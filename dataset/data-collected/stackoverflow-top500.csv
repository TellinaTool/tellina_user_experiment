Title,Id,Tags,Score,Body
"How to get the source directory of a Bash script from within the script itself?","59895","<bash><directory>","5229","<pre><code>#!/bin/bash

DIR=&quot;$( cd &quot;$( dirname &quot;${BASH_SOURCE[0]}&quot; )&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; pwd )&quot;
</code></pre>
<p>is a useful one-liner which will give you the full directory name of the script no matter where it is being called from.</p>
<p>It will work as long as the last component of the path used to find the script is not a symlink (directory links are OK).  If you also want to resolve any links to the script itself, you need a multi-line solution:</p>
<pre><code>#!/bin/bash

SOURCE=&quot;${BASH_SOURCE[0]}&quot;
while [ -h &quot;$SOURCE&quot; ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR=&quot;$( cd -P &quot;$( dirname &quot;$SOURCE&quot; )&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; pwd )&quot;
  SOURCE=&quot;$(readlink &quot;$SOURCE&quot;)&quot;
  [[ $SOURCE != /* ]] &amp;&amp; SOURCE=&quot;$DIR/$SOURCE&quot; # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR=&quot;$( cd -P &quot;$( dirname &quot;$SOURCE&quot; )&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; pwd )&quot;
</code></pre>
<p>This last one will work with any combination of aliases, <code>source</code>, <code>bash -c</code>, symlinks, etc.</p>
<p><strong>Beware:</strong> if you <code>cd</code> to a different directory before running this snippet, the result may be incorrect!</p>
<p>Also, watch out for <a href=""http://bosker.wordpress.com/2012/02/12/bash-scripters-beware-of-the-cdpath/"" rel=""noreferrer""><code>$CDPATH</code> gotchas</a>, and stderr output side effects if the user has smartly overridden cd to redirect output to stderr instead (including escape sequences, such as when calling <code>update_terminal_cwd &gt;&amp;2</code> on Mac). Adding <code>&gt;/dev/null 2&gt;&amp;1</code> at the end of your <code>cd</code> command will take care of both possibilities.</p>
<p>To understand how it works, try running this more verbose form:</p>
<pre><code>#!/bin/bash

SOURCE=&quot;${BASH_SOURCE[0]}&quot;
while [ -h &quot;$SOURCE&quot; ]; do # resolve $SOURCE until the file is no longer a symlink
  TARGET=&quot;$(readlink &quot;$SOURCE&quot;)&quot;
  if [[ $TARGET == /* ]]; then
    echo &quot;SOURCE '$SOURCE' is an absolute symlink to '$TARGET'&quot;
    SOURCE=&quot;$TARGET&quot;
  else
    DIR=&quot;$( dirname &quot;$SOURCE&quot; )&quot;
    echo &quot;SOURCE '$SOURCE' is a relative symlink to '$TARGET' (relative to '$DIR')&quot;
    SOURCE=&quot;$DIR/$TARGET&quot; # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  fi
done
echo &quot;SOURCE is '$SOURCE'&quot;
RDIR=&quot;$( dirname &quot;$SOURCE&quot; )&quot;
DIR=&quot;$( cd -P &quot;$( dirname &quot;$SOURCE&quot; )&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; pwd )&quot;
if [ &quot;$DIR&quot; != &quot;$RDIR&quot; ]; then
  echo &quot;DIR '$RDIR' resolves to '$DIR'&quot;
fi
echo &quot;DIR is '$DIR'&quot;
</code></pre>
<p>And it will print something like:</p>
<pre class=""lang-none prettyprint-override""><code>SOURCE './scriptdir.sh' is a relative symlink to 'sym2/scriptdir.sh' (relative to '.')
SOURCE is './sym2/scriptdir.sh'
DIR './sym2' resolves to '/home/ubuntu/dotfiles/fo fo/real/real1/real2'
DIR is '/home/ubuntu/dotfiles/fo fo/real/real1/real2'
</code></pre>
"
"How can I check if a directory exists in a Bash shell script?","59838","<bash><shell><unix><posix>","3870","<p>To check if a directory exists in a shell script, you can use the following:</p>

<pre><code>if [ -d ""$DIRECTORY"" ]; then
  # Control will enter here if $DIRECTORY exists.
fi
</code></pre>

<p>Or to check if a directory doesn't exist:</p>

<pre><code>if [ ! -d ""$DIRECTORY"" ]; then
  # Control will enter here if $DIRECTORY doesn't exist.
fi
</code></pre>

<hr>

<p>However, as <a href=""https://stackoverflow.com/users/1438/jon-ericson"">Jon Ericson</a> points out, subsequent commands may not work as intended if you do not take into account that a symbolic link to a directory will also pass this check.
E.g. running this:</p>

<pre><code>ln -s ""$ACTUAL_DIR"" ""$SYMLINK""
if [ -d ""$SYMLINK"" ]; then 
  rmdir ""$SYMLINK"" 
fi
</code></pre>

<p>Will produce the error message:</p>

<pre class=""lang-none prettyprint-override""><code>rmdir: failed to remove `symlink': Not a directory
</code></pre>

<p>So symbolic links may have to be treated differently, if subsequent commands expect directories:</p>

<pre><code>if [ -d ""$LINK_OR_DIR"" ]; then 
  if [ -L ""$LINK_OR_DIR"" ]; then
    # It is a symlink!
    # Symbolic link specific commands go here.
    rm ""$LINK_OR_DIR""
  else
    # It's a directory!
    # Directory command goes here.
    rmdir ""$LINK_OR_DIR""
  fi
fi
</code></pre>

<hr>

<p>Take particular note of the double-quotes used to wrap the variables. The reason for this is explained by 8jean <a href=""https://stackoverflow.com/a/67458/102401"">in another answer</a>.</p>

<p>If the variables contain spaces or other unusual characters it will probably cause the script to fail.</p>
"
"How do I tell if a regular file does not exist in Bash?","638975","<bash><file-io><scripting>","3421","<p>The <a href=""http://man7.org/linux/man-pages/man1/test.1.html"" rel=""noreferrer"">test</a> command (<code>[</code> here) has a ""not"" logical operator which is the exclamation point (similar to many other languages). Try this:</p>

<pre><code>if [ ! -f /tmp/foo.txt ]; then
    echo ""File not found!""
fi
</code></pre>
"
"How to concatenate string variables in Bash","4181703","<bash><shell><syntax><concat><string-concatenation>","2958","<pre><code>foo=""Hello""
foo=""${foo} World""
echo ""${foo}""
&gt; Hello World
</code></pre>

<p>In general to concatenate two variables you can just write them one after another:</p>

<pre><code>a='Hello'
b='World'
c=""${a} ${b}""
echo ""${c}""
&gt; Hello World
</code></pre>
"
"How to check if a string contains a substring in Bash","229551","<string><bash><shell><substring><sh>","2773","<p>You can use <a href=""https://stackoverflow.com/a/229585/3755692"">Marcus's answer (* wildcards)</a> outside a case statement, too, if you use double brackets:</p>

<pre><code>string='My long string'
if [[ $string == *""My long""* ]]; then
  echo ""It's there!""
fi
</code></pre>

<p>Note that spaces in the needle string need to be placed between double quotes, and the <code>*</code> wildcards should be outside. Also note that a simple comparison operator is used (i.e. <code>==</code>), not the regex operator <code>=~</code>.</p>
"
"Echo newline in Bash prints literal \n","8467424","<bash><echo><newline>","2632","<p>You could use <code>printf</code> instead:</p>

<pre><code>printf ""hello\nworld\n""
</code></pre>

<p><code>printf</code> has more consistent behavior than <code>echo</code>. The behavior of <code>echo</code> varies greatly between different versions.</p>
"
"In the shell, what does "" 2>&1 "" mean?","818255","<bash><shell><unix><redirect>","2441","<p>File descriptor 1 is the standard output (<code>stdout</code>).<br>
File descriptor 2 is the standard error (<code>stderr</code>).</p>
<p>Here is one way to remember this construct (although it is not entirely accurate): at first, <code>2&gt;1</code> may look like a good way to redirect <code>stderr</code> to <code>stdout</code>. However, it will actually be interpreted as &quot;redirect <code>stderr</code> to a file named <code>1</code>&quot;. <code>&amp;</code> indicates that what follows and precedes is a file descriptor and not a filename. So the construct becomes: <code>2&gt;&amp;1</code>.</p>
<p>Consider <code>&gt;&amp;</code> as redirect merger operator.</p>
"
"How can I check if a program exists from a Bash script?","592620","<bash>","2383","<h2>Answer</h2>
<p>POSIX compatible:</p>
<pre><code>command -v &lt;the_command&gt;
</code></pre>
<p>Example use:</p>
<pre><code>if ! command -v COMMAND &amp;&gt; /dev/null
then
    echo &quot;COMMAND could not be found&quot;
    exit
fi
</code></pre>
<p>For Bash specific environments:</p>
<pre><code>hash &lt;the_command&gt; # For regular commands. Or...
type &lt;the_command&gt; # To check built-ins and keywords
</code></pre>
<h2>Explanation</h2>
<p>Avoid <code>which</code>. Not only is it an external process you're launching for doing very little (meaning builtins like <code>hash</code>, <code>type</code> or <code>command</code> are way cheaper), you can also rely on the builtins to actually do what you want, while the effects of external commands can easily vary from system to system.</p>
<p>Why care?</p>
<ul>
<li>Many operating systems have a <code>which</code> that <strong>doesn't even set an exit status</strong>, meaning the <code>if which foo</code> won't even work there and will <strong>always</strong> report that <code>foo</code> exists, even if it doesn't (note that some POSIX shells appear to do this for <code>hash</code> too).</li>
<li>Many operating systems make <code>which</code> do custom and evil stuff like change the output or even hook into the package manager.</li>
</ul>
<p>So, don't use <code>which</code>. Instead use one of these:</p>
<pre><code>$ command -v foo &gt;/dev/null 2&gt;&amp;1 || { echo &gt;&amp;2 &quot;I require foo but it's not installed.  Aborting.&quot;; exit 1; }
$ type foo &gt;/dev/null 2&gt;&amp;1 || { echo &gt;&amp;2 &quot;I require foo but it's not installed.  Aborting.&quot;; exit 1; }
$ hash foo 2&gt;/dev/null || { echo &gt;&amp;2 &quot;I require foo but it's not installed.  Aborting.&quot;; exit 1; }
</code></pre>
<p>(Minor side-note: some will suggest <code>2&gt;&amp;-</code> is the same <code>2&gt;/dev/null</code> but shorter – <em>this is untrue</em>.  <code>2&gt;&amp;-</code> closes FD 2 which causes an <strong>error</strong> in the program when it tries to write to stderr, which is very different from successfully writing to it and discarding the output (and dangerous!))</p>
<p>If your hash bang is <code>/bin/sh</code> then you should care about what POSIX says. <code>type</code> and <code>hash</code>'s exit codes aren't terribly well defined by POSIX, and <code>hash</code> is seen to exit successfully when the command doesn't exist (haven't seen this with <code>type</code> yet).  <code>command</code>'s exit status is well defined by POSIX, so that one is probably the safest to use.</p>
<p>If your script uses <code>bash</code> though, POSIX rules don't really matter anymore and both <code>type</code> and <code>hash</code> become perfectly safe to use. <code>type</code> now has a <code>-P</code> to search just the <code>PATH</code> and <code>hash</code> has the side-effect that the command's location will be hashed (for faster lookup next time you use it), which is usually a good thing since you probably check for its existence in order to actually use it.</p>
<p>As a simple example, here's a function that runs <code>gdate</code> if it exists, otherwise <code>date</code>:</p>
<pre><code>gnudate() {
    if hash gdate 2&gt;/dev/null; then
        gdate &quot;$@&quot;
    else
        date &quot;$@&quot;
    fi
}
</code></pre>
<h1>Alternative with a complete feature set</h1>
<p>You can use <a href=""https://gitlab.com/bertrand-benoit/scripts-common"" rel=""noreferrer"">scripts-common</a> to reach your need.</p>
<p>To check if something is installed, you can do:</p>
<pre class=""lang-sh prettyprint-override""><code>checkBin &lt;the_command&gt; || errorMessage &quot;This tool requires &lt;the_command&gt;. Install it please, and then run this tool again.&quot;
</code></pre>
"
"Extract filename and extension in Bash","965053","<bash><string><filenames>","2251","<p>First, get file name without the path:</p>

<pre><code>filename=$(basename -- ""$fullfile"")
extension=""${filename##*.}""
filename=""${filename%.*}""
</code></pre>

<p>Alternatively, you can focus on the last '/' of the path instead of the '.' which should work even if you have unpredictable file extensions:</p>

<pre><code>filename=""${fullfile##*/}""
</code></pre>

<p>You may want to check the documentation :</p>

<ul>
<li>On the web at section ""<a href=""http://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html"" rel=""noreferrer"">3.5.3 Shell Parameter Expansion</a>""</li>
<li>In the bash manpage at section called ""Parameter Expansion""</li>
</ul>
"
"How do I split a string on a delimiter in Bash?","918886","<bash><shell><split><scripting>","2207","<p>You can set the <a href=""http://en.wikipedia.org/wiki/Internal_field_separator"" rel=""noreferrer"">internal field separator</a> (IFS) variable, and then let it parse into an array. When this happens in a command, then the assignment to <code>IFS</code> only takes place to that single command's environment (to <code>read</code> ). It then parses the input according to the <code>IFS</code> variable value into an array, which we can then iterate over.</p>

<pre><code>IFS=';' read -ra ADDR &lt;&lt;&lt; ""$IN""
for i in ""${ADDR[@]}""; do
    # process ""$i""
done
</code></pre>

<p>It will parse one line of items separated by <code>;</code>, pushing it into an array. Stuff for processing whole of <code>$IN</code>, each time one line of input separated by <code>;</code>:</p>

<pre><code> while IFS=';' read -ra ADDR; do
      for i in ""${ADDR[@]}""; do
          # process ""$i""
      done
 done &lt;&lt;&lt; ""$IN""
</code></pre>
"
"How do I parse command line arguments in Bash?","192249","<bash><command-line><scripting><arguments><getopts>","2062","<h1>Method #1: Using bash without getopt[s]</h1>

<p>Two common ways to pass key-value-pair arguments are:</p>

<h2>Bash Space-Separated (e.g., <code>--option argument</code>) (without getopt[s])</h2>

<p>Usage <code>demo-space-separated.sh -e conf -s /etc -l /usr/lib /etc/hosts</code></p>



<pre class=""lang-sh prettyprint-override""><code>cat &gt;/tmp/demo-space-separated.sh &lt;&lt;'EOF'
#!/bin/bash

POSITIONAL=()
while [[ $# -gt 0 ]]
do
key=""$1""

case $key in
    -e|--extension)
    EXTENSION=""$2""
    shift # past argument
    shift # past value
    ;;
    -s|--searchpath)
    SEARCHPATH=""$2""
    shift # past argument
    shift # past value
    ;;
    -l|--lib)
    LIBPATH=""$2""
    shift # past argument
    shift # past value
    ;;
    --default)
    DEFAULT=YES
    shift # past argument
    ;;
    *)    # unknown option
    POSITIONAL+=(""$1"") # save it in an array for later
    shift # past argument
    ;;
esac
done
set -- ""${POSITIONAL[@]}"" # restore positional parameters

echo ""FILE EXTENSION  = ${EXTENSION}""
echo ""SEARCH PATH     = ${SEARCHPATH}""
echo ""LIBRARY PATH    = ${LIBPATH}""
echo ""DEFAULT         = ${DEFAULT}""
echo ""Number files in SEARCH PATH with EXTENSION:"" $(ls -1 ""${SEARCHPATH}""/*.""${EXTENSION}"" | wc -l)
if [[ -n $1 ]]; then
    echo ""Last line of file specified as non-opt/last argument:""
    tail -1 ""$1""
fi
EOF

chmod +x /tmp/demo-space-separated.sh

/tmp/demo-space-separated.sh -e conf -s /etc -l /usr/lib /etc/hosts
</code></pre>

<p>output from copy-pasting the block above:</p>

<pre class=""lang-sh prettyprint-override""><code>FILE EXTENSION  = conf
SEARCH PATH     = /etc
LIBRARY PATH    = /usr/lib
DEFAULT         =
Number files in SEARCH PATH with EXTENSION: 14
Last line of file specified as non-opt/last argument:
#93.184.216.34    example.com
</code></pre>

<h2>Bash Equals-Separated (e.g., <code>--option=argument</code>) (without getopt[s])</h2>

<p>Usage <code>demo-equals-separated.sh -e=conf -s=/etc -l=/usr/lib /etc/hosts</code></p>

<pre class=""lang-sh prettyprint-override""><code>cat &gt;/tmp/demo-equals-separated.sh &lt;&lt;'EOF'
#!/bin/bash

for i in ""$@""
do
case $i in
    -e=*|--extension=*)
    EXTENSION=""${i#*=}""
    shift # past argument=value
    ;;
    -s=*|--searchpath=*)
    SEARCHPATH=""${i#*=}""
    shift # past argument=value
    ;;
    -l=*|--lib=*)
    LIBPATH=""${i#*=}""
    shift # past argument=value
    ;;
    --default)
    DEFAULT=YES
    shift # past argument with no value
    ;;
    *)
          # unknown option
    ;;
esac
done
echo ""FILE EXTENSION  = ${EXTENSION}""
echo ""SEARCH PATH     = ${SEARCHPATH}""
echo ""LIBRARY PATH    = ${LIBPATH}""
echo ""DEFAULT         = ${DEFAULT}""
echo ""Number files in SEARCH PATH with EXTENSION:"" $(ls -1 ""${SEARCHPATH}""/*.""${EXTENSION}"" | wc -l)
if [[ -n $1 ]]; then
    echo ""Last line of file specified as non-opt/last argument:""
    tail -1 $1
fi
EOF

chmod +x /tmp/demo-equals-separated.sh

/tmp/demo-equals-separated.sh -e=conf -s=/etc -l=/usr/lib /etc/hosts
</code></pre>

<p>output from copy-pasting the block above:</p>

<pre class=""lang-sh prettyprint-override""><code>FILE EXTENSION  = conf
SEARCH PATH     = /etc
LIBRARY PATH    = /usr/lib
DEFAULT         =
Number files in SEARCH PATH with EXTENSION: 14
Last line of file specified as non-opt/last argument:
#93.184.216.34    example.com
</code></pre>

<p>To better understand <code>${i#*=}</code> search for ""Substring Removal"" in <a href=""http://tldp.org/LDP/abs/html/string-manipulation.html"" rel=""noreferrer"">this guide</a>. It is functionally equivalent to <code>`sed 's/[^=]*=//' &lt;&lt;&lt; ""$i""`</code> which calls a needless subprocess or <code>`echo ""$i"" | sed 's/[^=]*=//'`</code> which calls <em>two</em> needless subprocesses. </p>

<h1>Method #2: Using bash with getopt[s]</h1>

<p>from: <a href=""http://mywiki.wooledge.org/BashFAQ/035#getopts"" rel=""noreferrer"">http://mywiki.wooledge.org/BashFAQ/035#getopts</a></p>

<p><strong>getopt(1) limitations</strong> (older, relatively-recent <code>getopt</code> versions): </p>

<ul>
<li>can't handle arguments that are empty strings</li>
<li>can't handle arguments with embedded whitespace</li>
</ul>

<p>More recent <code>getopt</code> versions don't have these limitations.</p>

<p>Additionally, the POSIX shell (and others) offer <code>getopts</code> which doesn't have these limitations. I've included a simplistic <code>getopts</code> example.</p>

<p>Usage <code>demo-getopts.sh -vf /etc/hosts foo bar</code></p>

<pre class=""lang-sh prettyprint-override""><code>cat &gt;/tmp/demo-getopts.sh &lt;&lt;'EOF'
#!/bin/sh

# A POSIX variable
OPTIND=1         # Reset in case getopts has been used previously in the shell.

# Initialize our own variables:
output_file=""""
verbose=0

while getopts ""h?vf:"" opt; do
    case ""$opt"" in
    h|\?)
        show_help
        exit 0
        ;;
    v)  verbose=1
        ;;
    f)  output_file=$OPTARG
        ;;
    esac
done

shift $((OPTIND-1))

[ ""${1:-}"" = ""--"" ] &amp;&amp; shift

echo ""verbose=$verbose, output_file='$output_file', Leftovers: $@""
EOF

chmod +x /tmp/demo-getopts.sh

/tmp/demo-getopts.sh -vf /etc/hosts foo bar
</code></pre>

<p>output from copy-pasting the block above:</p>

<pre class=""lang-sh prettyprint-override""><code>verbose=1, output_file='/etc/hosts', Leftovers: foo bar
</code></pre>

<p>The advantages of <code>getopts</code> are:</p>

<ol>
<li>It's more portable, and will work in other shells like <code>dash</code>.  </li>
<li>It can handle multiple single options like <code>-vf filename</code> in the typical Unix way, automatically.</li>
</ol>

<p>The disadvantage of <code>getopts</code> is that it can only handle short options (<code>-h</code>, not <code>--help</code>) without additional code.</p>

<p>There is a <a href=""http://wiki.bash-hackers.org/howto/getopts_tutorial"" rel=""noreferrer"">getopts tutorial</a> which explains what all of the syntax and variables mean.  In bash, there is also <code>help getopts</code>, which might be informative.</p>
"
"How do I set a variable to the output of a command in Bash?","4651437","<bash><shell><command-line>","1831","<p>In addition to backticks <code>`command`</code>, <a href=""http://www.gnu.org/software/bash/manual/bashref.html#Command-Substitution"" rel=""noreferrer"">command substitution</a> can be done with <code>$(command)</code> or <code>""$(command)""</code>, which I find easier to read, and allows for nesting.</p>

<pre><code>OUTPUT=$(ls -1)
echo ""${OUTPUT}""

MULTILINE=$(ls \
   -1)
echo ""${MULTILINE}""
</code></pre>

<p>Quoting (<code>""</code>) does matter to preserve <strong>multi-line variable values</strong>; it is optional on the right-hand side of an assignment, as <a href=""https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Parameters"" rel=""noreferrer"">word splitting is not performed</a>, so <code>OUTPUT=$(ls -1)</code> would work fine.</p>
"
"How to reload .bashrc settings without logging out and back in again?","2518127","<bash><shell><terminal><reload><profile>","1762","<p>You can enter the long form command:</p>
<pre><code>source ~/.bashrc
</code></pre>
<p>or you can use the shorter version of the command:</p>
<pre><code>. ~/.bashrc
</code></pre>
"
"How do I iterate over a range of numbers defined by variables in Bash?","169511","<bash><shell><for-loop><syntax>","1732","<pre><code>for i in $(seq 1 $END); do echo $i; done</code></pre>

<p>edit: I prefer <code>seq</code> over the other methods because I can actually remember it ;)</p>
"
"How to check if a variable is set in Bash?","3601515","<bash><shell><variables>","1726","<h2>(Usually) The right way</h2>

<pre><code>if [ -z ${var+x} ]; then echo ""var is unset""; else echo ""var is set to '$var'""; fi
</code></pre>

<p>where <code>${var+x}</code> is a <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02"" rel=""noreferrer"">parameter expansion</a> which evaluates to nothing if <code>var</code> is unset, and substitutes the string <code>x</code> otherwise.</p>

<h3>Quotes Digression</h3>

<p>Quotes can be omitted (so we can say <code>${var+x}</code> instead of <code>""${var+x}""</code>) because this syntax &amp; usage guarantees this will only expand to something that does not require quotes (since it either expands to <code>x</code> (which contains no word breaks so it needs no quotes), or to nothing (which results in <code>[ -z  ]</code>, which conveniently evaluates to the same value (true) that <code>[ -z """" ]</code> does as well)).</p>

<p>However, while quotes can be safely omitted, and it was not immediately obvious to all (it wasn't even apparent to <a href=""https://stackoverflow.com/users/2255628/destiny-architect"">the first author of this quotes explanation</a> who is also a major Bash coder), it would sometimes be better to write the solution with quotes as <code>[ -z ""${var+x}"" ]</code>, at the very small possible cost of an O(1) speed penalty.  The first author also added this as a comment next to the code using this solution giving the URL to this answer, which now also includes the explanation for why the quotes can be safely omitted.</p>

<h2>(Often) The wrong way</h2>

<pre><code>if [ -z ""$var"" ]; then echo ""var is blank""; else echo ""var is set to '$var'""; fi
</code></pre>

<p>This is often wrong because it doesn't distinguish between a variable that is unset and a variable that is set to the empty string. That is to say, if <code>var=''</code>, then the above solution will output ""var is blank"". </p>

<p>The distinction between unset and ""set to the empty string"" is essential in situations where the user has to specify an extension, or additional list of properties, and that not specifying them defaults to a non-empty value, whereas specifying the empty string should make the script use an empty extension or list of additional properties.</p>

<p>The distinction may not be essential in every scenario though. In those cases  <code>[ -z ""$var"" ]</code> will be just fine. </p>

<p></p>
"
"How can I count all the lines of code in a directory recursively?","1358540","<bash><shell>","1701","<p><strong>Try:</strong></p>
<pre><code>find . -name '*.php' | xargs wc -l
</code></pre>
<p><strong><a href=""http://www.dwheeler.com/sloccount/"" rel=""noreferrer"">The SLOCCount tool</a></strong> may help as well.</p>
<p>It will give an accurate source lines of code count for whatever
hierarchy you point it at, as well as some additional stats.</p>
<p><strong>Sorted output:</strong></p>
<p><code>find . -name '*.php' | xargs wc -l | sort -nr</code></p>
"
"Loop through an array of strings in Bash?","8880603","<arrays><bash><shell>","1630","<p>You can use it like this:</p>

<pre><code>## declare an array variable
declare -a arr=(""element1"" ""element2"" ""element3"")

## now loop through the above array
for i in ""${arr[@]}""
do
   echo ""$i""
   # or do whatever with individual element of the array
done

# You can access them using echo ""${arr[0]}"", ""${arr[1]}"" also
</code></pre>

<p>Also works for multi-line array declaration</p>

<pre><code>declare -a arr=(""element1"" 
                ""element2"" ""element3""
                ""element4""
                )
</code></pre>
"
"How to redirect and append both stdout and stderr to a file with Bash?","876239","<bash><append><stdout><io-redirection><stderr>","1607","<pre><code>cmd &gt;&gt;file.txt 2&gt;&amp;1
</code></pre>

<p>Bash executes the redirects from left to right as follows:</p>

<ol>
<li><code>&gt;&gt;file.txt</code>: Open <code>file.txt</code> in append mode and redirect <code>stdout</code> there.</li>
<li><code>2&gt;&amp;1</code>: Redirect <code>stderr</code> to <em>""where <code>stdout</code> is currently going""</em>. In this case, that is a file opened in append mode. In other words, the <code>&amp;1</code> reuses the file descriptor which <code>stdout</code> currently uses.</li>
</ol>
"
"How do I prompt for Yes/No/Cancel input in a Linux shell script?","226703","<linux><bash><shell><scripting>","1523","<p>The simplest and most widely available method to get user input at a shell prompt is the <a href=""https://www.gnu.org/software/bash/manual/bashref.html#index-read"" rel=""noreferrer""><code>read</code></a> command. The best way to illustrate its use is a simple demonstration:</p>

<pre><code>while true; do
    read -p ""Do you wish to install this program?"" yn
    case $yn in
        [Yy]* ) make install; break;;
        [Nn]* ) exit;;
        * ) echo ""Please answer yes or no."";;
    esac
done
</code></pre>

<p>Another method, <a href=""https://stackoverflow.com/a/226946/9084"">pointed out</a> by <a href=""https://stackoverflow.com/users/28604/steven-huwig"">Steven Huwig</a>, is Bash's <a href=""https://www.gnu.org/software/bash/manual/bashref.html#index-select"" rel=""noreferrer""><code>select</code></a> command. Here is the same example using <code>select</code>:</p>

<pre><code>echo ""Do you wish to install this program?""
select yn in ""Yes"" ""No""; do
    case $yn in
        Yes ) make install; break;;
        No ) exit;;
    esac
done
</code></pre>

<p>With <code>select</code> you don't need to sanitize the input &ndash; it displays the available choices, and you type a number corresponding to your choice. It also loops automatically, so there's no need for a <code>while true</code> loop to retry if they give invalid input.</p>

<p>Also, <a href=""https://stackoverflow.com/users/7939871/l%c3%a9a-gris"">Léa Gris</a> demonstrated a way to make the request language agnostic in <a href=""https://stackoverflow.com/a/57739142/9084"">her answer</a>. Adapting my first example to better serve multiple languages might look like this:</p>

<pre><code>set -- $(locale LC_MESSAGES)
yesptrn=""$1""; noptrn=""$2""; yesword=""$3""; noword=""$4""

while true; do
    read -p ""Install (${yesword} / ${noword})? "" yn
    case $yn in
        ${yesptrn##^} ) make install; break;;
        ${noptrn##^} ) exit;;
        * ) echo ""Answer ${yesword} / ${noword}."";;
    esac
done
</code></pre>

<p>Obviously other communication strings remain untranslated here (Install, Answer) which would need to be addressed in a more fully completed translation, but even a partial translation would be helpful in many cases.</p>

<p>Finally, please check out the <a href=""https://stackoverflow.com/a/27875395/9084"">excellent answer</a> by <a href=""https://stackoverflow.com/users/1765658/f-hauri"">F. Hauri</a>.</p>
"
"Looping through the content of a file in Bash","1521462","<linux><bash><loops><unix><io>","1518","<p>One way to do it is:</p>

<pre><code>while read p; do
  echo ""$p""
done &lt;peptides.txt
</code></pre>

<p>As pointed out in the comments, this has the side effects of trimming leading whitespace, interpreting backslash sequences, and skipping the last line if it's missing a terminating linefeed. If these are concerns, you can do:</p>

<pre><code>while IFS="""" read -r p || [ -n ""$p"" ]
do
  printf '%s\n' ""$p""
done &lt; peptides.txt
</code></pre>

<hr>

<p>Exceptionally, if the <a href=""https://unix.stackexchange.com/questions/107800/using-while-loop-to-ssh-to-multiple-servers"">loop body may read from standard input</a>, you can open the file using a different file descriptor:</p>

<pre><code>while read -u 10 p; do
  ...
done 10&lt;peptides.txt
</code></pre>

<p>Here, 10 is just an arbitrary number (different from 0, 1, 2).</p>
"
"Check existence of input argument in a Bash shell script","6482377","<bash><shell>","1478","<p>It is:</p>
<pre class=""lang-bash prettyprint-override""><code>if [ $# -eq 0 ]
  then
    echo &quot;No arguments supplied&quot;
fi
</code></pre>
<p>The <code>$#</code> variable will tell you the number of input arguments the script was passed.</p>
<p>Or you can check if an argument is an empty string or not like:</p>
<pre><code>if [ -z &quot;$1&quot; ]
  then
    echo &quot;No argument supplied&quot;
fi
</code></pre>
<p>The <code>-z</code> switch will test if the expansion of &quot;$1&quot; is a null string or not. If it is a null string then the body is executed.</p>
"
"Make a Bash alias that takes a parameter?","7131670","<bash><alias>","1378","<p>Bash alias does not directly accept parameters. You will have to create a function.</p>

<p><code>alias</code> does not accept parameters but a function can be called just like an alias. For example:</p>

<pre><code>myfunction() {
    #do things with parameters like $1 such as
    mv ""$1"" ""$1.bak""
    cp ""$2"" ""$1""
}


myfunction old.conf new.conf #calls `myfunction`
</code></pre>

<p>By the way, Bash functions defined in your <code>.bashrc</code> and other files are available as commands within your shell. So for instance you can call the earlier function like this </p>

<pre><code>$ myfunction original.conf my.conf
</code></pre>
"
"How to convert a string to lower case in Bash?","2264428","<string><bash><shell><lowercase>","1350","<p>The are various ways:</p>

<h2><a href=""https://en.wikipedia.org/wiki/POSIX"" rel=""noreferrer"">POSIX standard</a></h2>

<h3><a href=""http://en.wikipedia.org/wiki/Tr_%28Unix%29"" rel=""noreferrer"">tr</a></h3>

<pre><code>$ echo ""$a"" | tr '[:upper:]' '[:lower:]'
hi all
</code></pre>

<h3><a href=""http://en.wikipedia.org/wiki/AWK"" rel=""noreferrer"">AWK</a></h3>

<pre><code>$ echo ""$a"" | awk '{print tolower($0)}'
hi all
</code></pre>

<h2>Non-POSIX</h2>

<p>You may run into portability issues with the following examples:</p>

<h3><a href=""https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29"" rel=""noreferrer"">Bash 4.0</a></h3>

<pre><code>$ echo ""${a,,}""
hi all
</code></pre>

<h3><a href=""http://en.wikipedia.org/wiki/Sed"" rel=""noreferrer"">sed</a></h3>

<pre><code>$ echo ""$a"" | sed -e 's/\(.*\)/\L\1/'
hi all
# this also works:
$ sed -e 's/\(.*\)/\L\1/' &lt;&lt;&lt; ""$a""
hi all
</code></pre>

<h3><a href=""http://en.wikipedia.org/wiki/Perl"" rel=""noreferrer"">Perl</a></h3>

<pre><code>$ echo ""$a"" | perl -ne 'print lc'
hi all
</code></pre>

<h3><a href=""https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29"" rel=""noreferrer"">Bash</a></h3>

<pre><code>lc(){
    case ""$1"" in
        [A-Z])
        n=$(printf ""%d"" ""'$1"")
        n=$((n+32))
        printf \\$(printf ""%o"" ""$n"")
        ;;
        *)
        printf ""%s"" ""$1""
        ;;
    esac
}
word=""I Love Bash""
for((i=0;i&lt;${#word};i++))
do
    ch=""${word:$i:1}""
    lc ""$ch""
done
</code></pre>

<p>Note: YMMV on this one. Doesn't work for me (GNU bash version 4.2.46 and 4.0.33 (and same behaviour 2.05b.0 but nocasematch is not implemented)) even with using <code>shopt -u nocasematch;</code>. Unsetting that nocasematch causes [[ ""fooBaR"" == ""FOObar"" ]] to match OK BUT inside case weirdly [b-z] are incorrectly matched by [A-Z]. Bash is confused by the double-negative (""unsetting nocasematch"")! :-)</p>
"
"How to specify the private SSH-key to use when executing shell command on Git?","4565700","<git><bash><shell><ssh>","1254","<p>Something like this should work (suggested by orip):</p>

<pre><code>ssh-agent bash -c 'ssh-add /somewhere/yourkey; git clone git@github.com:user/project.git'
</code></pre>

<p>if you prefer subshells, you could try the following (though it is more fragile):</p>

<pre><code>ssh-agent $(ssh-add /somewhere/yourkey; git clone git@github.com:user/project.git)
</code></pre>

<p>Git will invoke SSH which will find its agent by environment variable; this will, in turn, have the key loaded.</p>

<p>Alternatively, setting <code>HOME</code> may also do the trick, provided you are willing to setup a directory that contains only a <code>.ssh</code> directory as <code>HOME</code>; this may either contain an identity.pub, or a <a href=""http://linux.die.net/man/5/ssh_config"" rel=""noreferrer"">config file</a> setting IdentityFile.</p>
"
"echo that outputs to stderr","2990414","<bash>","1227","<p>You could do this, which facilitates reading:</p>

<pre><code>&gt;&amp;2 echo ""error""
</code></pre>

<p><code>&gt;&amp;2</code> copies file descriptor #2 to file descriptor #1. Therefore, after this redirection is performed, both file descriptors will refer to the same file: the one file descriptor #2 was <strong>originally</strong> referring to. For more information see the <a href=""http://wiki.bash-hackers.org/howto/redirection_tutorial"" rel=""noreferrer"">Bash Hackers Illustrated Redirection Tutorial</a>.</p>
"
"What is the preferred Bash shebang?","10376206","<bash><shebang>","1200","<p>You should use <strong><code>#!/usr/bin/env bash</code></strong> for <a href=""https://en.wikipedia.org/w/index.php?title=Shebang_(Unix)&amp;oldid=878552871#Portability"" rel=""noreferrer"">portability</a>: different *nixes put <code>bash</code> in different places, and using <code>/usr/bin/env</code> is a workaround to run the first <code>bash</code> found on the <code>PATH</code>. And <strong><a href=""https://mywiki.wooledge.org/BashGuide/CommandsAndArguments#Scripts"" rel=""noreferrer""><code>sh</code> is not <code>bash</code></a></strong>.</p>
"
"YYYY-MM-DD format date in shell script","1401482","<bash><shell><date><strftime>","1172","<p>In bash (>=4.2) it is preferable to use printf's built-in date formatter (part of bash) rather than the external <code>date</code> (usually GNU date).</p>

<p>As such:</p>

<pre><code># put current date as yyyy-mm-dd in $date
# -1 -&gt; explicit current date, bash &gt;=4.3 defaults to current time if not provided
# -2 -&gt; start time for shell
printf -v date '%(%Y-%m-%d)T\n' -1 

# put current date as yyyy-mm-dd HH:MM:SS in $date
printf -v date '%(%Y-%m-%d %H:%M:%S)T\n' -1 

# to print directly remove -v flag, as such:
printf '%(%Y-%m-%d)T\n' -1
# -&gt; current date printed to terminal
</code></pre>

<p>In bash (&lt;4.2): </p>

<pre><code># put current date as yyyy-mm-dd in $date
date=$(date '+%Y-%m-%d')

# put current date as yyyy-mm-dd HH:MM:SS in $date
date=$(date '+%Y-%m-%d %H:%M:%S')

# print current date directly
echo $(date '+%Y-%m-%d')
</code></pre>

<p>Other available date formats can be viewed from the <a href=""http://man7.org/linux/man-pages/man1/date.1.html"" rel=""noreferrer"">date man pages</a> (for external non-bash specific command):</p>

<pre><code>man date
</code></pre>
"
"How to count lines in a document?","3137094","<linux><bash><command-line><scripting>","1169","<p>Use <code>wc</code>:</p>

<pre><code>wc -l &lt;filename&gt;
</code></pre>

<p>This will output the number of lines in <code>&lt;filename&gt;</code>:</p>

<pre><code>$ wc -l /dir/file.txt
3272485 /dir/file.txt
</code></pre>

<p>Or, to omit the <code>&lt;filename&gt;</code> from the result use <code>wc -l &lt; &lt;filename&gt;</code>:</p>

<pre><code>$ wc -l &lt; /dir/file.txt
3272485
</code></pre>

<p>You can also pipe data to <code>wc</code> as well:</p>

<pre><code>$ cat /dir/file.txt | wc -l
3272485
$ curl yahoo.com --silent | wc -l
63
</code></pre>
"
"How to redirect output to a file and stdout","418896","<linux><bash><file-io><io><stdout>","1097","<p>The command you want is named <strong><a href=""http://www.gnu.org/software/coreutils/manual/html_node/tee-invocation.html"" rel=""noreferrer""><code>tee</code></a></strong>:</p>

<pre><code>foo | tee output.file
</code></pre>

<p>For example, if you only care about stdout:</p>

<pre><code>ls -a | tee output.file
</code></pre>

<p>If you want to include stderr, do:</p>

<pre><code>program [arguments...] 2&gt;&amp;1 | tee outfile
</code></pre>

<p><code>2&gt;&amp;1</code> redirects channel 2 (stderr/standard error) into channel 1 (stdout/standard output), such that both is written as stdout. It is also directed to the given output file as of the <code>tee</code> command.</p>

<p>Furthermore, if you want to <em>append</em> to the log file, use <code>tee -a</code> as:</p>

<pre><code>program [arguments...] 2&gt;&amp;1 | tee -a outfile
</code></pre>
"
"How to escape single quotes within single quoted strings","1250079","<bash><syntax><quoting>","1096","<p>If you really want to use single quotes in the outermost layer, remember that you can glue both kinds of quotation. Example:</p>

<pre><code> alias rxvt='urxvt -fg '""'""'#111111'""'""' -bg '""'""'#111111'""'""
 #                     ^^^^^       ^^^^^     ^^^^^       ^^^^
 #                     12345       12345     12345       1234
</code></pre>

<p>Explanation of how <code>'""'""'</code> is interpreted as just <code>'</code>:</p>

<ol>
<li><code>'</code> End first quotation which uses single quotes.</li>
<li><code>""</code> Start second quotation, using double-quotes.</li>
<li><code>'</code> Quoted character.</li>
<li><code>""</code> End second quotation, using double-quotes.</li>
<li><code>'</code> Start third quotation, using single quotes.</li>
</ol>

<p>If you do not place any whitespaces between (1) and (2), or between (4) and (5), the shell will interpret that string as a one long word.</p>
"
"How can I declare and use Boolean variables in a shell script?","2953646","<bash><shell><scripting><boolean><sh>","1070","<p><strong>Revised Answer (Feb 12, 2014)</strong></p>

<pre><code>the_world_is_flat=true
# ...do something interesting...
if [ ""$the_world_is_flat"" = true ] ; then
    echo 'Be careful not to fall off!'
fi
</code></pre>

<hr>

<p><strong>Original Answer</strong></p>

<p>Caveats: <a href=""https://stackoverflow.com/a/21210966/89391"">https://stackoverflow.com/a/21210966/89391</a></p>

<pre><code>the_world_is_flat=true
# ...do something interesting...
if $the_world_is_flat ; then
    echo 'Be careful not to fall off!'
fi
</code></pre>

<p>From: <a href=""https://github.com/aperezdc/perezdecastro.org/blob/master/stash/using-boolean-variables-in-bash.markdown"" rel=""noreferrer"">Using boolean variables in Bash</a></p>

<p><em>The reason the original answer is included here is because the comments before the revision on Feb 12, 2014 pertain only to the original answer, and many of the comments are wrong when associated with the revised answer. For example, Dennis Williamson's comment about bash builtin <code>true</code> on Jun 2, 2010 only applies to the original answer, not the revised.</em></p>
"
"Passing parameters to a Bash function","6212219","<bash><parameters><arguments>","1066","<p>There are two typical ways of declaring a function. I prefer the second approach.</p>
<pre><code>function function_name {
   command...
} 
</code></pre>
<p>or</p>
<pre><code>function_name () {
   command...
} 
</code></pre>
<p>To call a function with arguments:</p>
<pre><code>function_name &quot;$arg1&quot; &quot;$arg2&quot;
</code></pre>
<p>The function refers to passed arguments by their position (not by name), that is <code>$1</code>, <code>$2</code>, and so forth. <strong><code>$0</code></strong> is the name of the script itself.</p>
<p>Example:</p>
<pre><code>function_name () {
   echo &quot;Parameter #1 is $1&quot;
}
</code></pre>
<p>Also, you need to call your function <strong>after</strong> it is declared.</p>
<pre><code>#!/usr/bin/env sh

foo 1  # this will fail because foo has not been declared yet.

foo() {
    echo &quot;Parameter #1 is $1&quot;
}

foo 2 # this will work.
</code></pre>
<p><strong>Output:</strong></p>
<pre class=""lang-none prettyprint-override""><code>./myScript.sh: line 2: foo: command not found
Parameter #1 is 2
</code></pre>
<p><a href=""http://tldp.org/LDP/abs/html/complexfunct.html"" rel=""noreferrer"">Reference: Advanced Bash-Scripting Guide</a>.</p>
"
"How can I pipe stderr, and not stdout?","2342826","<bash><grep><stdout><pipe><stderr>","1045","<p>First redirect stderr to stdout — the pipe; then redirect stdout to <code>/dev/null</code> (without changing where stderr is going):</p>
<pre><code>command 2&gt;&amp;1 &gt;/dev/null | grep 'something'
</code></pre>
<p>For the details of I/O redirection in all its variety, see the chapter on <a href=""http://www.gnu.org/software/bash/manual/bash.html#Redirections"" rel=""noreferrer"">Redirections</a> in the Bash reference manual.</p>
<p>Note that the sequence of I/O redirections is interpreted left-to-right, but pipes are set up before the I/O redirections are interpreted.  File descriptors such as 1 and 2 are references to open file descriptions.  The operation <code>2&gt;&amp;1</code> makes file descriptor 2 aka stderr refer to the same open file description as file descriptor 1 aka stdout is currently referring to (see <a href=""https://pubs.opengroup.org/onlinepubs/9699919799/functions/dup2.html"" rel=""noreferrer""><code>dup2()</code></a> and <a href=""https://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html"" rel=""noreferrer""><code>open()</code></a>).  The operation <code>&gt;/dev/null</code> then changes file descriptor 1 so that it refers to an open file description for <code>/dev/null</code>, but that doesn't change the fact that file descriptor 2 refers to the open file description which file descriptor 1 was originally pointing to — namely, the pipe.</p>
"
"How to reload .bash_profile from the command line?","4608187","<bash><shell><command-line>","1044","<p>Simply type <code>source ~/.bash_profile</code></p>

<p>Alternatively, if you like saving keystrokes you can type <code>. ~/.bash_profile</code></p>
"
"Pipe to/from the clipboard in Bash script","749544","<linux><bash><macos><clipboard>","1040","<p>There's a wealth of clipboards you could be dealing with.  I expect you're probably a Linux user who wants to put stuff in the X Windows primary clipboard.  Usually, the clipboard you want to talk to has a utility that lets you talk to it.</p>

<p>In the case of X, there's <code>xclip</code> (and others). <code>xclip -selection c</code> will send data to the clipboard that works with <kbd>Ctrl + C</kbd>, <kbd>Ctrl + V</kbd> in most applications.</p>

<p>If you're on Mac OS X, there's <code>pbcopy</code>. e.g <code>cat example.txt | pbcopy</code></p>

<p>If you're in Linux terminal mode (no X) then look into <code>gpm</code> or <a href=""http://www.gnu.org/software/screen/"" rel=""noreferrer"">screen</a> which has a clipboard.  Try the <code>screen</code> command <code>readreg</code>.</p>

<p>Under Windows 10+ or cygwin, use <code>/dev/clipboard</code> or <code>clip</code>.</p>
"
"Listing only directories using ls in Bash?","14352290","<bash><directory><ls>","1024","<p><code>*/</code> is a pattern that matches all of the subdirectories in the current directory (<code>*</code> would match all files <em>and</em> subdirectories; the <code>/</code> restricts it to directories). Similarly, to list all subdirectories under /home/alice/Documents, use <code>ls -d /home/alice/Documents/*/</code></p>
"
"Defining a variable with or without export","1158091","<linux><bash><shell>","1024","<p><code>export</code> makes the variable available to sub-processes.</p>

<p>That is,</p>

<pre><code>export name=value
</code></pre>

<p>means that the variable name is available to <em>any process</em> you run from that shell process. If you want a process to make use of this variable, use <code>export</code>, and run the process from that shell.</p>

<pre><code>name=value
</code></pre>

<p>means the variable scope is restricted to the shell, and is not available to any other process. You would use this for (say) loop variables, temporary variables etc.</p>

<p>It's important to note that exporting a variable doesn't make it available to parent processes. That is, specifying and exporting a variable in a spawned process doesn't make it available in the process that launched it.</p>
"
"How to compare strings in Bash","2237080","<string><bash>","1018","<h1>Using variables in if statements</h1>

<pre><code>if [ ""$x"" = ""valid"" ]; then
  echo ""x has the value 'valid'""
fi
</code></pre>

<p>If you want to do something when they don't match, replace <code>=</code> with <code>!=</code>. You can read more about <a href=""http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-11.html#ss11.1"" rel=""noreferrer"">string operations</a> and <a href=""http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-11.html#ss11.3"" rel=""noreferrer"">arithmetic operations</a> in their respective documentation.</p>

<h3>Why do we use quotes around <code>$x</code>?</h3>

<p>You want the quotes around <code>$x</code>, because if it is empty, your Bash script encounters a syntax error as seen below:</p>

<pre><code>if [ = ""valid"" ]; then
</code></pre>

<hr>

<h3>Non-standard use of <code>==</code> operator</h3>

<p>Note that Bash allows <code>==</code> to be used for equality with <code>[</code>, but <a href=""http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-6.html"" rel=""noreferrer"">this is not standard</a>.</p>

<p>Use either the first case wherein the quotes around <code>$x</code> are optional:</p>

<pre><code>if [[ ""$x"" == ""valid"" ]]; then
</code></pre>

<p>or use the second case:</p>

<pre><code>if [ ""$x"" = ""valid"" ]; then
</code></pre>
"
"How to echo shell commands as they are executed","2853803","<bash><shell><sh><posix><trace>","997","<p><code>set -x</code> or <code>set -o xtrace</code> expands variables and prints a little + sign before the line.</p>

<p><code>set -v</code> or <code>set -o verbose</code> does not expand the variables before printing.</p>

<p>Use <code>set +x</code> and <code>set +v</code> to turn off the above settings.</p>

<p>On the first line of the script, one can put <code>#!/bin/sh -x</code> (or <code>-v</code>) to have the same effect as <code>set -x</code> (or <code>-v</code>) later in the script.</p>

<p>The above also works with <code>/bin/sh</code>.</p>

<p>See the bash-hackers' wiki on <a href=""https://wiki.bash-hackers.org/commands/builtin/set#attributes"" rel=""noreferrer""><code>set</code> attributes</a>, and on <a href=""https://wiki.bash-hackers.org/scripting/debuggingtips"" rel=""noreferrer"">debugging</a>.</p>

<pre><code>$ cat shl
#!/bin/bash                                                                     

DIR=/tmp/so
ls $DIR

$ bash -x shl 
+ DIR=/tmp/so
+ ls /tmp/so
$
</code></pre>
"
"Parsing JSON with Unix tools","1955505","<json><bash><parsing>","963","<p>There are a number of tools specifically designed for the purpose of manipulating JSON from the command line, and will be a lot easier and more reliable than doing it with Awk, such as <a href=""https://stedolan.github.io/jq/"" rel=""noreferrer""><code>jq</code></a>:</p>
<pre><code>curl -s 'https://api.github.com/users/lambda' | jq -r '.name'
</code></pre>
<p>You can also do this with tools that are likely already installed on your system, like Python using the <a href=""https://docs.python.org/2/library/json.html"" rel=""noreferrer""><code>json</code> module</a>, and so avoid any extra dependencies, while still having the benefit of a proper JSON parser. The following assume you want to use UTF-8, which the original JSON should be encoded in and is what most modern terminals use as well:</p>
<p>Python 3:</p>
<pre><code>curl -s 'https://api.github.com/users/lambda' | \
    python3 -c &quot;import sys, json; print(json.load(sys.stdin)['name'])&quot;
</code></pre>
<p>Python 2:</p>
<pre><code>export PYTHONIOENCODING=utf8
curl -s 'https://api.github.com/users/lambda' | \
    python2 -c &quot;import sys, json; print json.load(sys.stdin)['name']&quot;
</code></pre>
<h2>Frequently Asked Questions</h2>
<h3>Why not a pure shell solution?</h3>
<p>The standard <a href=""https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html"" rel=""noreferrer"">POSIX/Single Unix Specification shell</a> is a very limited language which doesn't contain facilities for representing sequences (list or arrays) or associative arrays (also known as hash tables, maps, dicts, or objects in some other languages). This makes representing the result of parsing JSON somewhat tricky in portable shell scripts. There are <a href=""https://stackoverflow.com/questions/688849/associative-arrays-in-shell-scripts"">somewhat hacky ways to do it</a>, but many of them can break if keys or values contain certain special characters.</p>
<p>Bash 4 and later, zsh, and ksh have support for arrays and associative arrays, but these shells are not universally available (macOS stopped updating Bash at Bash 3, due to a change from GPLv2 to GPLv3, while many Linux systems don't have zsh installed out of the box). It's possible that you could write a script that would work in either Bash 4 or zsh, one of which is available on most macOS, Linux, and BSD systems these days, but it would be tough to write a shebang line that worked for such a polyglot script.</p>
<p>Finally, writing a full fledged JSON parser in shell would be a significant enough enough dependency that you might as well just use an existing dependency like jq or Python instead. It's not going to be a one-liner, or even small five-line snippet, to do a good implementation.</p>
<h3>Why not use awk, sed, or grep?</h3>
<p>It is possible to use these tools to do some quick extraction from JSON with a known shape and formatted in a known way, such as one key per line. There are several examples of suggestions for this in other answers.</p>
<p>However, these tools are designed for line based or record based formats; they are not designed for recursive parsing of matched delimiters with possible escape characters.</p>
<p>So these quick and dirty solutions using awk/sed/grep are likely to be fragile, and break if some aspect of the input format changes, such as collapsing whitespace, or adding additional levels of nesting to the JSON objects, or an escaped quote within a string. A solution that is robust enough to handle all JSON input without breaking will also be fairly large and complex, and so not too much different than adding another dependency on <code>jq</code> or Python.</p>
<p>I have had to deal with large amounts of customer data being deleted due to poor input parsing in a shell script before, so I never recommend quick and dirty methods that may be fragile in this way. If you're doing some one-off processing, see the other answers for suggestions, but I still highly recommend just using an existing tested JSON parser.</p>
<h2>Historical notes</h2>
<p>This answer originally recommended <a href=""http://github.com/micha/jsawk"" rel=""noreferrer"">jsawk</a>, which should still work, but is a little more cumbersome to use than <code>jq</code>, and depends on a standalone JavaScript interpreter being installed which is less common than a Python interpreter, so the above answers are probably preferable:</p>
<pre><code>curl -s 'https://api.github.com/users/lambda' | jsawk -a 'return this.name'
</code></pre>
<p>This answer also originally used the Twitter API from the question, but that API no longer works, making it hard to copy the examples to test out, and the new Twitter API requires API keys, so I've switched to using the GitHub API which can be used easily without API keys.  The first answer for the original question would be:</p>
<pre><code>curl 'http://twitter.com/users/username.json' | jq -r '.text'
</code></pre>
"
"How to iterate over arguments in a Bash script","255898","<bash><command-line>","950","<p>Use <code>""$@""</code> to represent all the arguments:</p>

<pre><code>for var in ""$@""
do
    echo ""$var""
done
</code></pre>

<p>This will iterate over each argument and print it out on a separate line.  $@ behaves like $* except that when quoted the arguments are broken up properly if there are spaces in them:</p>

<pre><code>sh test.sh 1 2 '3 4'
1
2
3 4
</code></pre>
"
"How to permanently set $PATH on Linux/Unix?","14637979","<linux><bash><unix><path><zsh>","925","<p>There are multiple ways to do it. The actual solution depends on the purpose.</p>

<p>The variable values are usually stored in either a list of assignments or a shell script that is run at the start of the system or user session. In case of the shell script you must use a specific shell syntax and <code>export</code> or <code>set</code> commands.</p>

<h2>System wide</h2>

<ol>
<li><code>/etc/environment</code> List of unique assignments, allows references. Perfect for adding system-wide directories like <code>/usr/local/something/bin</code> to <code>PATH</code> variable or defining <code>JAVA_HOME</code>. Used by PAM and SystemD. </li>
<li><code>/etc/environment.d/*.conf</code> List of unique assignments, allows references. Perfect for adding system-wide directories like <code>/usr/local/something/bin</code> to <code>PATH</code> variable or defining <code>JAVA_HOME</code>. The configuration can be split into multiple files, usually one per each tool (Java, Go, NodeJS). Used by SystemD that by design do not pass those values to user login shells. </li>
<li><code>/etc/xprofile</code> Shell script executed while starting X Window System session. This is run for every user that logs into X Window System. It is a good choice for <code>PATH</code> entries that are valid for every user like <code>/usr/local/something/bin</code>. The file is included by other script so use POSIX shell syntax not the syntax of your user shell.</li>
<li><code>/etc/profile</code> and <code>/etc/profile.d/*</code> Shell script. This is a good choice for shell-only systems. Those files are read only by shells in login mode.</li>
<li><code>/etc/&lt;shell&gt;.&lt;shell&gt;rc</code>. Shell script. This is a poor choice because it is single shell specific. Used in non-login mode.</li>
</ol>

<h2>User session</h2>

<ol>
<li><code>~/.pam_environment</code>. List of unique assignments, no references allowed. Loaded by PAM at the start of every user session irrelevant if it is an X Window System session or shell. You cannot reference other variables including <code>HOME</code> or <code>PATH</code> so it has limited use. Used by PAM.</li>
<li><code>~/.xprofile</code> Shell script. This is executed when the user logs into X Window System system. The variables defined here are visible to every X application. Perfect choice for extending <code>PATH</code> with values such as <code>~/bin</code> or <code>~/go/bin</code> or defining user specific <code>GOPATH</code> or <code>NPM_HOME</code>. The file is included by other script so use POSIX shell syntax not the syntax of your user shell. Your graphical text editor or IDE started by shortcut will see those values.</li>
<li><code>~/.profile</code>, <code>~/.&lt;shell&gt;_profile</code>, <code>~/.&lt;shell&gt;_login</code> Shell script. It will be visible only for programs started from terminal or terminal emulator. It is a good choice for shell-only systems. Used by shells in login mode.</li>
<li><code>~/.&lt;shell&gt;rc</code>. Shell script. This is a poor choice because it is single shell specific. Used by shells in non-login mode.</li>
</ol>

<h2>Notes</h2>

<p>Gnome on Wayland starts user login shell to get the environment. It effectively uses login shell configurations <code>~/.profile</code>, <code>~/.&lt;shell&gt;_profile</code>, <code>~/.&lt;shell&gt;_login</code> files.</p>

<h2>Manuals</h2>

<ul>
<li>environment</li>
<li>environment.d</li>
<li>bash</li>
<li>dash</li>
</ul>

<h2>Distribution specific documentation</h2>

<ul>
<li><a href=""https://help.ubuntu.com/community/EnvironmentVariables#Persistent_environment_variables"" rel=""noreferrer"">Ubuntu</a></li>
<li><a href=""https://wiki.archlinux.org/index.php/Environment_variables"" rel=""noreferrer"">archlinux</a></li>
</ul>

<h2>Related</h2>

<p><a href=""https://unix.stackexchange.com/a/46856/39410"">Difference between Login Shell and Non-Login Shell?</a></p>
"
"Propagate all arguments in a bash shell script","4824590","<bash><command-line-arguments>","921","<p>Use <code>&quot;$@&quot;</code> instead of plain <code>$@</code> if you actually wish your parameters to be passed the same.</p>
<p>Observe:</p>
<pre><code>$ cat no_quotes.sh
#!/bin/bash
echo_args.sh $@

$ cat quotes.sh
#!/bin/bash
echo_args.sh &quot;$@&quot;

$ cat echo_args.sh
#!/bin/bash
echo Received: $1
echo Received: $2
echo Received: $3
echo Received: $4

$ ./no_quotes.sh first second
Received: first
Received: second
Received:
Received:

$ ./no_quotes.sh &quot;one quoted arg&quot;
Received: one
Received: quoted
Received: arg
Received:

$ ./quotes.sh first second
Received: first
Received: second
Received:
Received:

$ ./quotes.sh &quot;one quoted arg&quot;
Received: one quoted arg
Received:
Received:
Received:
</code></pre>
"
"Replace one substring for another string in shell script","13210880","<bash><shell>","917","<p>To replace the <em>first</em> occurrence of a pattern with a given string, use <code>${<em>parameter</em>/<em>pattern</em>/<em>string</em>}</code>:</p>

<pre><code>#!/bin/bash
firstString=""I love Suzi and Marry""
secondString=""Sara""
echo ""${firstString/Suzi/$secondString}""    
# prints 'I love Sara and Marry'
</code></pre>

<p>To replace <em>all</em> occurrences, use <code>${<em>parameter</em>//<em>pattern</em>/<em>string</em>}</code>:</p>

<pre><code>message='The secret code is 12345'
echo ""${message//[0-9]/X}""           
# prints 'The secret code is XXXXX'
</code></pre>

<p>(This is documented in <a href=""https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion"" rel=""noreferrer"">the <em>Bash Reference Manual</em>, &sect;3.5.3 ""Shell Parameter Expansion""</a>.)</p>

<p>Note that this feature is not specified by POSIX &mdash; it's a Bash extension &mdash; so not all Unix shells implement it. For the relevant POSIX documentation, see <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02"" rel=""noreferrer""><em>The Open Group Technical Standard Base Specifications, Issue 7</em>, the <em>Shell &amp; Utilities</em> volume, &sect;2.6.2 ""Parameter Expansion""</a>.</p>
"
"How do I clear/delete the current line in terminal?","9679776","<bash><terminal>","880","<p>You can use <kbd>Ctrl</kbd>+<kbd>U</kbd> to clear up to the beginning.</p>

<p>You can use <kbd>Ctrl</kbd>+<kbd>W</kbd> to delete just a word.</p>

<p>You can also use <kbd>Ctrl</kbd>+<kbd>C</kbd> to cancel.</p>

<p>If you want to keep the history, you can use <kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>#</kbd> to make it a comment.</p>

<hr>

<p><sub><a href=""http://www.catonmat.net/blog/bash-emacs-editing-mode-cheat-sheet/"" rel=""noreferrer"">Bash Emacs Editing Mode Cheat Sheet</a></sub></p>
"
"Get current directory name (without full path) in a Bash script","1371261","<bash><shell>","875","<p>No need for basename, and especially no need for a subshell running pwd (which <A HREF=""http://mywiki.wooledge.org/SubShell"" rel=""noreferrer"">adds an extra, and expensive, fork operation</A>); the shell can do this internally using <A HREF=""http://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html"" rel=""noreferrer"">parameter expansion</A>:</p>

<pre class=""lang-none prettyprint-override""><code>result=${PWD##*/}          # to assign to a variable

printf '%s\n' ""${PWD##*/}"" # to print to stdout
                           # ...more robust than echo for unusual names
                           #    (consider a directory named -e or -n)

printf '%q\n' ""${PWD##*/}"" # to print to stdout, quoted for use as shell input
                           # ...useful to make hidden characters readable.
</code></pre>

<hr>

<p>Note that if you're applying this technique in other circumstances (not <code>PWD</code>, but some other variable holding a directory name), you might need to trim any trailing slashes. The below uses bash's <a href=""http://wiki.bash-hackers.org/syntax/pattern#extended_pattern_language"" rel=""noreferrer"">extglob support</a> to work even with multiple trailing slashes:</p>

<pre><code>dirname=/path/to/somewhere//
shopt -s extglob           # enable +(...) glob syntax
result=${dirname%%+(/)}    # trim however many trailing slashes exist
result=${result##*/}       # remove everything before the last / that still remains
printf '%s\n' ""$result""
</code></pre>

<p>Alternatively, without <code>extglob</code>:</p>

<pre><code>dirname=""/path/to/somewhere//""
result=""${dirname%""${dirname##*[!/]}""}"" # extglob-free multi-trailing-/ trim
result=""${result##*/}""                  # remove everything before the last /
</code></pre>
"
"Add a new element to an array without specifying the index in Bash","1951506","<bash><arrays>","834","<p>Yes there is:</p>

<pre><code>ARRAY=()
ARRAY+=('foo')
ARRAY+=('bar')
</code></pre>

<p><a href=""http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameters"" rel=""noreferrer"">Bash Reference Manual</a>:</p>

<blockquote>
  <p>In the context where an assignment statement is assigning a value to a shell variable or array index (see Arrays), the ‘+=’ operator can be used to append to or add to the variable's previous value.</p>
</blockquote>
"
"Given two directory trees, how can I find out which files differ by content?","4997693","<linux><bash><shell><unix><diff>","833","<p>You said Linux, so you luck out (at least it should be available, not sure when it was added):</p>

<pre><code>diff --brief --recursive dir1/ dir2/ # GNU long options
diff -qr dir1/ dir2/ # common short options
</code></pre>

<p>Should do what you need.</p>

<p>If you also want to see differences for files that may not exist in either directory:</p>

<pre><code>diff --brief --recursive --new-file dir1/ dir2/ # GNU long options
diff -qrN dir1/ dir2/ # common short options
</code></pre>
"
"What are the special dollar sign shell variables?","5163144","<bash><environment-variables><dollar-sign>","824","<ul>
<li><code>$1</code>, <code>$2</code>, <code>$3</code>, ... are the <a href=""https://www.gnu.org/software/bash/manual/html_node/Positional-Parameters.html"" rel=""noreferrer"">positional parameters</a>.</li>
<li><code>""$@""</code> is an array-like construct of all positional parameters, <code>{$1, $2, $3 ...}</code>.</li>
<li><code>""$*""</code> is the IFS expansion of all positional parameters, <code>$1 $2 $3 ...</code>.</li>
<li><code>$#</code> is the number of positional parameters.</li>
<li><code>$-</code> current options set for the shell.</li>
<li><code>$$</code> pid of the current shell (not subshell).</li>
<li><code>$_</code> most recent parameter (or the abs path of the command to start the current shell immediately after startup).</li>
<li><code>$IFS</code> is the (input) field separator.</li>
<li><code>$?</code> is the most recent foreground pipeline exit status.</li>
<li><code>$!</code> is the PID of the most recent background command.</li>
<li><code>$0</code> is the name of the shell or shell script.</li>
</ul>

<p>Most of the above can be found under <a href=""https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html"" rel=""noreferrer"">Special Parameters</a> in the Bash Reference Manual. There are all the <a href=""https://www.gnu.org/software/bash/manual/html_node/Shell-Variables.html"" rel=""noreferrer"">environment variables set by the shell</a>.</p>

<p>For a comprehensive index, please see the <a href=""https://www.gnu.org/software/bash/manual/html_node/Variable-Index.html"" rel=""noreferrer"">Reference Manual Variable Index</a>.</p>
"
"Count number of lines in a git repository","4822471","<bash><git><shell><line-count>","819","<p><code>xargs</code> will do what you want:</p>

<pre><code>git ls-files | xargs cat | wc -l
</code></pre>

<p>But with more information and probably better, you can do:</p>

<pre><code>git ls-files | xargs wc -l
</code></pre>
"
"How can I exclude all ""permission denied"" messages from ""find""?","762348","<bash><error-handling><find><file-permissions>","815","<p><sup>Note:<br>
* This answer probably goes deeper than the use case warrants, and <code>find 2&gt;/dev/null</code> may be good enough in many situations. It may still be of interest for a cross-platform perspective and for its discussion of some advanced shell techniques in the interest of finding a solution that is as robust as possible, even though the cases guarded against may be largely hypothetical.<br>
* <strong>If your system is configured to show <em>localized</em> error messages</strong>, prefix the <code>find</code> calls below with <code>LC_ALL=C</code> (<code>LC_ALL=C find ...</code>) to ensure that <em>English</em> messages are reported, so that <code>grep -v 'Permission denied'</code> works as intended. Invariably, however, any error messages that <em>do</em> get displayed will then be in English as well.  </p>

<p>If your <strong>shell is <code>bash</code> or <code>zsh</code></strong>, there's <strong>a solution that is robust while being reasonably simple</strong>, using <strong>only POSIX-compliant <code>find</code> features</strong>; while <code>bash</code> itself is not part of POSIX, most modern Unix platforms come with it, making this solution widely portable:</p>

<pre><code>find . &gt; files_and_folders 2&gt; &gt;(grep -v 'Permission denied' &gt;&amp;2)
</code></pre>

<p>Note: There's a small chance that some of <code>grep</code>'s output may arrive <em>after</em> <code>find</code> completes, because the overall command doesn't wait for the command inside <code>&gt;(...)</code> to finish. In <code>bash</code>, you can prevent this by appending <code>| cat</code> to the command.</sup></p>

<ul>
<li><p><code>&gt;(...)</code> is a (rarely used) <em>output</em> <a href=""http://mywiki.wooledge.org/ProcessSubstitution"" rel=""noreferrer"">process substitution</a> that allows redirecting output (in this case, <em>stderr</em> output (<code>2&gt;</code>) to the stdin of the command inside <code>&gt;(...)</code>.<br>
In addition to <code>bash</code> and <code>zsh</code>, <code>ksh</code> supports them as well <em>in principle</em>, but trying to combine them with redirection from <em>stderr</em>, as is done here (<code>2&gt; &gt;(...)</code>), appears to be silently ignored (in <code>ksh 93u+</code>).</p>

<ul>
<li><code>grep -v 'Permission denied'</code> filters <em>out</em> (<code>-v</code>) all lines (from the <code>find</code> command's stderr stream) that contain the phrase <code>Permission denied</code> and outputs the remaining lines to stderr (<code>&gt;&amp;2</code>).</li>
</ul></li>
</ul>

<p>This approach is:</p>

<ul>
<li><p><strong>robust</strong>: <code>grep</code> is only applied to <em>error messages</em> (and not to a combination of file paths and error messages, potentially leading to false positives), and error messages other than permission-denied ones are passed through, to stderr.</p></li>
<li><p><strong>side-effect free</strong>: <code>find</code>'s exit code is preserved: the inability to access at least one of the filesystem items encountered results in exit code <code>1</code> (although that won't tell you whether errors <em>other</em> than permission-denied ones occurred (too)).</p></li>
</ul>

<hr>

<h3>POSIX-compliant solutions:</h3>

<p>Fully POSIX-compliant solutions either have limitations or require additional work.</p>

<p><strong>If <code>find</code>'s output is to be captured in a <em>file</em> anyway</strong> (or suppressed altogether), then the pipeline-based solution from <a href=""https://stackoverflow.com/a/762360/45375"">Jonathan Leffler's answer</a> is simple, robust, and POSIX-compliant:</p>

<pre><code>find . 2&gt;&amp;1 &gt;files_and_folders | grep -v 'Permission denied' &gt;&amp;2
</code></pre>

<p>Note that the order of the redirections matters: <code>2&gt;&amp;1</code> must come <em>first</em>.</p>

<p>Capturing stdout output in a file up front allows <code>2&gt;&amp;1</code> to send <em>only</em> error messages through the pipeline, which <code>grep</code> can then unambiguously operate on.</p>

<p>The <strong>only downside is that the <em>overall exit code</em> will be the <code>grep</code> command's</strong>, not <code>find</code>'s, which in this case means: if there are <em>no</em> errors at all or <em>only</em> permission-denied errors, the exit code will be <code>1</code> (signaling <em>failure</em>), otherwise (errors other than permission-denied ones) <code>0</code> - which is the opposite of the intent.<br>
<strong>That said, <code>find</code>'s exit code is rarely used anyway</strong>, as it often conveys little information beyond <em>fundamental</em> failure such as passing a non-existent path.<br>
However, the specific case of even only <em>some</em> of the input paths being inaccessible due to lack of permissions <em>is</em> reflected in <code>find</code>'s exit code (in both GNU and BSD <code>find</code>): if a permissions-denied error occurs for <em>any</em> of the files processed, the exit code is set to <code>1</code>.</p>

<p>The following variation addresses that:</p>

<pre><code>find . 2&gt;&amp;1 &gt;files_and_folders | { grep -v 'Permission denied' &gt;&amp;2; [ $? -eq 1 ]; }
</code></pre>

<p>Now, the exit code indicates whether any errors <em>other than</em> <code>Permission denied</code> occurred: <code>1</code> if so, <code>0</code> otherwise.<br>
In other words: the exit code now reflects the true intent of the command: success (<code>0</code>) is reported, if no errors at all or <em>only</em> permission-denied errors occurred.<br>
This is arguably even better than just passing <code>find</code>'s exit code through, as in the solution at the top.</p>

<hr>

<p><a href=""https://stackoverflow.com/users/1815797/gniourf-gniourf"">gniourf_gniourf</a> in the comments proposes a (still POSIX-compliant) <strong>generalization of this solution using sophisticated redirections</strong>, which <strong>works even with the default behavior of printing the file paths to <em>stdout</em></strong>:</p>

<pre><code>{ find . 3&gt;&amp;2 2&gt;&amp;1 1&gt;&amp;3 | grep -v 'Permission denied' &gt;&amp;3; } 3&gt;&amp;2 2&gt;&amp;1
</code></pre>

<p>In short: Custom file descriptor <code>3</code> is used to temporarily swap stdout (<code>1</code>) and stderr (<code>2</code>), so that error messages <em>alone</em> can be piped to <code>grep</code> via stdout.</p>

<p>Without these redirections, both data (file paths) <em>and</em> error messages would be piped to <code>grep</code> via stdout, and <code>grep</code> would then not be able to distinguish between <em>error message</em> <code>Permission denied</code> and a (hypothetical) <em>file whose name happens to contain</em> the phrase <code>Permission denied</code>.</p>

<p>As in the first solution, however, the the exit code reported will be <code>grep</code>'s, not <code>find</code>'s, but the same fix as above can be applied.</p>

<hr>

<h3>Notes on the existing answers:</h3>

<ul>
<li><p>There are several points to note about <a href=""https://stackoverflow.com/a/25234419/45375"">Michael Brux's answer</a>, <code>find . ! -readable -prune -o -print</code>:</p>

<ul>
<li><p>It requires <em>GNU</em> <code>find</code>; notably, it won't work on macOS. Of course, if you only ever need the command to work with GNU <code>find</code>, this won't be a problem for you.</p></li>
<li><p>Some <code>Permission denied</code> errors may <em>still</em> surface: <code>find ! -readable -prune</code> reports such errors for the <em>child</em> items of directories for which the current user does have <code>r</code> permission, but lacks <code>x</code> (executable) permission. The reason is that because the directory itself <em>is</em> readable, <code>-prune</code> is not executed, and the attempt to descend <em>into</em> that directory then triggers the error messages. That said, the <em>typical</em> case is for the <code>r</code> permission to be missing.</p></li>
<li><p>Note: The following point is a matter of philosophy and/or specific use case, and you may decide it is not relevant to you and that the command fits your needs well, especially if simply <em>printing</em> the paths is all you do:</p>

<ul>
<li><em>If</em> you conceptualize the filtering of the permission-denied error messages a <em>separate</em> task that you want to be able to apply to <em>any</em> <code>find</code> command, then the opposite approach of proactively <em>preventing</em> permission-denied errors requires introducing ""noise"" into the <code>find</code> command, which also introduces complexity and logical <em>pitfalls</em>.</li>
<li>For instance, the most up-voted comment on Michael's answer (as of this writing) attempts to show how to <em>extend</em> the command by including a <code>-name</code> filter, as follows:<br>
<code>find . ! -readable -prune -o -name '*.txt'</code><br>
This, however, does <em>not</em> work as intended, because the trailing <code>-print</code> action is <em>required</em> (an explanation can be found in <a href=""https://stackoverflow.com/questions/1489277/how-to-use-prune-option-of-find-in-sh"">this answer</a>). Such subtleties can introduce bugs.</li>
</ul></li>
</ul></li>
<li><p>The first solution in <a href=""https://stackoverflow.com/a/762360/45375"">Jonathan Leffler's answer</a>, <code>find . 2&gt;/dev/null &gt; files_and_folders</code>, as he himself states,  <strong>blindly silences <em>all</em> error messages</strong> (and the workaround is cumbersome and not fully robust, as he also explains). <strong>Pragmatically speaking</strong>, however, it is the <strong>simplest solution</strong>, as you may be content to assume that any and all errors would be permission-related.</p></li>
<li><p><a href=""https://stackoverflow.com/a/27503763/45375"">mist's answer</a>, <code>sudo find . &gt; files_and_folders</code>, <strong>is concise and pragmatic, but ill-advised for anything other than merely <em>printing</em> filenames</strong>, for security reasons: because you're running as the <em>root</em> user, ""you risk having your whole system being messed up by a bug in find or a malicious version, or an incorrect invocation which writes something unexpectedly, which could not happen if you ran this with normal privileges"" (from a comment on mist's answer by <a href=""https://stackoverflow.com/users/874188/tripleee"">tripleee</a>).  </p></li>
<li><p>The 2nd solution in <a href=""https://stackoverflow.com/a/762377/45375"">viraptor's answer</a>, <code>find . 2&gt;&amp;1 | grep -v 'Permission denied' &gt; some_file</code> runs the risk of false positives (due to sending a mix of stdout and stderr through the pipeline), and, potentially, instead of reporting <em>non</em>-permission-denied errors via stderr, captures them alongside the output paths in the output file.</p></li>
</ul>
"
"How can I write a heredoc to a file in Bash script?","2953081","<bash><heredoc>","812","<p>Read the Advanced Bash-Scripting Guide <a href=""http://tldp.org/LDP/abs/html/here-docs.html"" rel=""noreferrer"">Chapter 19. Here Documents</a>.</p>

<p>Here's an example which will write the contents to a file at <code>/tmp/yourfilehere</code></p>

<pre><code>cat &lt;&lt; EOF &gt; /tmp/yourfilehere
These contents will be written to the file.
        This line is indented.
EOF
</code></pre>

<p>Note that the final 'EOF' (The <code>LimitString</code>) should not have any whitespace in front of the word, because it means that the <code>LimitString</code> will not be recognized.</p>

<p>In a shell script, you may want to use indentation to make the code readable, however this can have the undesirable effect of indenting the text within your here document. In this case, use <code>&lt;&lt;-</code> (followed by a dash) to disable leading tabs (<strong>Note</strong> that to test this you will need to <strong>replace the leading whitespace with a tab character</strong>, since I cannot print actual tab characters here.)</p>

<pre><code>#!/usr/bin/env bash

if true ; then
    cat &lt;&lt;- EOF &gt; /tmp/yourfilehere
    The leading tab is ignored.
    EOF
fi
</code></pre>

<p>If you don't want to interpret variables in the text, then use single quotes:</p>

<pre><code>cat &lt;&lt; 'EOF' &gt; /tmp/yourfilehere
The variable $FOO will not be interpreted.
EOF
</code></pre>

<p>To pipe the heredoc through a command pipeline:</p>

<pre><code>cat &lt;&lt;'EOF' |  sed 's/a/b/'
foo
bar
baz
EOF
</code></pre>

<p>Output:</p>

<pre><code>foo
bbr
bbz
</code></pre>

<p>... or to write the the heredoc to a file using <code>sudo</code>:</p>

<pre><code>cat &lt;&lt;'EOF' |  sed 's/a/b/' | sudo tee /etc/config_file.conf
foo
bar
baz
EOF
</code></pre>
"
"In Bash, how can I check if a string begins with some value?","2172352","<string><bash><comparison>","809","<p>This snippet on the <a href=""http://tldp.org/LDP/abs/html/comparison-ops.html"" rel=""noreferrer"">Advanced Bash Scripting Guide</a> says:</p>

<pre><code># The == comparison operator behaves differently within a double-brackets
# test than within single brackets.

[[ $a == z* ]]   # True if $a starts with a ""z"" (wildcard matching).
[[ $a == ""z*"" ]] # True if $a is equal to z* (literal matching).
</code></pre>

<p>So you had it <em>nearly</em> correct; you needed <em>double</em> brackets, not single brackets.</p>

<hr>

<p>With regards to your second question, you can write it this way:</p>

<pre><code>HOST=user1
if  [[ $HOST == user1 ]] || [[ $HOST == node* ]] ;
then
    echo yes1
fi

HOST=node001
if [[ $HOST == user1 ]] || [[ $HOST == node* ]] ;
then
    echo yes2
fi
</code></pre>

<p>Which will echo</p>

<pre><code>yes1
yes2
</code></pre>

<p>Bash's <code>if</code> syntax is hard to get used to (IMO).</p>
"
"What does set -e mean in a bash script?","19622198","<linux><bash><shell><sh>","797","<p>From <code>help set</code> :</p>

<pre><code>  -e  Exit immediately if a command exits with a non-zero status.
</code></pre>

<p>But it's considered bad practice by some (bash FAQ and irc freenode #bash FAQ authors). It's recommended to use:</p>

<pre><code>trap 'do_something' ERR
</code></pre>

<p>to run <code>do_something</code> function when errors occur.</p>

<p>See <a href=""http://mywiki.wooledge.org/BashFAQ/105"" rel=""noreferrer"">http://mywiki.wooledge.org/BashFAQ/105</a></p>
"
"Add line break to 'git commit -m' from the command line","5064563","<git><bash><shell>","794","<p>Certainly, how it's done depends on your shell. In Bash, you can use single quotes around the message and can just leave the quote open, which will make Bash prompt for another line, until you close the quote. Like this:</p>

<pre><code>git commit -m 'Message

goes
here'
</code></pre>

<p>Alternatively, you can use a ""here document"" (also known as heredoc):</p>

<pre><code>git commit -F- &lt;&lt;EOF
Message

goes
here
EOF
</code></pre>
"
"Read a file line by line assigning the value to a variable","10929453","<bash>","789","<p>The following reads a file passed as an argument line by line:</p>

<pre><code>while IFS= read -r line; do
    echo ""Text read from file: $line""
done &lt; my_filename.txt
</code></pre>

<p>This is the <a href=""http://mywiki.wooledge.org/BashFAQ/001"" rel=""noreferrer"">standard form</a> for reading lines from a file in a loop. Explanation:</p>

<ul>
<li><code>IFS=</code> (or <code>IFS=''</code>) prevents leading/trailing whitespace from being trimmed.</li>
<li><code>-r</code> prevents backslash escapes from being interpreted.</li>
</ul>

<p>Or you can put it in a bash file helper script, example contents:</p>

<pre><code>#!/bin/bash
while IFS= read -r line; do
    echo ""Text read from file: $line""
done &lt; ""$1""
</code></pre>

<p>If the above is saved to a script with filename <code>readfile</code>, it can be run as follows:</p>

<pre><code>chmod +x readfile
./readfile filename.txt
</code></pre>

<p>If the file isn’t a <a href=""https://stackoverflow.com/a/729795/1968"">standard POSIX text file</a> (= not terminated by a newline character), the loop can be modified to handle trailing partial lines:</p>

<pre><code>while IFS= read -r line || [[ -n ""$line"" ]]; do
    echo ""Text read from file: $line""
done &lt; ""$1""
</code></pre>

<p>Here, <code>|| [[ -n $line ]]</code> prevents the last line from being ignored if it doesn't end with a <code>\n</code> (since <code>read</code> returns a non-zero exit code when it encounters EOF).</p>

<p>If the commands inside the loop also read from standard input, the file descriptor used by <code>read</code> can be chanced to something else (avoid the <a href=""https://en.wikipedia.org/wiki/File_descriptor"" rel=""noreferrer"">standard file descriptors</a>), e.g.:</p>

<pre><code>while IFS= read -r -u3 line; do
    echo ""Text read from file: $line""
done 3&lt; ""$1""
</code></pre>

<p>(Non-Bash shells might not know <code>read -u3</code>; use <code>read &lt;&amp;3</code> instead.)</p>
"
"Assigning default values to shell variables with a single command in bash","2013547","<bash><shell>","789","<p>Very close to what you posted, actually.</p>
<p>To get the assigned value, or <code>default</code> if it's missing:</p>
<pre><code>FOO=${VARIABLE:-default}  # If variable not set or null, use default.
</code></pre>
<p>Or to assign <code>default</code> to <code>VARIABLE</code> at the same time:</p>
<pre><code>FOO=${VARIABLE:=default}  # If variable not set or null, set it to default.
</code></pre>
"
"Check number of arguments passed to a Bash script","18568706","<bash><parameter-passing><command-line-arguments>","783","<p>Just like any other simple command, <code>[ ... ]</code> or <code>test</code> requires spaces between its arguments.</p>
<pre class=""lang-bash prettyprint-override""><code>if [ &quot;$#&quot; -ne 1 ]; then
    echo &quot;Illegal number of parameters&quot;
fi
</code></pre>
<p>Or</p>
<pre class=""lang-bash prettyprint-override""><code>if test &quot;$#&quot; -ne 1; then
    echo &quot;Illegal number of parameters&quot;
fi
</code></pre>
<h3>Suggestions</h3>
<p>When in Bash, prefer using <code>[[ ]]</code> instead as it doesn't do word splitting and pathname expansion to its variables that quoting may not be necessary unless it's part of an expression.</p>
<pre class=""lang-none prettyprint-override""><code>[[ $# -ne 1 ]]
</code></pre>
<p>It also has some other features like unquoted condition grouping, pattern matching (extended pattern matching with <code>extglob</code>) and regex matching.</p>
<p>The following example checks if arguments are valid. It allows a single argument or two.</p>
<pre class=""lang-none prettyprint-override""><code>[[ ($# -eq 1 || ($# -eq 2 &amp;&amp; $2 == &lt;glob pattern&gt;)) &amp;&amp; $1 =~ &lt;regex pattern&gt; ]]
</code></pre>
<p>For pure arithmetic expressions, using <code>(( ))</code> to some may still be better, but they are still possible in <code>[[ ]]</code> with its arithmetic operators like <code>-eq</code>, <code>-ne</code>, <code>-lt</code>, <code>-le</code>, <code>-gt</code>, or <code>-ge</code> by placing the expression as a single string argument:</p>
<pre class=""lang-none prettyprint-override""><code>A=1
[[ 'A + 1' -eq 2 ]] &amp;&amp; echo true  ## Prints true.
</code></pre>
<p>That should be helpful if you would need to combine it with other features of <code>[[ ]]</code> as well.</p>
<p>Take note that <code>[[ ]]</code> and <code>(( ))</code> are keywords which have same level of parsing as <code>if</code>, <code>case</code>, <code>while</code>, and <code>for</code>.</p>
<p>Also as <a href=""https://stackoverflow.com/users/4412820/dave"">Dave</a> suggested, error messages are better sent to stderr so they don't get included when stdout is redirected:</p>
<pre><code>echo &quot;Illegal number of parameters&quot; &gt;&amp;2
</code></pre>
<h3>Exiting the script</h3>
<p>It's also logical to make the script exit when invalid parameters are passed to it.  This has already been suggested in the <a href=""https://stackoverflow.com/questions/18568706/check-number-of-arguments-passed-to-a-bash-script#comment50847987_18568706"">comments</a> by <a href=""https://stackoverflow.com/users/1102730/ekangas"">ekangas</a> but someone edited this answer to have it with <code>-1</code> as the returned value, so I might as well do it right.</p>
<p><code>-1</code> though accepted by Bash as an argument to <code>exit</code> is not explicitly documented and is not right to be used as a common suggestion.  <code>64</code> is also the most formal value since it's defined in <code>sysexits.h</code> with <code>#define EX_USAGE 64 /* command line usage error */</code>.  Most tools like <code>ls</code> also return <code>2</code> on invalid arguments.  I also used to return <code>2</code> in my scripts but lately I no longer really cared, and simply used <code>1</code> in all errors.  But let's just place <code>2</code> here since it's most common and probably not OS-specific.</p>
<pre><code>if [[ $# -ne 1 ]]; then
    echo &quot;Illegal number of parameters&quot;
    exit 2
fi
</code></pre>
<h3>References</h3>
<ul>
<li><a href=""https://www.gnu.org/software/bash/manual/bash.html#Bash-Conditional-Expressions"" rel=""noreferrer"">Bash Conditional Expressions</a></li>
<li><a href=""https://www.gnu.org/software/bash/manual/bash.html#Conditional-Constructs"" rel=""noreferrer"">Conditional Constructs</a></li>
<li><a href=""https://www.gnu.org/software/bash/manual/bash.html#Pattern-Matching"" rel=""noreferrer"">Pattern Matching</a></li>
<li><a href=""https://www.gnu.org/software/bash/manual/bash.html#Word-Splitting"" rel=""noreferrer"">Word Splitting</a></li>
<li><a href=""https://www.gnu.org/software/bash/manual/bash.html#Filename-Expansion"" rel=""noreferrer"">Filename Expansion (prev. Pathname Expansion)</a></li>
<li><a href=""https://www.gnu.org/software/bash/manual/html_node/Simple-Commands.html"" rel=""noreferrer"">Simple Commands</a></li>
</ul>
"
"Extract substring in Bash","428109","<string><bash><shell><substring>","774","<p>Use <a href=""http://www.manpagez.com/man/1/cut/"" rel=""noreferrer"">cut</a>:</p>

<pre><code>echo 'someletters_12345_moreleters.ext' | cut -d'_' -f 2
</code></pre>

<p>More generic:</p>

<pre><code>INPUT='someletters_12345_moreleters.ext'
SUBSTRING=$(echo $INPUT| cut -d'_' -f 2)
echo $SUBSTRING
</code></pre>
"
"Redirect all output to file","6674327","<linux><bash><io-redirection>","773","<p>That part is written to stderr, use <code>2&gt;</code> to redirect it. For example:</p>

<pre><code>foo &gt; stdout.txt 2&gt; stderr.txt
</code></pre>

<p>or if you want in same file:</p>

<pre><code>foo &gt; allout.txt 2&gt;&amp;1
</code></pre>

<p>Note: this works in (ba)sh, check your shell for proper syntax</p>
"
"How to 'grep' a continuous stream?","7161821","<linux><bash><shell><grep><tail>","771","<p>Turn on <code>grep</code>'s line buffering mode when using BSD grep (FreeBSD, Mac OS X etc.)</p>
<pre><code>tail -f file | grep --line-buffered my_pattern
</code></pre>
<p>It looks like a while ago <code>--line-buffered</code> didn't matter for GNU grep (used on pretty much any Linux) as it flushed by default (YMMV for other Unix-likes such as SmartOS, AIX or QNX). However, as of November 2020, <code>--line-buffered</code> is needed (at least with GNU grep 3.5 in openSUSE, but it seems generally needed based on comments below).</p>
"
"In a Bash script, how can I exit the entire script if a certain condition occurs?","1378274","<bash><scripting><exit><exit-code>","758","<p>Try this statement:</p>

<pre><code>exit 1
</code></pre>

<p>Replace <code>1</code> with appropriate error codes. See also <a href=""http://www.tldp.org/LDP/abs/html/exitcodes.html"" rel=""noreferrer"">Exit Codes With Special Meanings</a>.</p>
"
"Reliable way for a Bash script to get the full path to itself","4774054","<bash><path>","755","<p>Here's what I've come up with (edit: plus some tweaks provided by <a href=""https://stackoverflow.com/users/1430833/sfstewman"">sfstewman</a>, <a href=""https://stackoverflow.com/users/397210/levigroker"">levigroker</a>, <a href=""https://stackoverflow.com/users/1858225/kyle-strand"">Kyle Strand</a>, and <a href=""https://stackoverflow.com/users/33732/rob-kennedy"">Rob Kennedy</a>), that seems to mostly fit my ""better"" criteria:</p>

<pre><code>SCRIPTPATH=""$( cd ""$(dirname ""$0"")"" &gt;/dev/null 2&gt;&amp;1 ; pwd -P )""
</code></pre>

<p>That <code>SCRIPTPATH</code> line seems particularly roundabout, but we need it rather than <code>SCRIPTPATH=`pwd`</code> in order to properly handle spaces and symlinks.</p>

<p>The inclusion of output redirection (<code>&gt;/dev/null 2&gt;&amp;1</code>) handles the rare(?) case where <code>cd</code> might produce output that would interfere with the surrounding <code>$( ... )</code> capture. (Such as <a href=""https://unix.stackexchange.com/a/20413/32976""><code>cd</code> being overridden to also <code>ls</code> a directory</a> after switching to it.)</p>

<p>Note also that esoteric situations, such as executing a script that isn't coming from a file in an accessible file system at all (which is perfectly possible), is not catered to there (or in any of the other answers I've seen).</p>
"
"Redirect stderr and stdout in Bash","637827","<bash><shell><stdout><io-redirection><stderr>","728","<p>Take a look <a href=""http://tldp.org/LDP/abs/html/io-redirection.html"" rel=""noreferrer"">here</a>. Should be:</p>

<pre><code>yourcommand &amp;&gt;filename
</code></pre>

<p>(redirects both <code>stdout</code> and <code>stderr</code> to filename).</p>
"
"When do we need curly braces around shell variables?","8748831","<bash><shell><syntax><curly-braces>","707","<p>In this particular example, it makes no difference. However, the <code>{}</code> in <code>${}</code> are useful if you want to expand the variable <code>foo</code> in the string</p>

<pre><code>""${foo}bar""
</code></pre>

<p>since <code>""$foobar""</code> would instead expand the variable identified by <code>foobar</code>.</p>

<p>Curly braces are also unconditionally required when:</p>

<ul>
<li>expanding array elements, as in <code>${array[42]}</code></li>
<li>using parameter expansion operations, as in <code>${filename%.*}</code> (remove extension)</li>
<li>expanding positional parameters beyond 9: <code>""$8 $9 ${10} ${11}""</code></li>
</ul>

<p>Doing this everywhere, instead of just in potentially ambiguous cases, <em>can</em> be considered good programming practice. This is both for consistency and to avoid surprises like <code>$foo_$bar.jpg</code>, where it's not visually obvious that the underscore becomes part of the variable name.</p>
"
"How does ""cat << EOF"" work in bash?","2500436","<linux><bash><scripting><heredoc>","701","<p>This is called <strong><em>heredoc</strong> format</em> to provide a string into stdin. See <a href=""https://en.wikipedia.org/wiki/Here_document#Unix_shells"" rel=""noreferrer"">https://en.wikipedia.org/wiki/Here_document#Unix_shells</a> for more details.</p>

<hr>

<p>From <code>man bash</code>:</p>

<blockquote>
  <h2>Here Documents</h2>
  
  <p>This type of redirection instructs the shell to read input from
  the current source until a line
  containing only word (with no trailing
  blanks)  is  seen.</p>
  
  <p>All of the lines read up to that point are then used as the
  standard input for a command.</p>
  
  <p>The format of here-documents is:</p>

<pre><code>          &lt;&lt;[-]word
                  here-document
          delimiter
</code></pre>
  
  <p>No parameter expansion, command substitution, arithmetic expansion, or
  pathname expansion is performed on
  <strong>word</strong>.  If any characters in <strong>word</strong> are
  quoted, the
  <strong>delimiter</strong> is the result of quote removal on <strong>word</strong>, and the lines
  in the <strong>here-document</strong> are not expanded.
  If <strong>word</strong> is unquoted, all lines of  the
  <strong>here-document</strong>  are  subjected  to  parameter  expansion,  command
  substitution, and arithmetic
  expansion.  In the latter case, the
  character sequence <code>\&lt;newline&gt;</code> is
  ignored, and <code>\</code> must be used to quote the characters <code>\</code>, <code>$</code>, and <code>`</code>.</p>
  
  <p>If the redirection operator is <code>&lt;&lt;-</code>, then all leading tab characters
  are stripped from input lines and the
  line containing <strong>delimiter</strong>.   This 
  allows  here-documents within shell scripts to be indented in a natural fashion.</p>
</blockquote>
"
"How do I remove all .pyc files from a project?","785519","<bash>","699","<pre><code>find . -name ""*.pyc"" -exec rm -f {} \;
</code></pre>
"
"Split string into an array in Bash","10586153","<arrays><bash><split>","697","<pre><code>IFS=', ' read -r -a array &lt;&lt;&lt; ""$string""
</code></pre>

<p>Note that the characters in <code>$IFS</code> are treated individually as separators so that in this case fields may be separated by <em>either</em> a comma or a space rather than the sequence of the two characters. Interestingly though, empty fields aren't created when comma-space appears in the input because the space is treated specially.</p>

<p>To access an individual element:</p>

<pre><code>echo ""${array[0]}""
</code></pre>

<p>To iterate over the elements:</p>

<pre><code>for element in ""${array[@]}""
do
    echo ""$element""
done
</code></pre>

<p>To get both the index and the value:</p>

<pre><code>for index in ""${!array[@]}""
do
    echo ""$index ${array[index]}""
done
</code></pre>

<p>The last example is useful because Bash arrays are sparse. In other words, you can delete an element or add an element and then the indices are not contiguous.</p>

<pre><code>unset ""array[1]""
array[42]=Earth
</code></pre>

<p>To get the number of elements in an array:</p>

<pre><code>echo ""${#array[@]}""
</code></pre>

<p>As mentioned above, arrays can be sparse so you shouldn't use the length to get the last element. Here's how you can in Bash 4.2 and later:</p>

<pre><code>echo ""${array[-1]}""
</code></pre>

<p>in any version of Bash (from somewhere after 2.05b):</p>

<pre><code>echo ""${array[@]: -1:1}""
</code></pre>

<p>Larger negative offsets select farther from the end of the array. Note the space before the minus sign in the older form. It is required.</p>
"
"How to use double or single brackets, parentheses, curly braces","2188199","<bash><syntax>","687","<p>In Bash, <code>test</code> and <code>[</code> are shell builtins.</p>

<p>The <a href=""http://mywiki.wooledge.org/BashFAQ/031"" rel=""noreferrer"">double bracket</a>, which is a shell keyword, enables additional functionality. For example, you can use <code>&amp;&amp;</code> and <code>||</code> instead of <code>-a</code> and <code>-o</code> and there's a regular expression matching operator <code>=~</code>.</p>

<p>Also, in a simple test, double square brackets seem to evaluate quite a lot quicker than single ones.</p>

<pre class=""lang-bash prettyprint-override""><code>$ time for ((i=0; i&lt;10000000; i++)); do [[ ""$i"" = 1000 ]]; done

real    0m24.548s
user    0m24.337s
sys 0m0.036s
$ time for ((i=0; i&lt;10000000; i++)); do [ ""$i"" = 1000 ]; done

real    0m33.478s
user    0m33.478s
sys 0m0.000s
</code></pre>

<p>The braces, in addition to delimiting a variable name are used for <a href=""http://tiswww.case.edu/php/chet/bash/bashref.html#Brace-Expansion"" rel=""noreferrer"">parameter expansion</a> so you can do things like:</p>

<ul>
<li><p>Truncate the contents of a variable</p>

<pre><code>$ var=""abcde""; echo ${var%d*}
abc
</code></pre></li>
<li><p>Make substitutions similar to <code>sed</code></p>

<pre><code>$ var=""abcde""; echo ${var/de/12}
abc12
</code></pre></li>
<li><p>Use a default value</p>

<pre><code>$ default=""hello""; unset var; echo ${var:-$default}
hello
</code></pre></li>
<li><p>and several more</p></li>
</ul>

<p>Also, brace expansions create lists of strings which are typically iterated over in loops:</p>

<pre><code>$ echo f{oo,ee,a}d
food feed fad

$ mv error.log{,.OLD}
(error.log is renamed to error.log.OLD because the brace expression
expands to ""mv error.log error.log.OLD"")

$ for num in {000..2}; do echo ""$num""; done
000
001
002

$ echo {00..8..2}
00 02 04 06 08

$ echo {D..T..4}
D H L P T
</code></pre>

<p>Note that the leading zero and increment features weren't available before Bash 4.</p>

<p>Thanks to gboffi for reminding me about brace expansions.</p>

<p>Double parentheses are used for <a href=""http://tiswww.case.edu/php/chet/bash/bashref.html#Arithmetic-Expansion"" rel=""noreferrer"">arithmetic operations</a>:</p>

<pre><code>((a++))

((meaning = 42))

for ((i=0; i&lt;10; i++))

echo $((a + b + (14 * c)))
</code></pre>

<p>and they enable you to omit the dollar signs on integer and array variables and include spaces around operators for readability.</p>

<p>Single brackets are also used for <a href=""http://tiswww.case.edu/php/chet/bash/bashref.html#Arrays"" rel=""noreferrer"">array</a> indices:</p>

<pre><code>array[4]=""hello""

element=${array[index]}
</code></pre>

<p>Curly brace are required for (most/all?) array references on the right hand side.</p>

<p><strong>ephemient's</strong> comment reminded me that parentheses are also used for subshells. And that they are used to create arrays.</p>

<pre><code>array=(1 2 3)
echo ${array[1]}
2
</code></pre>
"
"How to pass all arguments passed to my bash script to a function of mine?","3811345","<bash><function><parameter-passing>","686","<p>The <code>$@</code> variable expands to all command-line parameters separated by spaces.  Here is an example.</p>
<pre><code>abc &quot;$@&quot;
</code></pre>
<p>When using <code>$@</code>, you should (almost) always put it in double-quotes to avoid misparsing of arguments containing spaces or wildcards (see below).  This works for multiple arguments. It is also portable to all POSIX-compliant shells.</p>
<p>It is also worth nothing that <code>$0</code> (generally the script's name or path) is not in <code>$@</code>.</p>
<p>The <a href=""http://www.gnu.org/software/bash/manual/bash.html#Special-Parameters"" rel=""noreferrer"">Bash Reference Manual Special Parameters Section</a> says that <code>$@</code> expands to the positional parameters starting from one.  When the expansion occurs within double quotes, each parameter expands to a separate word.  That is <code>&quot;$@&quot;</code> is equivalent to <code>&quot;$1&quot; &quot;$2&quot; &quot;$3&quot;...</code>.</p>
<h1>Passing <em>some</em> arguments:</h1>
<p>If you want to pass <em>all but the first</em> arguments, you can first use <code>shift</code> to &quot;consume&quot; the first argument and then pass <code>&quot;$@&quot;</code> to pass the remaining arguments to another command.  In bash (and zsh and ksh, but not in plain POSIX shells like dash), you can do this without messing with the argument list using a variant of array slicing: <code>&quot;${@:3}&quot;</code> will get you the arguments starting with <code>&quot;$3&quot;</code>.  <code>&quot;${@:3:4}&quot;</code> will get you up to four arguments starting at <code>&quot;$3&quot;</code> (i.e. <code>&quot;$3&quot; &quot;$4&quot; &quot;$5&quot; &quot;$6&quot;</code>), if that many arguments were passed.</p>
<h1>Things you probably don't want to do:</h1>
<p><code>&quot;$*&quot;</code> gives all of the arguments stuck together into a single string (separated by spaces, or whatever the first character of <code>$IFS</code> is). This looses the distinction between spaces <em>within</em> arguments and the spaces <em>between</em> arguments, so is generally a bad idea. Although it might be ok for printing the arguments, e.g. <code>echo &quot;$*&quot;</code>, provided you don't care about preserving the space within/between distinction.</p>
<p>Assigning the arguments to a regular variable (as in <code>args=&quot;$@&quot;</code>) mashes all the arguments together just like <code>&quot;$*&quot;</code> does. If you want to store the arguments in a variable, use an array with <code>args=(&quot;$@&quot;)</code> (the parentheses make it an array), and then reference them as e.g. <code>&quot;${args[0]}&quot;</code> etc (note that bash array indexes start at 0, so <code>$1</code> will be in <code>args[0]</code>, etc).</p>
<p>Leaving off the double-quotes, with either <code>$@</code> or <code>$*</code>, will try to split each argument up into separate words (based on whitespace or whatever's in <code>$IFS</code>), and also try to expand anything that looks like a filename wildcard into a list of matching filenames. This can have really weird effects, and should almost always be avoided.</p>
"
"Find and kill a process in one line using bash and regex","3510673","<regex><bash><terminal><awk>","686","<p>In <code>bash</code>, you should be able to do:</p>

<pre><code>kill $(ps aux | grep '[p]ython csp_build.py' | awk '{print $2}')
</code></pre>

<p>Details on its workings are as follows:</p>

<ul>
<li>The <code>ps</code> gives you the list of all the processes.</li>
<li>The <code>grep</code> filters that based on your search string, <code>[p]</code> is a trick to stop you picking up the actual <code>grep</code> process itself.</li>
<li>The <code>awk</code> just gives you the second field of each line, which is the PID.</li>
<li>The <code>$(x)</code> construct means to execute <code>x</code> then take its output and put it on the command line. The output of that <code>ps</code> pipeline inside that construct above is the list of process IDs so you end up with a command like <code>kill 1234 1122 7654</code>.</li>
</ul>

<p>Here's a transcript showing it in action:</p>

<pre><code>pax&gt; sleep 3600 &amp;
[1] 2225
pax&gt; sleep 3600 &amp;
[2] 2226
pax&gt; sleep 3600 &amp;
[3] 2227
pax&gt; sleep 3600 &amp;
[4] 2228
pax&gt; sleep 3600 &amp;
[5] 2229
pax&gt; kill $(ps aux | grep '[s]leep' | awk '{print $2}')
[5]+  Terminated              sleep 3600
[1]   Terminated              sleep 3600
[2]   Terminated              sleep 3600
[3]-  Terminated              sleep 3600
[4]+  Terminated              sleep 3600
</code></pre>

<p>and you can see it terminating all the sleepers.</p>

<hr>

<p>Explaining the <code>grep '[p]ython csp_build.py'</code> bit in a bit more detail:</p>

<p>When you do <code>sleep 3600 &amp;</code> followed by <code>ps -ef | grep sleep</code>, you tend to get <em>two</em> processes with <code>sleep</code> in it, the <code>sleep 3600</code> and the <code>grep sleep</code> (because they both have <code>sleep</code> in them, that's not rocket science).</p>

<p>However, <code>ps -ef | grep '[s]leep'</code> won't create a process with <code>sleep</code> in it, it instead creates <code>grep '[s]leep'</code> and here's the tricky bit: the <code>grep</code> doesn't find it because it's looking for the regular expression ""any character from the character class <code>[s]</code> (which is <code>s</code>) followed by <code>leep</code>.</p>

<p>In other words, it's looking for <code>sleep</code> but the grep process is <code>grep '[s]leep'</code> which doesn't have <code>sleep</code> in it.</p>

<p>When I was shown this (by someone here on SO), I immediately started using it because</p>

<ul>
<li>it's one less process than adding <code>| grep -v grep</code>; and</li>
<li>it's elegant <em>and</em> sneaky, a rare combination :-)</li>
</ul>
"
"Get current time in seconds since the Epoch on Linux, Bash","1092631","<linux><bash><datetime>","677","<p>This should work:</p>

<pre><code>date +%s
</code></pre>
"
"Syntax for a single-line Bash infinite while loop","1289026","<bash><loops><while-loop>","676","<pre><code>while true; do foo; sleep 2; done
</code></pre>

<p>By the way, if you type it as a multiline (as you are showing) at the command prompt and then call the history with arrow up, you will get it on a single line, correctly punctuated.</p>

<pre><code>$ while true
&gt; do
&gt;    echo ""hello""
&gt;    sleep 2
&gt; done
hello
hello
hello
^C
$ &lt;arrow up&gt; while true; do    echo ""hello"";    sleep 2; done
</code></pre>
"
"Bash tool to get nth line from a file","6022384","<bash><shell><unix><awk><sed>","665","<p><code>head</code> and pipe with <code>tail</code> will be slow for a huge file. I would suggest <code>sed</code> like this:</p>

<pre><code>sed 'NUMq;d' file
</code></pre>

<p>Where <code>NUM</code> is the number of the line you want to print; so, for example, <code>sed '10q;d' file</code> to print the 10th line of <code>file</code>.</p>

<p>Explanation:</p>

<p><code>NUMq</code> will quit immediately when the line number is <code>NUM</code>.</p>

<p><code>d</code> will delete the line instead of printing it; this is inhibited on the last line because the <code>q</code> causes the rest of the script to be skipped when quitting.</p>

<p>If you have <code>NUM</code> in a variable, you will want to use double quotes instead of single:</p>

<pre><code>sed ""${NUM}q;d"" file
</code></pre>
"
"How to kill all processes with a given partial name?","8987037","<linux><bash><posix>","664","<p>Use <code>pkill -f</code>, which matches the pattern for any part of the command line</p>

<pre><code>pkill -f my_pattern
</code></pre>
"
"How to determine the current shell I'm working on","3327013","<bash><unix><shell><csh><tcsh>","663","<ul>
<li><p>There are three approaches to finding the <strong>name</strong> of the current shell's executable:</p>

<p>Please note that all three approaches can be fooled if the executable of the shell is <code>/bin/sh</code>, but it's really a renamed <code>bash</code>, for example (which frequently happens).</p>

<p><em>Thus your second question of whether <code>ps</code> output will do is answered with ""<strong>not always</strong>"".</em></p>

<ol>
<li><p><code>echo $0</code> - will print the program name... which in the case of the shell is the actual shell.</p></li>
<li><p><code>ps  -ef | grep $$ | grep -v grep</code> - this will look for the current process ID in the list of running processes. Since the current process is the shell, it will be included.</p>

<p>This is not 100% reliable, as you might have <em>other</em> processes whose <code>ps</code> listing includes the same number as shell's process ID, especially if that ID is a small number (for example, if the shell's PID is ""5"", you may find processes called ""java5"" or ""perl5"" in the same <code>grep</code> output!). <em>This is the second problem with the ""ps"" approach, on top of not being able to rely on the shell name.</em></p></li>
<li><p><code>echo $SHELL</code> - The path to the current shell is stored as the <code>SHELL</code> variable for any shell. The caveat for this one is that if you launch a shell explicitly as a subprocess (for example, it's not your login shell), you will get your login shell's value instead. If that's a possibility, use the <code>ps</code> or <code>$0</code> approach.</p></li>
</ol>

<hr></li>
<li><p>If, however, the executable doesn't match your actual shell (e.g. <code>/bin/sh</code> is actually bash or ksh), you need heuristics. Here are some environmental variables specific to various shells:</p>

<ul>
<li><p><code>$version</code> is set on tcsh</p></li>
<li><p><code>$BASH</code> is set on bash</p></li>
<li><p><code>$shell</code> (lowercase) is set to actual shell name in csh or tcsh</p></li>
<li><p><code>$ZSH_NAME</code> is set on zsh</p></li>
<li><p>ksh has <code>$PS3</code> and <code>$PS4</code> set, whereas the normal Bourne shell (<code>sh</code>) only has <code>$PS1</code> and <code>$PS2</code> set. This generally seems like the hardest to distinguish - the <em>only</em> difference in the entire set of environment variables between <code>sh</code> and <code>ksh</code> we have installed on Solaris boxen is <code>$ERRNO</code>, <code>$FCEDIT</code>, <code>$LINENO</code>, <code>$PPID</code>, <code>$PS3</code>, <code>$PS4</code>, <code>$RANDOM</code>, <code>$SECONDS</code>, and <code>$TMOUT</code>.</p></li>
</ul></li>
</ul>
"
"How do I prompt a user for confirmation in bash script?","1885525","<bash>","662","<pre class=""lang-sh prettyprint-override""><code>read -p &quot;Are you sure? &quot; -n 1 -r
echo    # (optional) move to a new line
if [[ $REPLY =~ ^[Yy]$ ]]
then
    # do dangerous stuff
fi
</code></pre>
<p>I incorporated <strong>levislevis85</strong>'s suggestion (thanks!) and added the <code>-n</code> option to <code>read</code> to accept one character without the need to press <kbd>Enter</kbd>. You can use one or both of these.</p>
<p>Also, the negated form might look like this:</p>
<pre class=""lang-sh prettyprint-override""><code>read -p &quot;Are you sure? &quot; -n 1 -r
echo    # (optional) move to a new line
if [[ ! $REPLY =~ ^[Yy]$ ]]
then
    [[ &quot;$0&quot; = &quot;$BASH_SOURCE&quot; ]] &amp;&amp; exit 1 || return 1 # handle exits from shell or function but don't exit interactive shell
fi
</code></pre>
<p>However, as pointed out by Erich, under some circumstances such as a syntax error caused by the script being run in the wrong shell, the negated form could allow the script to continue to the &quot;dangerous stuff&quot;. The failure mode should favor the safest outcome so only the first, non-negated <code>if</code> should be used.</p>
<h2>Explanation:</h2>
<p>The <code>read</code> command outputs the prompt (<code>-p &quot;prompt&quot;</code>) then accepts one character (<code>-n 1</code>) and accepts backslashes literally (<code>-r</code>) (otherwise <code>read</code> would see the backslash as an escape and wait for a second character). The default variable for <code>read</code> to store the result in is <code>$REPLY</code> if you don't supply a name like this: <code>read -p &quot;my prompt&quot; -n 1 -r my_var</code></p>
<p>The <code>if</code> statement uses a regular expression to check if the character in <code>$REPLY</code> matches (<code>=~</code>) an upper or lower case &quot;Y&quot;. The regular expression used here says &quot;a string starting (<code>^</code>) and consisting solely of one of a list of characters in a bracket expression (<code>[Yy]</code>) and ending (<code>$</code>)&quot;. The anchors (<code>^</code> and <code>$</code>) prevent matching longer strings. In this case they help reinforce the one-character limit set in the <code>read</code> command.</p>
<p>The negated form uses the logical &quot;not&quot; operator (<code>!</code>) to match (<code>=~</code>) any character that is not &quot;Y&quot; or &quot;y&quot;. An alternative way to express this is less readable and doesn't as clearly express the intent in my opinion in this instance. However, this is what it would look like: <code>if [[ $REPLY =~ ^[^Yy]$ ]]</code></p>
"
"How do I test if a variable is a number in Bash?","806906","<linux><bash><shell>","660","<p>One approach is to use a regular expression, like so:</p>

<pre><code>re='^[0-9]+$'
if ! [[ $yournumber =~ $re ]] ; then
   echo ""error: Not a number"" &gt;&amp;2; exit 1
fi
</code></pre>

<p>If the value is not necessarily an integer, consider amending the regex appropriately; for instance:</p>

<pre><code>^[0-9]+([.][0-9]+)?$
</code></pre>

<p>...or, to handle numbers with a sign:</p>

<pre><code>^[+-]?[0-9]+([.][0-9]+)?$
</code></pre>
"
"Check if pull needed in Git","3258243","<git><bash><shell>","657","<p>First use <a href=""https://git-scm.com/docs/git-remote"" rel=""noreferrer""><code>git remote update</code></a>, to bring your remote refs up to date. Then you can do one of several things, such as:</p>

<ol>
<li><p><code>git status -uno</code> will tell you whether the branch you are tracking is ahead, behind or has diverged. If it says nothing, the local and remote are the same.</p></li>
<li><p><code>git show-branch *master</code> will show you the commits in all of the branches whose names end in 'master' (eg <em>master</em> and <em>origin/master</em>).</p></li>
</ol>

<p>If you use <code>-v</code> with <code>git remote update</code> (<code>git remote -v update</code>) you can see which branches got updated, so you don't really need any further commands.</p>

<p>However, it looks like you want to do this in a script or program and end up with a true/false value. If so, there are ways to check the relationship between your current <em>HEAD</em> commit and the head of the branch you're tracking, although since there are four possible outcomes you can't reduce it to a yes/no answer. However, if you're prepared to do a <code>pull --rebase</code> then you can treat ""local is behind"" and ""local has diverged"" as ""need to pull"", and the other two as ""don't need to pull"".</p>

<p>You can get the commit id of any ref using <code>git rev-parse &lt;ref&gt;</code>, so you can do this for <em>master</em> and <em>origin/master</em> and compare them. If they're equal, the branches are the same. If they're unequal, you want to know which is ahead of the other. Using <code>git merge-base master origin/master</code> will tell you the common ancestor of both branches, and if they haven't diverged this will be the same as one or the other. If you get three different ids, the branches have diverged.</p>

<p>To do this properly, eg in a script, you need to be able to refer to the current branch, and the remote branch it's tracking. The bash prompt-setting function in <code>/etc/bash_completion.d</code> has some useful code for getting branch names. However, you probably don't actually need to get the names. Git has some neat shorthands for referring to branches and commits (as documented in <code>git rev-parse --help</code>). In particular, you can use <code>@</code> for the current branch (assuming you're not in a detached-head state) and <code>@{u}</code> for its upstream branch (eg <code>origin/master</code>). So <code>git merge-base @ @{u}</code> will return the (hash of the) commit at which the current branch and its upstream diverge and <code>git rev-parse @</code> and <code>git rev-parse @{u}</code> will give you the hashes of the two tips. This can be summarized in the following script:</p>

<pre><code>#!/bin/sh

UPSTREAM=${1:-'@{u}'}
LOCAL=$(git rev-parse @)
REMOTE=$(git rev-parse ""$UPSTREAM"")
BASE=$(git merge-base @ ""$UPSTREAM"")

if [ $LOCAL = $REMOTE ]; then
    echo ""Up-to-date""
elif [ $LOCAL = $BASE ]; then
    echo ""Need to pull""
elif [ $REMOTE = $BASE ]; then
    echo ""Need to push""
else
    echo ""Diverged""
fi
</code></pre>

<p><em>Note:</em> older versions of git didn't allow <code>@</code> on its own, so you may have to use <code>@{0}</code> instead.</p>

<p>The line <code>UPSTREAM=${1:-'@{u}'}</code> allows you optionally to pass an upstream branch explicitly, in case you want to check against a different remote branch than the one configured for the current branch. This would typically be of the form <em>remotename/branchname</em>. If no parameter is given, the value defaults to <code>@{u}</code>.</p>

<p>The script assumes that you've done a <code>git fetch</code> or <code>git remote update</code> first, to bring the tracking branches up to date. I didn't build this into the script because it's more flexible to be able to do the fetching and the comparing as separate operations, for example if you want to compare without fetching because you already fetched recently.</p>
"
"How do I know the script file name in a Bash script?","192319","<linux><bash><shell><scripting>","644","<pre><code>me=`basename ""$0""`
</code></pre>

<p>For reading through a symlink<sup>1</sup>, which is usually not what you want (you usually don't want to confuse the user this way), try:</p>

<pre><code>me=""$(basename ""$(test -L ""$0"" &amp;&amp; readlink ""$0"" || echo ""$0"")"")""
</code></pre>

<p>IMO, that'll produce confusing output.  ""I ran foo.sh, but it's saying I'm running bar.sh!?  Must be a bug!""   Besides, one of the purposes of having differently-named symlinks is to provide different functionality based on the name it's called as (think gzip and gunzip on some platforms).</p>

<hr>

<p><sup>1</sup> That is, to resolve symlinks such that when the user executes <code>foo.sh</code> which is actually a symlink to <code>bar.sh</code>, you wish to use the resolved name <code>bar.sh</code> rather than <code>foo.sh</code>.</p>
"
"Is double square brackets [[ ]] preferable over single square brackets [ ] in Bash?","669452","<bash><if-statement><syntax>","634","<p><code>[[</code> has fewer surprises and is generally safer to use. But it is not portable - POSIX doesn't specify what it does and only some shells support it (beside bash, I heard ksh supports it too). For example, you can do </p>

<pre><code>[[ -e $b ]]
</code></pre>

<p>to test whether a file exists. But with <code>[</code>, you have to quote <code>$b</code>, because it splits the argument and expands things like <code>""a*""</code> (where <code>[[</code> takes it literally). That has also to do with how <code>[</code> can be an external program and receives its argument just normally like every other program (although it can also be a builtin, but then it still has not this special handling).</p>

<p><code>[[</code> also has some other nice features, like regular expression matching with <code>=~</code> along with operators like they are known in C-like languages. Here is a good page about it: <a href=""http://mywiki.wooledge.org/BashFAQ/031"" rel=""noreferrer"">What is the difference between test, <code>[</code> and <code>[[</code> ?</a> and <a href=""http://mywiki.wooledge.org/BashGuide/Practices#Bash_Tests"" rel=""noreferrer"">Bash Tests</a></p>
"
"Automatic exit from bash shell script on error","2870992","<bash><shell><error-handling><exit>","632","<p>Use the <a href=""http://www.gnu.org/software/bash/manual/bashref.html#The-Set-Builtin"" rel=""noreferrer""><code>set -e</code></a> builtin:</p>

<pre><code>#!/bin/bash
set -e
# Any subsequent(*) commands which fail will cause the shell script to exit immediately
</code></pre>

<p>Alternatively, you can pass <code>-e</code> on the command line:</p>

<pre><code>bash -e my_script.sh
</code></pre>

<p>You can also <strong>disable</strong> this behavior with <code>set +e</code>.</p>

<p>You may also want to employ all or some of the the <code>-e</code> <code>-u</code> <code>-x</code> and <code>-o pipefail</code> options like so:</p>

<pre><code>set -euxo pipefail
</code></pre>

<p><code>-e</code> exits on error, <code>-u</code> errors on undefined variables, and <code>-o (for option) pipefail</code> exits on command pipe failures. Some gotchas and workarounds are documented well <a href=""https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/"" rel=""noreferrer"">here</a>.</p>

<p>(*) Note:</p>

<blockquote>
  <p>The shell does <em>not</em> exit if the command that fails is part of the
  command list immediately following a <strong>while</strong> or <strong>until</strong> keyword,
  part of the test following the <strong>if</strong> or <strong>elif</strong> reserved words, part
  of any command executed in a <strong>&amp;&amp;</strong> or <strong>||</strong> list except the command
  following the final <strong>&amp;&amp;</strong> or <strong>||</strong>, any command in a pipeline but
  the last, or if the command's return value is being inverted with
  <strong>!</strong></p>
</blockquote>

<p>(from <code>man bash</code>)</p>
"
"How do I compare two string variables in an 'if' statement in Bash?","4277665","<bash><if-statement><scripting>","631","<p>For string equality comparison, use:</p>

<pre><code>if [[ ""$s1"" == ""$s2"" ]]
</code></pre>

<p>For string does NOT equal comparison, use:</p>

<pre><code>if [[ ""$s1"" != ""$s2"" ]]
</code></pre>

<p>For the <code>a</code> contains <code>b</code>, use:</p>

<pre><code>if [[ $s1 == *""$s2""* ]]
</code></pre>

<p>(and make sure to add spaces between the symbols):</p>

<p>Bad:</p>

<pre><code>if [[""$s1"" == ""$s2""]]
</code></pre>

<p>Good:</p>

<pre><code>if [[ ""$s1"" == ""$s2"" ]]
</code></pre>
"
"Difference between single and double quotes in Bash","6697753","<bash><shell><syntax><quotes>","624","<p>Single quotes won't interpolate anything, but double quotes will. For example: variables, backticks, certain <code>\</code> escapes, etc. </p>

<p>Example:</p>

<pre><code>$ echo ""$(echo ""upg"")""
upg
$ echo '$(echo ""upg"")'
$(echo ""upg"")
</code></pre>

<p>The Bash manual has this to say:</p>

<blockquote>
  <p><a href=""http://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html"" rel=""noreferrer"">3.1.2.2 Single Quotes</a></p>
  
  <p>Enclosing characters in single quotes (<code>'</code>) preserves the literal value of each character within the quotes. A single quote may not occur between single quotes, even when preceded by a backslash. </p>
  
  <p><a href=""http://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html"" rel=""noreferrer"">3.1.2.3 Double Quotes</a></p>
  
  <p>Enclosing characters in double quotes (<code>""</code>) preserves the literal value of all characters within the quotes, with the exception of <code>$</code>, <code>`</code>, <code>\</code>, and, when history expansion is enabled, <code>!</code>. The characters <code>$</code> and <code>`</code> retain their special meaning within double quotes (see <a href=""https://www.gnu.org/software/bash/manual/html_node/Shell-Expansions.html#Shell-Expansions"" rel=""noreferrer"">Shell Expansions</a>). The backslash retains its special meaning only when followed by one of the following characters: <code>$</code>, <code>`</code>, <code>""</code>, <code>\</code>, or newline. Within double quotes, backslashes that are followed by one of these characters are removed. Backslashes preceding characters without a special meaning are left unmodified. A double quote may be quoted within double quotes by preceding it with a backslash. If enabled, history expansion will be performed unless an <code>!</code> appearing in double quotes is escaped using a backslash. The backslash preceding the <code>!</code> is not removed.</p>
  
  <p>The special parameters <code>*</code> and <code>@</code> have special meaning when in double quotes (see <a href=""https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html#Shell-Parameter-Expansion"" rel=""noreferrer"">Shell Parameter Expansion</a>). </p>
</blockquote>
"
"How to set current working directory to the directory of the script in bash?","3349105","<bash><path><scripting>","617","<pre><code>#!/bin/bash
cd ""$(dirname ""$0"")""
</code></pre>
"
"Comparing numbers in Bash","18668556","<bash><shell><numeric>","614","<p>In bash, you should do your check in <a href=""http://mywiki.wooledge.org/ArithmeticExpression"" rel=""noreferrer"">arithmetic context</a>:</p>

<pre><code>if (( a &gt; b )); then
    ...
fi
</code></pre>

<p>For POSIX shells that don't support <code>(())</code>, you can use <code>-lt</code> and <code>-gt</code>.</p>

<pre><code>if [ ""$a"" -gt ""$b"" ]; then
    ...
fi
</code></pre>

<p>You can get a full list of comparison operators with <code>help test</code> or <code>man test</code>.</p>
"
"sudo echo ""something"" >> /etc/privilegedFile doesn't work","84882","<bash><shell><scripting><permissions><sudo>","613","<p>Use <code>tee --append</code> or <code>tee -a</code>.</p>

<pre><code>echo 'deb blah ... blah' | sudo tee -a /etc/apt/sources.list
</code></pre>

<p>Make sure to avoid quotes inside quotes.</p>

<p>To avoid printing data back to the console, redirect the output to /dev/null.</p>

<pre><code>echo 'deb blah ... blah' | sudo tee -a /etc/apt/sources.list &gt; /dev/null
</code></pre>

<p>Remember about the (<code>-a</code>/<code>--append</code>) flag! 
Just <code>tee</code> works like <code>&gt;</code> and will overwrite your file. <code>tee -a</code> works like <code>&gt;&gt;</code> and will write at the end of the file.</p>
"
"How to loop over files in directory and change path and add suffix to filename","20796200","<bash><for-loop><filenames><glob>","611","<p>A couple of notes first: when you use <code>Data/data1.txt</code> as an argument, should it really be <code>/Data/data1.txt</code> (with a leading slash)? Also, should the outer loop scan only for .txt files, or all files in /Data? Here's an answer, assuming <code>/Data/data1.txt</code> and .txt files only:</p>

<pre><code>#!/bin/bash
for filename in /Data/*.txt; do
    for ((i=0; i&lt;=3; i++)); do
        ./MyProgram.exe ""$filename"" ""Logs/$(basename ""$filename"" .txt)_Log$i.txt""
    done
done
</code></pre>

<p>Notes:</p>

<ul>
<li><code>/Data/*.txt</code> expands to the paths of the text files in /Data (<em>including</em> the /Data/ part)</li>
<li><code>$( ... )</code> runs a shell command and inserts its output at that point in the command line</li>
<li><code>basename somepath .txt</code> outputs the base part of somepath, with .txt removed from the end (e.g. <code>/Data/file.txt</code> -> <code>file</code>)</li>
</ul>

<p>If you needed to run MyProgram with <code>Data/file.txt</code> instead of <code>/Data/file.txt</code>, use <code>""${filename#/}""</code> to remove the leading slash. On the other hand, if it's really <code>Data</code> not <code>/Data</code> you want to scan, just use <code>for filename in Data/*.txt</code>.</p>
"
"Capturing multiple line output into a Bash variable","613572","<bash><variables>","610","<p>Actually, RESULT contains what you want — to demonstrate:</p>

<pre><code>echo ""$RESULT""
</code></pre>

<p>What you show is what you get from:</p>

<pre><code>echo $RESULT
</code></pre>

<hr>

<p>As noted in the comments, the difference is that (1) the double-quoted version of the variable (<code>echo ""$RESULT""</code>) preserves internal spacing of the value exactly as it is represented in the variable — newlines, tabs, multiple blanks and all — whereas (2) the unquoted version (<code>echo $RESULT</code>) replaces each sequence of one or more blanks, tabs and newlines with a single space. Thus (1) preserves the shape of the input variable, whereas (2) creates a potentially very long single line of output with 'words' separated by single spaces (where a 'word' is a sequence of non-whitespace characters; there needn't be any alphanumerics in any of the words).</p>
"
"How can I remove the first line of a text file using bash/sed script?","339483","<bash><scripting><sed>","607","<p>Try <a href=""http://man7.org/linux/man-pages/man1/tail.1.html"" rel=""noreferrer"">tail</a>:</p>

<pre><code>tail -n +2 ""$FILE""
</code></pre>

<p><code>-n x</code>: Just print the last <code>x</code> lines. <code>tail -n 5</code> would give you the last 5 lines of the input. The <code>+</code> sign kind of inverts the argument and make <code>tail</code> print anything but the first <code>x-1</code> lines. <code>tail -n +1</code> would print the whole file, <code>tail -n +2</code> everything but the first line, etc.</p>

<p>GNU <code>tail</code> is much faster than <code>sed</code>. <code>tail</code> is also available on BSD and the <code>-n +2</code> flag is consistent across both tools. Check the <a href=""https://www.freebsd.org/cgi/man.cgi?query=tail"" rel=""noreferrer"">FreeBSD</a> or <a href=""https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/tail.1.html"" rel=""noreferrer"">OS X</a> man pages for more. </p>

<p>The BSD version can be much slower than <code>sed</code>, though. I wonder how they managed that; <code>tail</code> should just read a file line by line while <code>sed</code> does pretty complex operations involving interpreting a script, applying regular expressions and the like.</p>

<p>Note: You may be tempted to use</p>

<pre><code># THIS WILL GIVE YOU AN EMPTY FILE!
tail -n +2 ""$FILE"" &gt; ""$FILE""
</code></pre>

<p>but this will give you an <strong>empty file</strong>. The reason is that the redirection (<code>&gt;</code>) happens before <code>tail</code> is invoked by the shell:</p>

<ol>
<li>Shell truncates file <code>$FILE</code></li>
<li>Shell creates a new process for <code>tail</code></li>
<li>Shell redirects stdout of the <code>tail</code> process to <code>$FILE</code></li>
<li><code>tail</code> reads from the now empty <code>$FILE</code></li>
</ol>

<p>If you want to remove the first line inside the file, you should use:</p>

<pre><code>tail -n +2 ""$FILE"" &gt; ""$FILE.tmp"" &amp;&amp; mv ""$FILE.tmp"" ""$FILE""
</code></pre>

<p>The <code>&amp;&amp;</code> will make sure that the file doesn't get overwritten when there is a problem.</p>
"
"How to wait in bash for several subprocesses to finish and return exit code !=0 when any subprocess ends with code !=0?","356100","<bash><process><wait>","606","<p><a href=""https://www.gnu.org/software/bash/manual/html_node/Job-Control-Builtins.html#index-wait"" rel=""noreferrer""><code>wait</code></a> also (optionally) takes the PID of the process to wait for, and with $! you get the PID of the last command launched in background.
Modify the loop to store the PID of each spawned sub-process into an array, and then loop again waiting on each PID.</p>

<pre><code># run processes and store pids in array
for i in $n_procs; do
    ./procs[${i}] &amp;
    pids[${i}]=$!
done

# wait for all pids
for pid in ${pids[*]}; do
    wait $pid
done
</code></pre>
"
"How do I get cURL to not show the progress bar?","7373752","<linux><bash><unix><scripting><curl>","605","<pre><code>curl -s http://google.com &gt; temp.html
</code></pre>

<p>works for curl version 7.19.5 on Ubuntu 9.10 (no progress bar). But if for some reason that does not work on your platform, you could always redirect stderr to /dev/null:</p>

<pre><code>curl  http://google.com 2&gt;/dev/null &gt; temp.html
</code></pre>
"
"Set environment variables from file of key/value pairs","19331497","<bash><variables><environment-variables>","603","<p>Problem with your approach is the <code>export</code> in the <code>while</code> loop is happening in a sub shell, and those variable will not be available in current shell (parent shell of while loop).</p>

<p>Add <code>export</code> command in the file itself:</p>

<pre><code>export MINIENTREGA_FECHALIMITE=""2011-03-31""
export MINIENTREGA_FICHEROS=""informe.txt programa.c""
export MINIENTREGA_DESTINO=""./destino/entrega-prac1""
</code></pre>

<p>Then you need to source in the file in current shell using:</p>

<pre><code>. ./conf/prac1
</code></pre>

<p>OR</p>

<pre><code>source ./conf/prac1
</code></pre>
"
"How to define hash tables in Bash?","1494178","<bash><dictionary><hashtable><associative-array>","602","<h1>Bash 4</h1>

<p>Bash 4 natively supports this feature.  Make sure your script's hashbang is <code>#!/usr/bin/env bash</code> or <code>#!/bin/bash</code> so you don't end up using <code>sh</code>.  Make sure you're either executing your script directly, or execute <code>script</code> with <code>bash script</code>. (Not actually executing a Bash script with Bash <em>does</em> happen, and will be <em>really</em> confusing!)</p>

<p>You declare an associative array by doing:</p>

<pre><code>declare -A animals
</code></pre>

<p>You can fill it up with elements using the normal array assignment operator. For example, if you want to have a map of <code>animal[sound(key)] = animal(value)</code>:</p>

<pre><code>animals=( [""moo""]=""cow"" [""woof""]=""dog"")
</code></pre>

<p>Or merge them:</p>

<pre><code>declare -A animals=( [""moo""]=""cow"" [""woof""]=""dog"")
</code></pre>

<p>Then use them just like normal arrays. Use</p>

<ul>
<li><p><code>animals['key']='value'</code> to set value</p></li>
<li><p><code>""${animals[@]}""</code> to expand the values</p></li>
<li><p><code>""${!animals[@]}""</code> (notice the <code>!</code>) to expand the keys  </p></li>
</ul>

<p>Don't forget to quote them:</p>

<pre><code>echo ""${animals[moo]}""
for sound in ""${!animals[@]}""; do echo ""$sound - ${animals[$sound]}""; done
</code></pre>

<h1>Bash 3</h1>

<p>Before bash 4, you don't have associative arrays.  <strong>Do not use <code>eval</code> to emulate them</strong>.  Avoid <code>eval</code> like the plague, because it <em>is</em> the plague of shell scripting.  The most important reason is that <code>eval</code> treats your data as executable code (there are many other reasons too).</p>

<p><em>First and foremost</em>: Consider upgrading to bash 4.  This will make the whole process much easier for you.</p>

<p>If there's a reason you can't upgrade, <code>declare</code> is a far safer option.  It does not evaluate data as bash code like <code>eval</code> does, and as such does not allow arbitrary code injection quite so easily.</p>

<p>Let's prepare the answer by introducing the concepts:</p>

<p>First, indirection.</p>

<pre><code>$ animals_moo=cow; sound=moo; i=""animals_$sound""; echo ""${!i}""
cow
</code></pre>

<p>Secondly, <code>declare</code>:</p>

<pre><code>$ sound=moo; animal=cow; declare ""animals_$sound=$animal""; echo ""$animals_moo""
cow
</code></pre>

<p>Bring them together:</p>

<pre><code># Set a value:
declare ""array_$index=$value""

# Get a value:
arrayGet() { 
    local array=$1 index=$2
    local i=""${array}_$index""
    printf '%s' ""${!i}""
}
</code></pre>

<p>Let's use it:</p>

<pre><code>$ sound=moo
$ animal=cow
$ declare ""animals_$sound=$animal""
$ arrayGet animals ""$sound""
cow
</code></pre>

<p>Note: <code>declare</code> cannot be put in a function.  Any use of <code>declare</code> inside a bash function turns the variable it creates <em>local</em> to the scope of that function, meaning we can't access or modify global arrays with it. (In bash 4 you can use declare -g to declare global variables - but in bash 4, you can use associative arrays in the first place, avoiding this workaround.)</p>

<p>Summary:</p>

<ul>
<li>Upgrade to bash 4 and use <code>declare -A</code> for associative arrays.</li>
<li>Use the <code>declare</code> option if you can't upgrade.</li>
<li>Consider using <code>awk</code> instead and avoid the issue altogether.</li>
</ul>
"
"How to detect the OS from a Bash script?","394230","<bash><os-detection>","596","<p>I think the following should work. I'm not sure about <code>win32</code> though.</p>

<pre><code>if [[ ""$OSTYPE"" == ""linux-gnu""* ]]; then
        # ...
elif [[ ""$OSTYPE"" == ""darwin""* ]]; then
        # Mac OSX
elif [[ ""$OSTYPE"" == ""cygwin"" ]]; then
        # POSIX compatibility layer and Linux environment emulation for Windows
elif [[ ""$OSTYPE"" == ""msys"" ]]; then
        # Lightweight shell and GNU utilities compiled for Windows (part of MinGW)
elif [[ ""$OSTYPE"" == ""win32"" ]]; then
        # I'm not sure this can happen.
elif [[ ""$OSTYPE"" == ""freebsd""* ]]; then
        # ...
else
        # Unknown.
fi
</code></pre>
"
"How do I write stderr to a file while using ""tee"" with a pipe?","692000","<linux><bash><unix>","594","<p>I'm assuming you want to still see STDERR and STDOUT on the terminal.  You could go for Josh Kelley's answer, but I find keeping a <code>tail</code> around in the background which outputs your log file very hackish and cludgy.  Notice how you need to keep an exra FD and do cleanup afterward by killing it and technically should be doing that in a <code>trap '...' EXIT</code>.</p>

<p>There is a better way to do this, and you've already discovered it: <code>tee</code>.</p>

<p>Only, instead of just using it for your stdout, have a tee for stdout and one for stderr.  How will you accomplish this?  Process substitution and file redirection:</p>

<pre><code>command &gt; &gt;(tee -a stdout.log) 2&gt; &gt;(tee -a stderr.log &gt;&amp;2)
</code></pre>

<p>Let's split it up and explain:</p>

<pre><code>&gt; &gt;(..)
</code></pre>

<p><code>&gt;(...)</code> (process substitution) creates a FIFO and lets <code>tee</code> listen on it.  Then, it uses <code>&gt;</code> (file redirection) to redirect the STDOUT of <code>command</code> to the FIFO that your first <code>tee</code> is listening on.</p>

<p>Same thing for the second:</p>

<pre><code>2&gt; &gt;(tee -a stderr.log &gt;&amp;2)
</code></pre>

<p>We use process substitution again to make a <code>tee</code> process that reads from STDIN and dumps it into <code>stderr.log</code>.  <code>tee</code> outputs its input back on STDOUT, but since its input is our STDERR, we want to redirect <code>tee</code>'s STDOUT to our STDERR again.  Then we use file redirection to redirect <code>command</code>'s STDERR to the FIFO's input (<code>tee</code>'s STDIN).</p>

<p>See <a href=""http://mywiki.wooledge.org/BashGuide/InputAndOutput"" rel=""noreferrer"">http://mywiki.wooledge.org/BashGuide/InputAndOutput</a></p>

<p>Process substitution is one of those really lovely things you get as a bonus of choosing <code>bash</code> as your shell as opposed to <code>sh</code> (POSIX or Bourne).</p>

<hr>

<p>In <code>sh</code>, you'd have to do things manually:</p>

<pre><code>out=""${TMPDIR:-/tmp}/out.$$"" err=""${TMPDIR:-/tmp}/err.$$""
mkfifo ""$out"" ""$err""
trap 'rm ""$out"" ""$err""' EXIT
tee -a stdout.log &lt; ""$out"" &amp;
tee -a stderr.log &lt; ""$err"" &gt;&amp;2 &amp;
command &gt;""$out"" 2&gt;""$err""
</code></pre>
"
"Find and Replace Inside a Text File from a Bash Command","525592","<bash><ssh><replace><scripting><ironpython>","594","<p>The easiest way is to use sed (or perl):</p>

<pre><code>sed -i -e 's/abc/XYZ/g' /tmp/file.txt
</code></pre>

<p>Which will invoke sed to do an in-place edit due to the <code>-i</code> option.  This can be called from bash.</p>

<p>If you really really want to use just bash, then the following can work:</p>

<pre><code>while read a; do
    echo ${a//abc/XYZ}
done &lt; /tmp/file.txt &gt; /tmp/file.txt.t
mv /tmp/file.txt{.t,}
</code></pre>

<p>This loops over each line, doing a substitution, and writing to a temporary file (don't want to clobber the input).  The move at the end just moves temporary to the original name.</p>
"
"Print a file, skipping the first X lines, in Bash","604864","<linux><bash><printing><skip>","587","<p>You'll need tail.  Some examples: </p>

<pre><code>$ tail great-big-file.log
&lt; Last 10 lines of great-big-file.log &gt;
</code></pre>

<p>If you really need to SKIP a particular number of ""first"" lines, use</p>

<pre><code>$ tail -n +&lt;N+1&gt; &lt;filename&gt;
&lt; filename, excluding first N lines. &gt;
</code></pre>

<p>That is, if you want to skip N lines, you start printing line N+1. Example:</p>

<pre><code>$ tail -n +11 /tmp/myfile
&lt; /tmp/myfile, starting at line 11, or skipping the first 10 lines. &gt;
</code></pre>

<p>If you want to just see the last so many lines, omit the ""+"":</p>

<pre><code>$ tail -n &lt;N&gt; &lt;filename&gt;
&lt; last N lines of file. &gt;
</code></pre>
"
"How to do a logical OR operation in shell scripting","4111475","<bash><unix><if-statement><sh>","585","<p>This should work:</p>

<pre><code>#!/bin/bash

if [ ""$#"" -eq 0 ] || [ ""$#"" -gt 1 ] ; then
    echo ""hello""
fi
</code></pre>

<p>I'm not sure if this is different in other shells but if you wish to use &lt;, >, you need to put them inside double parenthesis like so: </p>

<pre><code>if ((""$#"" &gt; 1))
 ...
</code></pre>
"
"How to obtain the number of CPUs/cores in Linux from the command line?","6481005","<linux><bash><cpu>","578","<pre><code>grep -c ^processor /proc/cpuinfo     
</code></pre>

<p>will count the number of lines starting with ""processor"" in <code>/proc/cpuinfo</code></p>

<p>For systems with hyper-threading, you can use</p>

<pre><code>grep ^cpu\\scores /proc/cpuinfo | uniq |  awk '{print $4}' 
</code></pre>

<p>which should return (for example) <code>8</code> (whereas the command above would return <code>16</code>)</p>
"
"Command not found error in Bash variable assignment","2268104","<bash><shell><syntax><sh><variable-assignment>","555","<p>You cannot have spaces around your '=' sign.</p>
<p>When you write:</p>
<pre><code>STR = &quot;foo&quot;
</code></pre>
<p>bash tries to run a command named STR with 2 arguments (the strings '=' and 'foo')</p>
<p>When you write:</p>
<pre><code>STR =foo
</code></pre>
<p>bash tries to run a command named STR with 1 argument (the string '=foo')</p>
<p>When you write:</p>
<pre><code>STR= foo
</code></pre>
<p>bash tries to run the command foo with STR set to the empty string in its environment.</p>
<p>I'm not sure if this helps to clarify or if it is mere obfuscation, but note that:</p>
<ol>
<li>the first command is exactly equivalent to: <code>STR &quot;=&quot; &quot;foo&quot;</code>,</li>
<li>the second is the same as <code>STR &quot;=foo&quot;</code>,</li>
<li>and the last is equivalent to <code>STR=&quot;&quot; foo</code>.</li>
</ol>
<p>The relevant section of the <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_09_01"" rel=""nofollow noreferrer"">sh language spec, section 2.9.1</a> states:</p>
<blockquote>
<p>A &quot;simple command&quot; is a sequence of optional variable assignments and redirections, in any sequence, optionally followed by words and redirections, terminated by a control operator.</p>
</blockquote>
<p>In that context, a <code>word</code> is the command that bash is going to run.  Any string containing <code>=</code> (in any position other than at the beginning of the string) which is not a redirection and in which the portion of the string before the <code>=</code> is a valid variable name is a variable assignment, while any string that is not a redirection or a variable assignment is a command.  In <code>STR = &quot;foo&quot;</code>, <code>STR</code> is not a variable assignment.</p>
"
"How to split a large text file into smaller files with equal number of lines?","2016894","<bash><file><unix>","547","<p>Have you looked at the split command?</p>

<pre class=""lang-none prettyprint-override""><code>$ split --help
Usage: split [OPTION] [INPUT [PREFIX]]
Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default
size is 1000 lines, and default PREFIX is `x'.  With no INPUT, or when INPUT
is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -a, --suffix-length=N   use suffixes of length N (default 2)
  -b, --bytes=SIZE        put SIZE bytes per output file
  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file
  -d, --numeric-suffixes  use numeric suffixes instead of alphabetic
  -l, --lines=NUMBER      put NUMBER lines per output file
      --verbose           print a diagnostic to standard error just
                            before each output file is opened
      --help     display this help and exit
      --version  output version information and exit
</code></pre>

<p>You could do something like this:</p>

<pre><code>split -l 200000 filename
</code></pre>

<p>which will create files each with 200000 lines named <code>xaa xab xac</code> ...</p>

<p>Another option, split by size of output file (still splits on line breaks):</p>

<pre><code> split -C 20m --numeric-suffixes input_filename output_prefix
</code></pre>

<p>creates files like <code>output_prefix01 output_prefix02 output_prefix03 ...</code> each of max size 20 megabytes.</p>
"
"Remove a fixed prefix/suffix from a string in Bash","16623835","<bash>","544","<pre><code>$ foo=${string#&quot;$prefix&quot;}
$ foo=${foo%&quot;$suffix&quot;}
$ echo &quot;${foo}&quot;
o-wor
</code></pre>
<p>This is documented in the <a href=""https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html"" rel=""nofollow noreferrer"">Shell Parameter Expansion</a> section of the manual:</p>
<blockquote>
<p><code>${parameter#word}</code><br />
<code>${parameter##word}</code></p>
<p>The word is expanded to produce a pattern and matched according to the rules described below (see <a href=""https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html"" rel=""nofollow noreferrer"">Pattern Matching</a>). If the pattern matches the beginning of the expanded value of parameter, then the result of the expansion is the expanded value of parameter with the shortest matching pattern (the <code>#</code> case) or the longest matching pattern (the <code>##</code> case) deleted. […]</p>
<p><code>${parameter%word}</code><br />
<code>${parameter%%word}</code></p>
<p>The word is expanded to produce a pattern and matched according to the rules described below (see <a href=""https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html"" rel=""nofollow noreferrer"">Pattern Matching</a>). If the pattern matches a trailing portion of the expanded value of parameter, then the result of the expansion is the value of parameter with the shortest matching pattern (the <code>%</code> case) or the longest matching pattern (the <code>%%</code> case) deleted. […]</p>
</blockquote>
"
"Why is whitespace sometimes needed around metacharacters?","21186724","<bash><shell><syntax><syntax-error>","544","<p>There is a list of characters that separate tokens in BASH. These characters are called <em>metacharacters</em> and they are <code>|</code>, <code>&amp;</code>, <code>;</code>, <code>(</code>, <code>)</code>, <code>&lt;</code>, <code>&gt;</code>, <strong>space</strong> and <strong>tab</strong>. On the other hand, curly braces (<code>{</code> and <code>}</code>) are just ordinary characters that make up words.</p>

<p>Omitting the second space before <code>}</code> will do, since <code>&amp;</code> is a metacharacter. Therefore, your tattoo should have at least one space character.</p>

<pre><code>:(){ :|:&amp;};:
</code></pre>
"
"Colorized grep -- viewing the entire file with highlighted matches","981601","<bash><shell><colors><grep>","537","<p>Here are some ways to do it:</p>
<pre><code>grep --color 'pattern\|$' file
grep --color -E 'pattern|$' file
egrep --color 'pattern|$' file
</code></pre>
<p>The <code>|</code> symbol is the OR operator. Either escape it using <code>\</code> or tell grep that the search text has to be interpreted as regular expressions by adding -E or using the <code>egrep</code> command instead of <code>grep</code>.</p>
<p>The search text &quot;pattern|$&quot; is actually a trick, it will match lines that have <code>pattern</code> OR lines that have an end. Because all lines have an end, all lines are matched, but the end of a line isn't actually any characters, so it won't be colored.</p>
"
"Why do you need to put #!/bin/bash at the beginning of a script file?","8967902","<linux><bash><scripting><shebang>","534","<p>It's a convention so the *nix shell knows what kind of interpreter to run.</p>

<p>For example, older flavors of ATT defaulted to <em>sh</em> (the Bourne shell), while older versions of BSD defaulted to <em>csh</em> (the C shell).</p>

<p>Even today (where most systems run bash, the <em>""Bourne Again Shell""</em>), scripts can be in bash, python, perl, ruby, PHP, etc, etc.  For example, you might see <code>#!/bin/perl</code> or <code>#!/bin/perl5</code>.</p>

<p>PS:
The exclamation mark (<code>!</code>) is affectionately called <em>""bang""</em>.  The shell comment symbol (<code>#</code>) is sometimes called <em>""hash""</em>.</p>

<p>PPS:
Remember - under *nix, associating a suffix with a file type is merely a <em>convention</em>, not a <em>""rule""</em>.  An <em>executable</em> can be a binary program, any one of a million script types and other things as well. Hence the need for <code>#!/bin/bash</code>.</p>
"
"How to run a shell script on a Unix console or Mac terminal?","733824","<linux><bash><macos><shell><unix>","528","<p>To run a non-executable <code>sh</code> script, use:</p>

<pre><code>sh myscript
</code></pre>

<p>To run a non-executable <code>bash</code> script, use:</p>

<pre><code>bash myscript
</code></pre>

<p>To start an executable (which is any file with executable permission); you just specify it by its path:</p>

<pre><code>/foo/bar
/bin/bar
./bar
</code></pre>

<p>To make a script executable, give it the necessary permission:</p>

<pre><code>chmod +x bar
./bar
</code></pre>

<p>When a file is executable, the <strong>kernel</strong> is responsible for figuring out how to execte it.  For non-binaries, this is done by looking at the first line of the file.  It should contain a <code>hashbang</code>:</p>

<pre><code>#! /usr/bin/env bash
</code></pre>

<p>The hashbang tells the kernel what program to run (in this case the command <code>/usr/bin/env</code> is ran with the argument <code>bash</code>).  Then, the script is passed to the program (as second argument) along with all the arguments you gave the script as subsequent arguments.</p>

<p>That means <strong>every script that is executable should have a hashbang</strong>.  If it doesn't, you're not telling the kernel what it <em>is</em>, and therefore the kernel doesn't know what program to use to interprete it.  It could be <code>bash</code>, <code>perl</code>, <code>python</code>, <code>sh</code>, or something else.  (In reality, the kernel will often use the user's default shell to interprete the file, which is very dangerous because it might not be the right interpreter at all or it might be able to parse some of it but with subtle behavioural differences such as is the case between <code>sh</code> and <code>bash</code>).</p>

<h1>A note on <code>/usr/bin/env</code></h1>

<p>Most commonly, you'll see hash bangs like so:</p>

<pre><code>#!/bin/bash
</code></pre>

<p>The result is that the kernel will run the program <code>/bin/bash</code> to interpret the script.  Unfortunately, <code>bash</code> is not always shipped by default, and it is not always available in <code>/bin</code>.  While on Linux machines it usually is, there are a range of other POSIX machines where <code>bash</code> ships in various locations, such as <code>/usr/xpg/bin/bash</code> or <code>/usr/local/bin/bash</code>.</p>

<p>To write a portable bash script, we can therefore not rely on hard-coding the location of the <code>bash</code> program.  POSIX already has a mechanism for dealing with that: <code>PATH</code>.  The idea is that you install your programs in one of the directories that are in <code>PATH</code> and the system should be able to find your program when you want to run it by name.</p>

<p>Sadly, you <strong><em>cannot</em></strong> just do this:</p>

<pre><code>#!bash
</code></pre>

<p>The kernel won't (some might) do a <code>PATH</code> search for you.  There is a program that can do a <code>PATH</code> search for you, though, it's called <code>env</code>.  Luckily, nearly all systems have an <code>env</code> program installed in <code>/usr/bin</code>.  So we start <code>env</code> using a hardcoded path, which then does a <code>PATH</code> search for <code>bash</code> and runs it so that it can interpret your script:</p>

<pre><code>#!/usr/bin/env bash
</code></pre>

<p>This approach has one downside: According to POSIX, the hashbang can have <strong>one argument</strong>.  In this case, we use <code>bash</code> as the argument to the <code>env</code> program.  That means we have no space left to pass arguments to <code>bash</code>.  So there's no way to convert something like <code>#!/bin/bash -exu</code> to this scheme.  You'll have to put <code>set -exu</code> after the hashbang instead.</p>

<p>This approach also has another advantage: Some systems may ship with a <code>/bin/bash</code>, but the user may not like it, may find it's buggy or outdated, and may have installed his own <code>bash</code> somewhere else.  This is often the case on OS X (Macs) where Apple ships an outdated <code>/bin/bash</code> and users install an up-to-date <code>/usr/local/bin/bash</code> using something like Homebrew.  When you use the <code>env</code> approach which does a <code>PATH</code> search, you take the user's preference into account and use his preferred bash over the one his system shipped with.</p>
"
"How to write a bash script that takes optional input arguments?","9332802","<bash><arguments><parameter-passing>","520","<p>You could use the default-value syntax:</p>

<pre><code>somecommand ${1:-foo}
</code></pre>

<p>The above will, as described in <a href=""http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion"" rel=""noreferrer"">Bash Reference Manual - 3.5.3 Shell Parameter Expansion</a> [emphasis mine]:</p>

<blockquote>
  <p>If parameter is unset <em>or null</em>, the expansion of word is substituted. Otherwise, the value of parameter is substituted.</p>
</blockquote>

<p>If you only want to substitute a default value if the parameter is unset (but not if it's null, e.g. not if it's an empty string), use this syntax instead:</p>

<pre><code>somecommand ${1-foo}
</code></pre>

<p>Again from <a href=""http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion"" rel=""noreferrer"">Bash Reference Manual - 3.5.3 Shell Parameter Expansion</a>:</p>

<blockquote>
  <p>Omitting the colon results in a test only for a parameter that is unset. Put another way, if the colon is included, the operator tests for both parameter’s existence and that its value is not null; if the colon is omitted, the operator tests only for existence.</p>
</blockquote>
"
"ls command: how can I get a recursive full-path listing, one line per file?","1767384","<bash><command-line><find><ls>","513","<p>If you really want to use <code>ls</code>, then format its output using awk:</p>

<pre><code>ls -R /path | awk '
/:$/&amp;&amp;f{s=$0;f=0}
/:$/&amp;&amp;!f{sub(/:$/,"""");s=$0;f=1;next}
NF&amp;&amp;f{ print s""/""$0 }'
</code></pre>
"
"How do I rename the extension for a bunch of files?","1224766","<bash><rename><file-rename>","510","<p>For an better solution (with only bash functionality, as opposed to external calls), see <a href=""https://stackoverflow.com/questions/1224766/bash-rename-files/1225236#1225236"">one of the other answers</a>.</p>

<hr>

<p>The following would do and does not require the system to have the <code>rename</code> program (although you would most often have this on a system):</p>

<pre><code>for file in *.html; do
    mv ""$file"" ""$(basename ""$file"" .html).txt""
done
</code></pre>

<p><em>EDIT:</em> As pointed out in the comments, this does not work for filenames with spaces in them without proper quoting (now added above). When working purely on your own files that you know do not have spaces in the filenames this will work but whenever you write something that may be reused at a later time, do not skip proper quoting. </p>
"
"What's a concise way to check that environment variables are set in a Unix shell script?","307503","<bash><unix><shell>","505","<h3>Parameter Expansion</h3>
<p>The obvious answer is to use one of the special forms of parameter expansion:</p>
<pre><code>: ${STATE?&quot;Need to set STATE&quot;}
: ${DEST:?&quot;Need to set DEST non-empty&quot;}
</code></pre>
<p>Or, better (see section on 'Position of double quotes' below):</p>
<pre><code>: &quot;${STATE?Need to set STATE}&quot;
: &quot;${DEST:?Need to set DEST non-empty}&quot;
</code></pre>
<p>The first variant (using just <code>?</code>) requires STATE to be set, but STATE=&quot;&quot; (an empty string) is OK — not exactly what you want, but the alternative and older notation.</p>
<p>The second variant (using <code>:?</code>) requires DEST to be set and non-empty.</p>
<p>If you supply no message, the shell provides a default message.</p>
<p>The <code>${var?}</code> construct is portable back to Version 7 UNIX and the Bourne Shell (1978 or thereabouts).  The <code>${var:?}</code> construct is slightly more recent: I think it was in System III UNIX circa 1981, but it may have been in PWB UNIX before that.  It is therefore in the Korn Shell, and in the POSIX shells, including specifically Bash.</p>
<p>It is usually documented in the shell's man page in a section called <a href=""http://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion"" rel=""noreferrer"">Parameter Expansion</a>.  For example, the <code>bash</code> manual says:</p>
<blockquote>
<pre><code>${parameter:?word}
</code></pre>
<p>Display Error if Null or Unset.  If parameter is null or unset, the expansion of word (or a message to that effect if word is not present) is written to the standard error and the shell, if it is not interactive, exits.  Otherwise, the value of parameter is substituted.</p>
</blockquote>
<h3>The Colon Command</h3>
<p>I should probably add that the colon command simply has its arguments evaluated and then succeeds.  It is the original shell comment notation (before '<code>#</code>' to end of line).  For a long time, Bourne shell scripts had a colon as the first character.  The C Shell would read a script and use the first character to determine whether it was for the C Shell (a '<code>#</code>' hash) or the Bourne shell (a '<code>:</code>' colon).  Then the kernel got in on the act and added support for '<code>#!/path/to/program</code>' and the Bourne shell got '<code>#</code>' comments, and the colon convention went by the wayside.  But if you come across a script that starts with a colon, now you will know why.</p>
<hr>
<h3>Position of double quotes</h3>
<p><a href=""https://stackoverflow.com/users/320399/blong"">blong</a> asked in a <a href=""https://stackoverflow.com/questions/307503/whats-the-best-way-to-check-that-environment-variables-are-set-in-unix-shellscr/307735?noredirect=1#comment53771660_307735"">comment</a>:</p>
<blockquote>
<p>Any thoughts on this discussion? <a href=""https://github.com/koalaman/shellcheck/issues/380#issuecomment-145872749"" rel=""noreferrer"">https://github.com/koalaman/shellcheck/issues/380#issuecomment-145872749</a></p>
</blockquote>
<p>The gist of the discussion is:</p>
<blockquote>
<p>… However, when I <code>shellcheck</code> it (with version 0.4.1), I get this message:</p>
<pre><code>In script.sh line 13:
: ${FOO:?&quot;The environment variable 'FOO' must be set and non-empty&quot;}
  ^-- SC2086: Double quote to prevent globbing and word splitting.
</code></pre>
<p>Any advice on what I should do in this case?</p>
</blockquote>
<p>The short answer is &quot;do as <code>shellcheck</code> suggests&quot;:</p>
<pre><code>: &quot;${STATE?Need to set STATE}&quot;
: &quot;${DEST:?Need to set DEST non-empty}&quot;
</code></pre>
<p>To illustrate why, study the following.  Note that the <code>:</code> command doesn't echo its arguments (but the shell does evaluate the arguments).  We want to see the arguments, so the code below uses <code>printf &quot;%s\n&quot;</code> in place of <code>:</code>.</p>
<pre><code>$ mkdir junk
$ cd junk
$ &gt; abc
$ &gt; def
$ &gt; ghi
$ 
$ x=&quot;*&quot;
$ printf &quot;%s\n&quot; ${x:?You must set x}    # Careless; not recommended
abc
def
ghi
$ unset x
$ printf &quot;%s\n&quot; ${x:?You must set x}    # Careless; not recommended
bash: x: You must set x
$ printf &quot;%s\n&quot; &quot;${x:?You must set x}&quot;  # Careful: should be used
bash: x: You must set x
$ x=&quot;*&quot;
$ printf &quot;%s\n&quot; &quot;${x:?You must set x}&quot;  # Careful: should be used
*
$ printf &quot;%s\n&quot; ${x:?&quot;You must set x&quot;}  # Not quite careful enough
abc
def
ghi
$ x=
$ printf &quot;%s\n&quot; ${x:?&quot;You must set x&quot;}  # Not quite careful enough
bash: x: You must set x
$ unset x
$ printf &quot;%s\n&quot; ${x:?&quot;You must set x&quot;}  # Not quite careful enough
bash: x: You must set x
$ 
</code></pre>
<p>Note how the value in <code>$x</code> is expanded to first <code>*</code> and then a list of file names when the overall expression is not in double quotes.  This is what <code>shellcheck</code> is recommending should be fixed.  I have not verified that it doesn't object to the form where the expression is enclosed in double quotes, but it is a reasonable assumption that it would be OK.</p>
"
"Bash ignoring error for a particular command","11231937","<linux><bash>","505","<p>The solution:</p>

<pre><code>particular_script || true
</code></pre>

<p>Example:</p>

<pre><code>$ cat /tmp/1.sh
particular_script()
{
    false
}

set -e

echo one
particular_script || true
echo two
particular_script
echo three

$ bash /tmp/1.sh
one
two
</code></pre>

<p><code>three</code> will be never printed.</p>

<p>Also, I want to add that when <code>pipefail</code> is on,
it is enough for shell to think that the entire pipe has non-zero exit code
when one of commands in the pipe has non-zero exit code (with <code>pipefail</code> off it must the last one).</p>

<pre><code>$ set -o pipefail
$ false | true ; echo $?
1
$ set +o pipefail
$ false | true ; echo $?
0
</code></pre>
"
"How to obtain the absolute path of a file via Shell (BASH/ZSH/SH)?","3915040","<bash><shell><path>","493","<p>Use <a href=""https://man7.org/linux/man-pages/man1/realpath.1.html"" rel=""noreferrer""><code>realpath</code></a></p>
<pre><code>$ realpath example.txt
/home/username/example.txt
</code></pre>
"
"Ternary operator (?:) in Bash","3953645","<bash><syntax><conditional-operator>","489","<p>ternary operator <code>? :</code> is just short form of <code>if/else</code></p>

<pre><code>case ""$b"" in
 5) a=$c ;;
 *) a=$d ;;
esac
</code></pre>

<p>Or</p>

<pre><code> [[ $b = 5 ]] &amp;&amp; a=""$c"" || a=""$d""
</code></pre>
"
"How to return a string value from a Bash function","3236871","<string><bash><function><return-value>","484","<p>There is no better way I know of. Bash knows only status codes (integers) and strings written to the stdout.</p>
"
"Process all arguments except the first one (in a bash script)","9057387","<bash><shell>","482","<p>Use this:</p>

<pre><code>echo ""${@:2}""
</code></pre>

<hr>

<p>The following syntax:</p>

<pre><code>echo ""${*:2}""
</code></pre>

<p>would work as well, but is not recommended, because as <a href=""https://stackoverflow.com/questions/9057387/process-all-arguments-except-the-first-one#comment11369452_9057392"">@Gordon</a> already explained, that using <code>*</code>, it runs all of the arguments together as a single argument with spaces, while <code>@</code> preserves the breaks between them (even if some of the arguments themselves contain spaces). It doesn't make the difference with <code>echo</code>, but it matters for many other commands.</p>
"
"Bash script and /bin/bash^M: bad interpreter: No such file or directory","14219092","<bash>","477","<p>I have seen this issue when creating scripts in Windows env and then porting over to run on a Unix environment.</p>

<p>Try running <code>dos2unix</code>  on the script:</p>

<p><a href=""http://dos2unix.sourceforge.net/"" rel=""noreferrer"">http://dos2unix.sourceforge.net/</a></p>

<p>Or just rewrite the script in your Unix env using <code>vi</code> and test.</p>

<p>Unix uses different line endings so can't read the file you created on Windows. Hence it is seeing ^M as an illegal character.</p>

<p>If you want to write a file on Windows and then port over, make sure your editor is set to create files in UNIX format.</p>

<p>In notepad++ in the bottom right of the screen, it tells you the document format. By default, it will say <code>Dos\Windows</code>. To change it go to </p>

<ul>
<li>settings->preferences </li>
<li>new document / default directory tab</li>
<li>select the format as unix and close</li>
<li>create a new document</li>
</ul>
"
"How to join multiple lines of file names into one with custom delimiter?","2764051","<linux><bash><shell><parsing><merge>","476","<p>Similar to the very first option but omits the trailing delimiter </p>

<pre><code>ls -1 | paste -sd "","" -
</code></pre>
"
"How to create a file in Linux from terminal window?","9381463","<linux><bash><file><command-line-interface>","475","<p>Depending on what you want the file to contain:</p>

<ul>
<li><code>touch /path/to/file</code> for an empty file</li>
<li><p><code>somecommand &gt; /path/to/file</code> for a file containing the output of some command.</p>

<pre><code>  eg: grep --help &gt; randomtext.txt
      echo ""This is some text"" &gt; randomtext.txt
</code></pre></li>
<li><p><code>nano /path/to/file</code> or <code>vi /path/to/file</code> (or <code>any other editor emacs,gedit etc</code>)<br>
It either opens the existing one for editing or creates &amp; opens the empty file to enter, if it doesn't exist</p></li>
</ul>
"
"Aborting a shell script if any command returns a non-zero value?","821396","<linux><bash><unix><shell>","474","<p>Add this to the beginning of the script:</p>

<pre><code>set -e
</code></pre>

<p>This will cause the shell to exit immediately if a simple command exits with a nonzero exit value.  A simple command is any command not part of an if, while, or until test, or part of an &amp;&amp; or || list.</p>

<p>See the <a href=""https://ss64.com/bash/set.html"" rel=""noreferrer"">bash(1) man page</a> on the ""set"" internal command for more details.</p>

<p>I personally start almost all shell scripts with ""set -e"".  It's really annoying to have a script stubbornly continue when something fails in the middle and breaks assumptions for the rest of the script.</p>
"
"Multi-line string with extra space (preserved indentation)","23929235","<string><bash><shell><echo>","465","<p>Heredoc sounds more convenient for this purpose. It is used to send multiple commands to a command interpreter program like <em>ex</em> or <em>cat</em></p>

<pre><code>cat &lt;&lt; EndOfMessage
This is line 1.
This is line 2.
Line 3.
EndOfMessage
</code></pre>

<p>The string after <code>&lt;&lt;</code> indicates where to stop.</p>

<p>To send these lines to a file, use:</p>

<pre><code>cat &gt; $FILE &lt;&lt;- EOM
Line 1.
Line 2.
EOM
</code></pre>

<p>You could also store these lines to a variable:</p>

<pre><code>read -r -d '' VAR &lt;&lt; EOM
This is line 1.
This is line 2.
Line 3.
EOM
</code></pre>

<p>This stores the lines to the variable named <code>VAR</code>.</p>

<p>When printing, remember the quotes around the variable otherwise you won't see the newline characters.</p>

<pre><code>echo ""$VAR""
</code></pre>

<p>Even better, you can use indentation to make it stand out more in your code. This time just add a <code>-</code> after <code>&lt;&lt;</code> to stop the tabs from appearing.</p>

<pre><code>read -r -d '' VAR &lt;&lt;- EOM
    This is line 1.
    This is line 2.
    Line 3.
EOM
</code></pre>

<p>But then you must use tabs, not spaces, for indentation in your code.</p>
"
"How to zero pad a sequence of integers in bash so that all have the same width?","8789729","<bash><numbers><padding>","464","<p>In your specific case though it's probably easiest to use the <code>-f</code> flag to <code>seq</code> to get it to format the numbers as it outputs the list.  For example:</p>

<pre><code>for i in $(seq -f ""%05g"" 10 15)
do
  echo $i
done
</code></pre>

<p>will produce the following output:</p>

<pre><code>00010
00011
00012
00013
00014
00015
</code></pre>

<p>More generally, <code>bash</code> has <code>printf</code> as a built-in so you can pad output with zeroes as follows:</p>

<pre><code>$ i=99
$ printf ""%05d\n"" $i
00099
</code></pre>

<p>You can use the <code>-v</code> flag to store the output in another variable:</p>

<pre><code>$ i=99
$ printf -v j ""%05d"" $i
$ echo $j
00099
</code></pre>

<p>Notice that <code>printf</code> supports a slightly different format to <code>seq</code> so you need to use <code>%05d</code> instead of <code>%05g</code>.</p>
"
"Difference between return and exit in Bash functions","4419952","<bash><function><return-value><return><exit>","461","<p>From <code>man bash</code> on <code>return [n]</code>;</p>

<blockquote>
  <p>Causes a function to stop executing and return  the value  specified by n to its caller.  If n is omitted, the return status is that of the last  command executed  in  the function body.</p>
</blockquote>

<p>... on <code>exit [n]</code>:</p>

<blockquote>
  <p>Cause  the  shell to exit with a status of n.  If n is omitted, the exit status is  that  of  the  last command  executed.   A  trap  on  EXIT  is executed before the shell terminates.</p>
</blockquote>

<p><strong>EDIT:</strong></p>

<p>As per your edit of the question, regarding exit codes, <code>return</code> has nothing to do with exit codes. Exit codes are intended for <strong>applications/scripts</strong>, not functions. So in this regard, the only keyword that sets the exit code of the script (the one that can be caught by the calling program using the <code>$?</code> shell variable) is <code>exit</code>.</p>

<p><strong>EDIT 2:</strong></p>

<p>My last statement referring <code>exit</code> is causing some comments. It was made to differentiate <code>return</code> and <code>exit</code> for the understanding of the OP, and in fact, at <em>any</em> given point of a program/shell script, <code>exit</code> is the only way of ending the script with an exit code to the calling process.</p>

<p>Every command executed in the shell produces a local ""exit code"": it sets the <code>$?</code> variable to that code, and can be used with <code>if</code>,  <code>&amp;&amp;</code> and other operators to conditionally execute other commands.</p>

<p>These exit codes (and the value of the <code>$?</code> variable) are reset by each command execution.</p>

<p>Incidentally, the exit code of the last command executed by the script is used as the exit code of the script itself as seen by the calling process. </p>

<p>Finally, functions, when called, act as shell commands with respect to exit codes. The exit code of the function (<em>within</em> the function) is set by using <code>return</code>. So when in a function <code>return 0</code> is run, the function execution terminates, giving an exit code of 0.</p>
"
"Length of string in bash","17368067","<bash><variables><string-length>","460","<h3>UTF-8 string length</h3>

<p>In addition to <a href=""https://stackoverflow.com/a/17368090/1983854"">fedorqui's correct answer</a>, I would like to show the difference between string length and byte length:</p>

<pre><code>myvar='Généralités'
chrlen=${#myvar}
oLang=$LANG oLcAll=$LC_ALL
LANG=C LC_ALL=C
bytlen=${#myvar}
LANG=$oLang LC_ALL=$oLcAll
printf ""%s is %d char len, but %d bytes len.\n"" ""${myvar}"" $chrlen $bytlen
</code></pre>

<p>will render:</p>

<pre><code>Généralités is 11 char len, but 14 bytes len.
</code></pre>

<p>you could even have a look at stored chars:</p>

<pre><code>myvar='Généralités'
chrlen=${#myvar}
oLang=$LANG oLcAll=$LC_ALL
LANG=C LC_ALL=C
bytlen=${#myvar}
printf -v myreal ""%q"" ""$myvar""
LANG=$oLang LC_ALL=$oLcAll
printf ""%s has %d chars, %d bytes: (%s).\n"" ""${myvar}"" $chrlen $bytlen ""$myreal""
</code></pre>

<p>will answer:</p>

<pre><code>Généralités has 11 chars, 14 bytes: ($'G\303\251n\303\251ralit\303\251s').
</code></pre>

<p><strong>Nota:</strong> According to <a href=""https://stackoverflow.com/questions/17368067/length-of-string-in-bash/31009961#comment69945980_31009961"">Isabell Cowan's comment</a>, I've added setting to <code>$LC_ALL</code> along with <code>$LANG</code>.</p>

<h3>Length of an argument</h3>

<p>Argument work same as regular variables</p>

<pre><code>strLen() {
    local bytlen sreal oLang=$LANG oLcAll=$LC_ALL
    LANG=C LC_ALL=C
    bytlen=${#1}
    printf -v sreal %q ""$1""
    LANG=$oLang LC_ALL=$oLcAll
    printf ""String '%s' is %d bytes, but %d chars len: %s.\n"" ""$1"" $bytlen ${#1} ""$sreal""
}
</code></pre>

<p>will work as</p>

<pre><code>strLen théorème
String 'théorème' is 10 bytes, but 8 chars len: $'th\303\251or\303\250me'
</code></pre>

<h3>Useful <code>printf</code> correction tool:</h3>

<p>If you:</p>

<pre><code>for string in Généralités Language Théorème Février  ""Left: ←"" ""Yin Yang ☯"";do
    printf "" - %-14s is %2d char length\n"" ""'$string'""  ${#string}
done

 - 'Généralités' is 11 char length
 - 'Language'     is  8 char length
 - 'Théorème'   is  8 char length
 - 'Février'     is  7 char length
 - 'Left: ←'    is  7 char length
 - 'Yin Yang ☯' is 10 char length
</code></pre>

<p>Not really <em>pretty</em>... For this, there is a little function:</p>

<pre><code>strU8DiffLen () { 
    local bytlen oLang=$LANG oLcAll=$LC_ALL
    LANG=C LC_ALL=C
    bytlen=${#1}
    LANG=$oLang LC_ALL=$oLcAll
    return $(( bytlen - ${#1} ))
}
</code></pre>

<p>Then now:</p>

<pre><code>for string in Généralités Language Théorème Février  ""Left: ←"" ""Yin Yang ☯"";do
    strU8DiffLen ""$string""
    printf "" - %-$((14+$?))s is %2d chars length, but uses %2d bytes\n"" \
        ""'$string'"" ${#string} $((${#string}+$?))
  done 

 - 'Généralités'  is 11 chars length, but uses 14 bytes
 - 'Language'     is  8 chars length, but uses  8 bytes
 - 'Théorème'     is  8 chars length, but uses 10 bytes
 - 'Février'      is  7 chars length, but uses  8 bytes
 - 'Left: ←'      is  7 chars length, but uses  9 bytes
 - 'Yin Yang ☯'   is 10 chars length, but uses 12 bytes
</code></pre>

<h3>Unfortunely, this is not perfect!</h3>

<p>But there left some strange UTF-8 behaviour, like double-spaced chars, zero spaced chars, reverse deplacement and other that could not be as simple...</p>

<p>Have a look at <a href=""https://f-hauri.ch/vrac/diffU8test.sh"" rel=""noreferrer"">diffU8test.sh</a> or <a href=""https://f-hauri.ch/vrac/diffU8test.sh.txt"" rel=""noreferrer"">diffU8test.sh.txt</a> for more limitations.</p>
"
"How to get a password from a shell script without echoing","3980668","<bash><shell><scripting><sh>","459","<p>Here is another way to do it:</p>

<pre><code>#!/bin/bash
# Read Password
echo -n Password: 
read -s password
echo
# Run Command
echo $password
</code></pre>

<p>The <code>read -s</code> will turn off echo for you. Just replace the <code>echo</code> on the last line with the command you want to run.</p>
"
"How can I join elements of an array in Bash?","1527049","<arrays><bash>","455","<p>A 100% pure Bash function that supports multi-character delimiters is:</p>
<pre><code>function join_by { local d=$1; shift; local f=$1; shift; printf %s &quot;$f&quot; &quot;${@/#/$d}&quot;; }
</code></pre>
<p>For example,</p>
<pre><code>join_by , a b c #a,b,c
join_by ' , ' a b c #a , b , c
join_by ')|(' a b c #a)|(b)|(c
join_by ' %s ' a b c #a %s b %s c
join_by $'\n' a b c #a&lt;newline&gt;b&lt;newline&gt;c
join_by - a b c #a-b-c
join_by '\' a b c #a\b\c
join_by '-n' '-e' '-E' '-n' #-e-n-E-n-n
join_by , #
join_by , a #a
</code></pre>
<p>The code above is based on the ideas by @gniourf_gniourf, @AdamKatz, and @MattCowell.</p>
<p>Alternatively, a simpler function that supports only a single character delimiter, would be:</p>
<pre><code>function join_by { local IFS=&quot;$1&quot;; shift; echo &quot;$*&quot;; }
</code></pre>
<p>For example,</p>
<pre><code>join_by , a &quot;b c&quot; d #a,b c,d
join_by / var local tmp #var/local/tmp
join_by , &quot;${FOO[@]}&quot; #a,b,c
</code></pre>
<p>This solution is based on Pascal Pilz's original suggestion.</p>
<p>A detailed explanation of the solutions proposed here can be found in <a href=""https://dev.to/meleu/how-to-join-array-elements-in-a-bash-script-303a"" rel=""noreferrer"">&quot;How to join() array elements in a bash script&quot;, an article by <em>meleu</em> at <em>dev.to</em></a>.</p>
"
"Can a shell script set environment variables of the calling shell?","496702","<bash><shell><csh><tcsh>","455","<p>Your shell process has a copy of the parent's environment and no access to the parent process's environment whatsoever. When your shell process terminates any changes you've made to its environment are lost. Sourcing a script file is the most commonly used method for configuring a shell environment, you may just want to bite the bullet and maintain one for each of the two flavors of shell.</p>
"
"Expansion of variables inside single quotes in a command in Bash","13799789","<bash><shell><variables><quotes>","449","<p>Inside single quotes everything is preserved literally, without exception.</p>

<p>That means you have to close the quotes, insert something, and then re-enter again.</p>

<pre><code>'before'""$variable""'after'
'before'""'""'after'
'before'\''after'
</code></pre>

<p>Word concatenation is simply done by juxtaposition. As you can verify, each of the above lines is a single word to the shell. Quotes (single or double quotes, depending on the situation) don't isolate words. They are only used to disable interpretation of various special characters, like whitespace, <code>$</code>, <code>;</code>... For a good tutorial on quoting see Mark Reed's answer. Also relevant: <a href=""https://stackoverflow.com/questions/15783701/which-characters-need-to-be-escaped-in-bash-how-do-we-know-it/20053121"">Which characters need to be escaped in bash?</a></p>

<h2>Do not concatenate strings interpreted by a shell</h2>

<p>You should absolutely avoid building shell commands by concatenating variables. This is a bad idea similar to concatenation of SQL fragments (SQL injection!).</p>

<p>Usually it is possible to have placeholders in the command, and to supply the command together with variables so that the callee can receive them from the invocation arguments list.</p>

<p>For example, the following is very unsafe. DON'T DO THIS</p>

<pre><code>script=""echo \""Argument 1 is: $myvar\""""
/bin/sh -c ""$script""
</code></pre>

<p>If the contents of <code>$myvar</code> is untrusted, here is an exploit:</p>

<pre><code>myvar='foo""; echo ""you were hacked'
</code></pre>

<p>Instead of the above invocation, use positional arguments. The following invocation is better -- it's not exploitable:</p>

<pre><code>script='echo ""arg 1 is: $1""'
/bin/sh -c ""$script"" -- ""$myvar""
</code></pre>

<p>Note the use of single ticks in the assignment to <code>script</code>, which means that it's taken literally, without variable expansion or any other form of interpretation.</p>
"
"Disable beep of Linux Bash on Windows 10","36724209","<bash><windows-10><windows-subsystem-for-linux>","448","<ol>
<li><p>To disable the beep in <strong>bash</strong> you need to uncomment (or add if not already there) the line <code>set bell-style none</code> in your <code>/etc/inputrc</code> file.</p>

<p><em>Note:</em> Since it is a protected file you need to be a privileged user to edit it (i.e. launch your text editor with something like <code>sudo &lt;editor&gt; /etc/inputrc</code>).</p></li>
<li><p>To disable the beep also in <strong>vim</strong> you need to add <code>set visualbell</code> in your <code>~/.vimrc</code> file.</p></li>
<li><p>To disable the beep also in <strong>less</strong> (i.e. also in man pages and when using ""git diff"") you need to add <code>export LESS=""$LESS -R -Q""</code> in your <code>~/.profile</code> file.</p></li>
</ol>
"
"Git Bash is extremely slow on Windows 7 x64","4485059","<git><bash><windows-7><msysgit><mingw32>","446","<p>It appears that completely uninstalling Git, restarting (the classic Windows cure), and reinstalling Git was the cure.  I also wiped out all bash config files which were left over (they were manually created).  Everything is fast again.</p>

<p>If for some reason reinstalling isn't possible (or desirable), then I would definitely try changing the PS1 variable referenced in <a href=""https://stackoverflow.com/a/4485396/542251"">Chris Dolan's answer</a>; it resulted in significant speedups in certain operations.</p>
"
"How to add a progress bar to a shell script?","238073","<bash><shell><zsh>","441","<p>You can implement this by overwriting a line.  Use <code>\r</code> to go back to the beginning of the line without writing <code>\n</code> to the terminal.</p>

<p>Write <code>\n</code> when you're done to advance the line.</p>

<p>Use <code>echo -ne</code> to:</p>

<ol>
<li>not print <code>\n</code> and</li>
<li>to recognize escape sequences like <code>\r</code>.</li>
</ol>

<p>Here's a demo:</p>

<pre><code>echo -ne '#####                     (33%)\r'
sleep 1
echo -ne '#############             (66%)\r'
sleep 1
echo -ne '#######################   (100%)\r'
echo -ne '\n'
</code></pre>

<p>In a comment below, puk mentions this ""fails"" if you start with a long line and then want to write a short line: In this case, you'll need to overwrite the length of the long line (e.g., with spaces).</p>
"
"Get file directory path from file path","6121091","<bash>","440","<p><code>dirname</code> and <code>basename</code> are the tools you're looking for for extracting path components:</p>
<pre><code>$ export VAR='/home/pax/file.c'
$ echo &quot;$(dirname &quot;${VAR}&quot;)&quot; ; echo &quot;$(basename &quot;${VAR}&quot;)&quot;
/home/pax
file.c
</code></pre>
<p>They're not internal Bash commands but they're part of the POSIX standard -  see <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html"" rel=""noreferrer""><code>dirname</code></a> and <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html"" rel=""noreferrer""><code>basename</code></a>. Hence, they're probably available on, or can be obtained for, most platforms that are capable of running <code>bash</code>.</p>
"
"Pipe output and capture exit status in Bash","1221833","<bash><shell><error-handling><pipe>","438","<p>There is an internal Bash variable called <code>$PIPESTATUS</code>; it’s an array that holds the exit status of each command in your last foreground pipeline of commands.</p>

<pre><code>&lt;command&gt; | tee out.txt ; test ${PIPESTATUS[0]} -eq 0
</code></pre>

<p>Or another alternative which also works with other shells (like zsh) would be to enable pipefail:</p>

<pre><code>set -o pipefail
...
</code></pre>

<p>The first option does <em>not</em> work with <code>zsh</code> due to a little bit different syntax.</p>
"
"Using getopts to process long and short command line options","402377","<bash><command-line-arguments><getopt><getopts>","429","<p>There are three implementations that may be considered:</p>

<ul>
<li><p>Bash builtin <code>getopts</code>. This does not support long option names with the double-dash prefix.  It only supports single-character options.</p></li>
<li><p>BSD UNIX implementation of standalone <code>getopt</code> command (which is what MacOS uses). This does not support long options either.</p></li>
<li><p>GNU implementation of standalone <code>getopt</code>.  GNU <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/getopt.3.html"" rel=""noreferrer""><code>getopt(3)</code></a> (used by the command-line <a href=""https://linux.die.net/man/1/getopt"" rel=""noreferrer""><code>getopt(1)</code></a> on Linux) supports parsing long options.  </p></li>
</ul>

<hr>

<p>Some other answers show a solution for using the bash builtin <code>getopts</code> to mimic long options. That solution actually makes a short option whose character is ""-"". So you get ""--"" as the flag. Then anything following that becomes OPTARG, and you test the OPTARG with a nested <code>case</code>.</p>

<p>This is clever, but it comes with caveats: </p>

<ul>
<li><code>getopts</code> can't enforce the opt spec. It can't return errors if the user supplies an invalid option. You have to do your own error-checking as you parse OPTARG.</li>
<li>OPTARG is used for the long option name, which complicates usage when your long option itself has an argument. You end up having to code that yourself as an additional case.</li>
</ul>

<p>So while it is possible to write more code to work around the lack of support for long options, this is a lot more work and partially defeats the purpose of using a getopt parser to simplify your code.</p>
"
"iTerm 2: How to set keyboard shortcuts to jump to beginning/end of line?","6205157","<macos><bash><iterm><iterm2>","428","<p><strong>Add in iTerm2 the following Profile Shortcut Keys</strong></p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th style=""text-align: center;"">FOR</th>
<th style=""text-align: center;"">ACTION</th>
<th style=""text-align: center;"">SEND</th>
</tr>
</thead>
<tbody>
<tr>
<td style=""text-align: center;"">⌘ ←</td>
<td style=""text-align: center;"">&quot;SEND HEX CODE&quot;</td>
<td style=""text-align: center;"">0x01</td>
</tr>
<tr>
<td style=""text-align: center;"">⌘ →</td>
<td style=""text-align: center;"">&quot;SEND HEX CODE&quot;</td>
<td style=""text-align: center;"">0x05</td>
</tr>
<tr>
<td style=""text-align: center;"">⌥ ←</td>
<td style=""text-align: center;"">&quot;SEND ESC SEQ&quot;</td>
<td style=""text-align: center;"">b</td>
</tr>
<tr>
<td style=""text-align: center;"">⌥ →</td>
<td style=""text-align: center;"">&quot;SEND ESC SEQ&quot;</td>
<td style=""text-align: center;"">f</td>
</tr>
</tbody>
</table>
</div>
<p>Here is a visual for those who need it</p>
<p><img src=""https://i.imgur.com/djgBBQ3.png"" alt=""iTerm add key visual"" /></p>
"
"Running multiple commands in one line in shell","5130847","<bash><shell>","424","<p>You are using <code>|</code> (pipe) to direct the output of a command into another command. What you are looking for is <code>&amp;&amp;</code> operator to execute the next command only if the previous one succeeded:</p>

<pre><code>cp /templates/apple /templates/used &amp;&amp; cp /templates/apple /templates/inuse &amp;&amp; rm /templates/apple
</code></pre>

<p>Or </p>

<pre><code>cp /templates/apple /templates/used &amp;&amp; mv /templates/apple /templates/inuse
</code></pre>

<hr>

<p>To summarize (non-exhaustively) bash's command operators/separators:</p>

<ul>
<li><code>|</code> pipes (pipelines) the standard output (<code>stdout</code>) of one command into the standard input of another one. Note that <code>stderr</code> still goes into its default destination, whatever that happen to be.</li>
<li><code>|&amp;</code>pipes both <code>stdout</code> and <code>stderr</code> of one command into the standard input of another one. Very useful, available in bash version 4 and above.</li>
<li><code>&amp;&amp;</code> executes the right-hand command of <code>&amp;&amp;</code> only if the previous one succeeded.</li>
<li><code>||</code> executes the right-hand command of <code>||</code> only it the previous one failed.</li>
<li><code>;</code> executes the right-hand command of <code>;</code> always regardless whether the previous command succeeded or failed. Unless <code>set -e</code> was previously invoked, which causes <code>bash</code> to fail on an error.</li>
</ul>
"
"How to create a cron job using Bash automatically without the interactive editor?","878600","<bash><shell><cron>","424","<p>You can add to the crontab as follows:</p>

<pre><code>#write out current crontab
crontab -l &gt; mycron
#echo new cron into cron file
echo ""00 09 * * 1-5 echo hello"" &gt;&gt; mycron
#install new cron file
crontab mycron
rm mycron
</code></pre>

<hr>

<h2>Cron line explaination</h2>

<pre><code>* * * * * ""command to be executed""
- - - - -
| | | | |
| | | | ----- Day of week (0 - 7) (Sunday=0 or 7)
| | | ------- Month (1 - 12)
| | --------- Day of month (1 - 31)
| ----------- Hour (0 - 23)
------------- Minute (0 - 59)
</code></pre>

<p>Source <a href=""http://www.cyberciti.biz/faq/how-do-i-add-jobs-to-cron-under-linux-or-unix-oses/"" rel=""noreferrer"">nixCraft</a>.</p>
"
"Linux how to copy but not overwrite?","9392735","<linux><bash><cp>","422","<p>Taken from the <a href=""http://manpages.ubuntu.com/manpages/precise/en/man1/cp.1.html"" rel=""noreferrer"">man page</a>:</p>

<pre><code>-n, --no-clobber
              do not overwrite an existing file (overrides a previous -i option)
</code></pre>

<p>Example:</p>

<pre><code>cp -n myoldfile.txt mycopiedfile.txt
</code></pre>
"
"How to execute mongo commands through shell scripts?","4837673","<mongodb><bash><shell><sh>","416","<p>You can also evaluate a command using the <code>--eval</code> flag, if it is just a single command.</p>

<pre><code>mongo --eval ""printjson(db.serverStatus())""
</code></pre>

<p><strong>Please note:</strong> if you are using Mongo operators, starting with a $ sign, you'll want to surround the eval argument in single quotes to keep the shell from evaluating the operator as an environment variable:</p>

<pre><code>mongo --eval 'db.mycollection.update({""name"":""foo""},{$set:{""this"":""that""}});' myDbName
</code></pre>

<p>Otherwise you may see something like this:</p>

<pre><code>mongo --eval ""db.test.update({\""name\"":\""foo\""},{$set:{\""this\"":\""that\""}});""
&gt; E QUERY    SyntaxError: Unexpected token :
</code></pre>
"
"What is the difference between ""#!/usr/bin/env bash"" and ""#!/usr/bin/bash""?","16365130","<linux><bash><shell><unix><shebang>","416","<p>Running a command through <code>/usr/bin/env</code> has the benefit of looking for whatever the default version of the program is in your current <strong>env</strong>ironment.</p>

<p>This way, you don't have to look for it in a specific place on the system, as those paths may be in different locations on different systems.  As long as it's in your path, it will find it.</p>

<p>One downside is that you will be unable to pass more than one argument (e.g. you will be unable to write <code>/usr/bin/env awk -f</code>) if you wish to support Linux, as <a href=""https://unix.stackexchange.com/a/399702/6252"">POSIX is vague</a> on how the line is to be interpreted, and Linux interprets everything after the first space to denote a single argument. You can use <code>/usr/bin/env -S</code> on some versions of <code>env</code> to get around this, but then the script will become even less portable and break on fairly recent systems (e.g. even Ubuntu 16.04 if not later).</p>

<p>Another downside is that since you aren't calling an explicit executable, it's got the potential for mistakes, and on multiuser systems security problems (if someone managed to get their executable called <code>bash</code> in your path, for example).</p>

<pre><code>#!/usr/bin/env bash #lends you some flexibility on different systems
#!/usr/bin/bash     #gives you explicit control on a given system of what executable is called
</code></pre>

<p>In some situations, the first may be preferred (like running python scripts with multiple versions of python, without having to rework the executable line).  But in situations where security is the focus, the latter would be preferred, as it limits code injection possibilities.</p>
"
"Get program execution time in the shell","385408","<linux><bash><shell>","415","<p>Use the built-in <code>time</code> keyword:</p>

<pre>
$ help time

time: time [-p] PIPELINE
    Execute PIPELINE and print a summary of the real time, user CPU time,
    and system CPU time spent executing PIPELINE when it terminates.
    The return status is the return status of PIPELINE.  The `-p' option
    prints the timing summary in a slightly different format.  This uses
    the value of the TIMEFORMAT variable as the output format.
</pre>

<p>Example:</p>

<pre><code>$ time sleep 2
</code></pre>

<pre>
real    0m2.009s
user    0m0.000s
sys     0m0.004s
</pre>
"
"Create timestamp variable in bash script","17066250","<bash><variables><timestamp>","412","<p>In order to get the current timestamp and not the time of when a fixed variable is defined, the trick is to use a function and <strong>not</strong> a variable:</p>
<pre><code>#!/bin/bash

# Define a timestamp function
timestamp() {
  date +&quot;%T&quot; # current time
}

# do something...
timestamp # print timestamp
# do something else...
timestamp # print another timestamp
# continue...
</code></pre>
<p>If you don't like the format given by the <code>%T</code> specifier you can combine the other time conversion specifiers accepted by <code>date</code>.  For GNU <code>date</code>, you can find the complete list of these specifiers in the official documentation here: <a href=""https://www.gnu.org/software/coreutils/manual/html_node/Time-conversion-specifiers.html#Time-conversion-specifiers"" rel=""noreferrer"">https://www.gnu.org/software/coreutils/manual/html_node/Time-conversion-specifiers.html#Time-conversion-specifiers</a></p>
"
"How do I remove the file suffix and path portion from a path string in Bash?","125281","<string><bash><filenames>","412","<p>Here's how to do it with the # and % operators in Bash.</p>

<pre><code>$ x=""/foo/fizzbuzz.bar""
$ y=${x%.bar}
$ echo ${y##*/}
fizzbuzz
</code></pre>

<p><code>${x%.bar}</code> could also be <code>${x%.*}</code> to remove everything after a dot or <code>${x%%.*}</code> to remove everything after the first dot.</p>

<p>Example:</p>

<pre><code>$ x=""/foo/fizzbuzz.bar.quux""
$ y=${x%.*}
$ echo $y
/foo/fizzbuzz.bar
$ y=${x%%.*}
$ echo $y
/foo/fizzbuzz
</code></pre>

<p>Documentation can be found in the <a href=""https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html#Shell-Parameter-Expansion"" rel=""noreferrer"">Bash manual</a>. Look for <code>${parameter%word}</code> and <code>${parameter%%word}</code> trailing portion matching section.</p>
"
"./configure : /bin/sh^M : bad interpreter","2920416","<linux><bash><shell><newline>","409","<p>To fix, open your script with vi or vim and enter in vi command mode (key <KBD>Esc</KBD>), then type this:</p>

<pre><code>:set fileformat=unix
</code></pre>

<p>Finally save it</p>

<p><code>:x!</code> or <code>:wq!</code></p>
"
"Bash command to sum a column of numbers","3096259","<bash>","406","<h1>Using existing file:</h1>

<pre><code>paste -sd+ infile | bc
</code></pre>

<h1>Using stdin:</h1>

<pre><code>&lt;cmd&gt; | paste -sd+ | bc
</code></pre>

<p>Edit:
With some <em>paste</em> implementations you need to be more explicit when reading from <em>stdin</em>:</p>

<p><code>&lt;cmd&gt; | paste -sd+ - | bc</code></p>
"
"How to assign a heredoc value to a variable in Bash?","1167746","<bash><heredoc>","401","<p>You can avoid a useless use of <code>cat</code> and handle mismatched quotes better with this:</p>

<pre><code>$ read -r -d '' VAR &lt;&lt;'EOF'
abc'asdf""
$(dont-execute-this)
foo""bar""''
EOF
</code></pre>

<p>If you don't quote the variable when you echo it, newlines are lost. Quoting it preserves them:</p>

<pre><code>$ echo ""$VAR""
abc'asdf""
$(dont-execute-this)
foo""bar""''
</code></pre>

<p>If you want to use indentation for readability in the source code, use a dash after the less-thans. The indentation must be done using only tabs (no spaces).</p>

<pre><code>$ read -r -d '' VAR &lt;&lt;-'EOF'
    abc'asdf""
    $(dont-execute-this)
    foo""bar""''
    EOF
$ echo ""$VAR""
abc'asdf""
$(dont-execute-this)
foo""bar""''
</code></pre>

<p>If, instead, you want to preserve the tabs in the contents of the resulting variable, you need to remove tab from <code>IFS</code>. The terminal marker for the here doc (<code>EOF</code>) must not be indented.</p>

<pre><code>$ IFS='' read -r -d '' VAR &lt;&lt;'EOF'
    abc'asdf""
    $(dont-execute-this)
    foo""bar""''
EOF
$ echo ""$VAR""
    abc'asdf""
    $(dont-execute-this)
    foo""bar""''
</code></pre>

<p>Tabs can be inserted at the command line by pressing <kbd>Ctrl</kbd>-<kbd>V</kbd> <kbd>Tab</kbd>. If you are using an editor, depending on which one, that may also work or you may have to turn off the feature that automatically converts tabs to spaces.</p>
"
".bashrc at ssh login","820517","<ubuntu><ssh><bash>","400","<p><code>.bashrc</code> is not sourced when you log in using SSH. You need to source it in your <code>.bash_profile</code> like this:</p>

<pre><code>if [ -f ~/.bashrc ]; then
  . ~/.bashrc
fi
</code></pre>
"
"Capturing Groups From a Grep RegEx","1891797","<bash><shell><grep>","400","<p>If you're using Bash, you don't even have to use <code>grep</code>:</p>

<pre><code>files=""*.jpg""
regex=""[0-9]+_([a-z]+)_[0-9a-z]*""
for f in $files    # unquoted in order to allow the glob to expand
do
    if [[ $f =~ $regex ]]
    then
        name=""${BASH_REMATCH[1]}""
        echo ""${name}.jpg""    # concatenate strings
        name=""${name}.jpg""    # same thing stored in a variable
    else
        echo ""$f doesn't match"" &gt;&amp;2 # this could get noisy if there are a lot of non-matching files
    fi
done
</code></pre>

<p>It's better to put the regex in a variable. Some patterns won't work if included literally.</p>

<p>This uses  <code>=~</code> which is Bash's regex match operator. The results of the match are saved to an array called <code>$BASH_REMATCH</code>. The first capture group is stored in index 1, the second (if any) in index 2, etc. Index zero is the full match.</p>

<p>You should be aware that without anchors, this regex (and the one using <code>grep</code>) will match any of the following examples and more, which may not be what you're looking for:</p>

<pre><code>123_abc_d4e5
xyz123_abc_d4e5
123_abc_d4e5.xyz
xyz123_abc_d4e5.xyz
</code></pre>

<p>To eliminate the second and fourth examples, make your regex like this:</p>

<pre><code>^[0-9]+_([a-z]+)_[0-9a-z]*
</code></pre>

<p>which says the string must <em>start</em> with one or more digits. The carat represents the beginning of the string. If you add a dollar sign at the end of the regex, like this:</p>

<pre><code>^[0-9]+_([a-z]+)_[0-9a-z]*$
</code></pre>

<p>then the third example will also be eliminated since the dot is not among the characters in the regex and the dollar sign represents the end of the string. Note that the fourth example fails this match as well.</p>

<p>If you have GNU <code>grep</code> (around 2.5 or later, I think, when the <code>\K</code> operator was added):</p>

<pre><code>name=$(echo ""$f"" | grep -Po '(?i)[0-9]+_\K[a-z]+(?=_[0-9a-z]*)').jpg
</code></pre>

<p>The <code>\K</code> operator (variable-length look-behind) causes the preceding pattern to match, but doesn't include the match in the result. The fixed-length equivalent is <code>(?&lt;=)</code> - the pattern would be included before the closing parenthesis. You must use <code>\K</code> if quantifiers may match strings of different lengths (e.g. <code>+</code>, <code>*</code>, <code>{2,4}</code>).</p>

<p>The <code>(?=)</code> operator matches fixed or variable-length patterns and is called ""look-ahead"". It also does not include the matched string in the result.</p>

<p>In order to make the match case-insensitive, the <code>(?i)</code> operator is used. It affects the patterns that follow it so its position is significant.</p>

<p>The regex might need to be adjusted depending on whether there are other characters in the filename. You'll note that in this case, I show an example of concatenating a string at the same time that the substring is captured.</p>
"
"How can I format my grep output to show line numbers at the end of the line, and also the hit count?","3968103","<linux><bash><unix><grep>","397","<p><code>-n</code> returns line number.</p>

<p><code>-i</code> is for ignore-case. Only to be used if case matching is not necessary</p>

<pre><code>$ grep -in null myfile.txt

2:example two null,
4:example four null,
</code></pre>

<p>Combine with <code>awk</code> to print out the line number after the match:</p>

<pre><code>$ grep -in null myfile.txt | awk -F: '{print $2"" - Line number : ""$1}'

example two null, - Line number : 2
example four null, - Line number : 4
</code></pre>

<p>Use command substitution to print out the total null count:</p>

<pre><code>$ echo ""Total null count :"" $(grep -ic null myfile.txt)

Total null count : 2
</code></pre>
"
"Linux: copy and create destination dir if it does not exist","1529946","<linux><bash><shell><unix><cp>","397","<pre><code>mkdir -p ""$d"" &amp;&amp; cp file ""$d""
</code></pre>

<p>(there's no such option for <code>cp</code>).</p>
"
"Is there a TRY CATCH command in Bash","22009364","<bash><shell><error-handling>","392","<blockquote>
  <p>Is there a TRY CATCH command in Bash?</p>
</blockquote>

<p>No.  </p>

<p>Bash doesn't have as many luxuries as one can find in many programming languages.</p>

<p>There is no <code>try/catch</code> in bash; however, one can achieve similar behavior using <code>&amp;&amp;</code> or <code>||</code>.</p>

<p>Using <code>||</code>:</p>

<p>if <code>command1</code> fails then <code>command2</code> runs as follows</p>

<pre><code>command1 || command2
</code></pre>

<p>Similarly, using <code>&amp;&amp;</code>, <code>command2</code> will run if <code>command1</code> is successful</p>

<p>The closest approximation of <code>try/catch</code> is as follows</p>

<pre><code>{ # try

    command1 &amp;&amp;
    #save your output

} || { # catch
    # save log for exception 
}
</code></pre>

<p>Also bash contains some error handling mechanisms, as well </p>

<pre><code>set -e
</code></pre>

<p>it stops your script if any simple command fails. </p>

<p>And also why not <code>if...else</code>. It is your best friend.</p>
"
"How do I specify a password to 'psql' non-interactively?","6405127","<bash><postgresql><command-line>","391","<p>From the <a href=""http://www.postgresql.org/docs/8.3/static/app-psql.html"" rel=""noreferrer"">official documentation</a>:</p>

<blockquote>
  <p>It is also convenient to have a ~/.pgpass file to avoid regularly having to type in passwords. See <a href=""http://www.postgresql.org/docs/8.3/static/libpq-pgpass.html"" rel=""noreferrer"">Section 30.13</a> for more information.</p>
</blockquote>

<p>...</p>

<blockquote>
  <p>This file should contain lines of the following format:</p>
</blockquote>

<pre><code>hostname:port:database:username:password
</code></pre>

<blockquote>
  <p>The password field from the first line that matches the current connection parameters will be used. </p>
</blockquote>
"
"What's the difference between [ and [[ in Bash?","3427872","<bash>","387","<p><code>[[</code> is bash's improvement to the <code>[</code> command. It has several enhancements that make it a better choice if you write scripts that target bash. My favorites are:</p>

<ol>
<li><p>It is a syntactical feature of the shell, so it has some special behavior that <code>[</code> doesn't have. You no longer have to quote variables like mad because <code>[[</code> handles empty strings and strings with whitespace more intuitively. For example, with <code>[</code> you have to write</p>

<pre><code>if [ -f ""$file"" ]
</code></pre>

<p>to correctly handle empty strings or file names with spaces in them. With <code>[[</code> the quotes are unnecessary:</p>

<pre><code>if [[ -f $file ]]
</code></pre></li>
<li><p>Because it is a syntactical feature, it lets you use <code>&amp;&amp;</code> and <code>||</code> operators for boolean tests and <code>&lt;</code> and <code>&gt;</code> for string comparisons. <code>[</code> cannot do this because it is a regular command and  <code>&amp;&amp;</code>, <code>||</code>, <code>&lt;</code>, and <code>&gt;</code> are not passed to regular commands as command-line arguments.</p></li>
<li><p>It has a wonderful <code>=~</code> operator for doing regular expression matches. With <code>[</code> you might write</p>

<pre><code>if [ ""$answer"" = y -o ""$answer"" = yes ]
</code></pre>

<p>With <code>[[</code> you can write this as</p>

<pre><code>if [[ $answer =~ ^y(es)?$ ]]
</code></pre>

<p>It even lets you access the captured groups which it stores in <code>BASH_REMATCH</code>. For instance, <code>${BASH_REMATCH[1]}</code> would be ""es"" if you typed a full ""yes"" above.</p></li>
<li><p>You get pattern matching aka globbing for free. Maybe you're less strict about how to type yes. Maybe you're okay if the user types y-anything. Got you covered:</p>

<pre><code>if [[ $ANSWER = y* ]]
</code></pre></li>
</ol>

<p>Keep in mind that it is a bash extension, so if you are writing sh-compatible scripts then you need to stick with <code>[</code>. Make sure you have the <code>#!/bin/bash</code> shebang line for your script if you use double brackets.</p>

<h3>See also</h3>

<ul>
<li><a href=""http://mywiki.wooledge.org/BashFAQ/031"" rel=""noreferrer"">Bash FAQ - ""What is the difference between test, [ and [[ ?""</a></li>
<li><a href=""http://mywiki.wooledge.org/BashGuide/Practices#Bash_Tests"" rel=""noreferrer"">Bash Practices - Bash Tests</a></li>
<li><a href=""https://serverfault.com/questions/52034/what-is-the-difference-between-double-and-single-square-brackets-in-bash"">Server Fault - What is the difference between double and single brackets in bash?</a></li>
</ul>
"
"Exit Shell Script Based on Process Exit Code","90418","<bash><shell>","382","<p>After each command, the exit code can be found in the <code>$?</code> variable so you would have something like:</p>

<pre><code>ls -al file.ext
rc=$?; if [[ $rc != 0 ]]; then exit $rc; fi
</code></pre>

<p>You need to be careful of piped commands since the <code>$?</code> only gives you the return code of the last element in the pipe so, in the code:</p>

<pre><code>ls -al file.ext | sed 's/^/xx: /""
</code></pre>

<p>will not return an error code if the file doesn't exist (since the <code>sed</code> part of the pipeline actually works, returning 0).</p>

<p>The <code>bash</code> shell actually provides an array which can assist in that case, that being <code>PIPESTATUS</code>. This array has one element for each of the pipeline components, that you can access individually like <code>${PIPESTATUS[0]}</code>:</p>

<pre><code>pax&gt; false | true ; echo ${PIPESTATUS[0]}
1
</code></pre>

<p>Note that this is getting you the result of the <code>false</code> command, not the entire pipeline. You can also get the entire list to process as you see fit:</p>

<pre><code>pax&gt; false | true | false; echo ${PIPESTATUS[*]}
1 0 1
</code></pre>

<p>If you wanted to get the largest error code from a pipeline, you could use something like:</p>

<pre><code>true | true | false | true | false
rcs=${PIPESTATUS[*]}; rc=0; for i in ${rcs}; do rc=$(($i &gt; $rc ? $i : $rc)); done
echo $rc
</code></pre>

<p>This goes through each of the <code>PIPESTATUS</code> elements in turn, storing it in <code>rc</code> if it was greater than the previous <code>rc</code> value.</p>
"
"Unlimited Bash History","9457233","<bash><unix>","377","<p>Set <code>HISTSIZE</code> and <code>HISTFILESIZE</code> in .bashrc to an empty string:</p>

<pre><code>HISTSIZE= 
HISTFILESIZE=
</code></pre>

<p>In <a href=""http://tiswww.case.edu/php/chet/bash/CHANGES"" rel=""noreferrer"">bash 4.3 and later</a> you can also use <code>HISTSIZE=-1 HISTFILESIZE=-1</code>:</p>

<pre class=""lang-none prettyprint-override""><code>n.  Setting HISTSIZE to a value less than zero causes the history list to be
    unlimited (setting it 0 zero disables the history list).

o.  Setting HISTFILESIZE to a value less than zero causes the history file size
    to be unlimited (setting it to 0 causes the history file to be truncated
    to zero size).
</code></pre>
"
"if, elif, else statement issues in Bash","16034749","<bash><if-statement>","376","<p>There is a space missing between <code>elif</code> and <code>[</code>:</p>

<pre><code>elif[ ""$seconds"" -gt 0 ]
</code></pre>

<p>should be</p>

<pre><code>elif [ ""$seconds"" -gt 0 ]
</code></pre>

<hr>

<p>As I see this question is getting a lot of views, it is important to indicate that the syntax to follow is:</p>

<pre class=""lang-bash prettyprint-override""><code>if [ conditions ]
# ^ ^          ^
</code></pre>

<p>meaning that <strong>spaces are needed around the brackets</strong>. Otherwise, it won't work. This is because <code>[</code> itself <em>is</em> a command.</p>

<p>The reason why you are not seeing something like <code>elif[: command not found</code> (or similar) is that after seeing <code>if</code> and <code>then</code>, the shell is looking for either <code>elif</code>, <code>else</code>, or <code>fi</code>.  However it finds another <code>then</code> (after the mis-formatted <code>elif[</code>).  Only <em>after</em> having parsed the statement it would be executed (and an error message like <code>elif[: command not found</code> would be output).</p>
"
"Setting an environment variable before a command in Bash is not working for the second command in a pipe","10856129","<bash><environment-variables>","372","<pre><code>FOO=bar bash -c 'somecommand someargs | somecommand2'
</code></pre>
"
"How can I kill a process by name instead of PID?","160924","<linux><bash><shell><kill>","371","<pre><code>pkill firefox
</code></pre>

<p>More information: <a href=""http://linux.about.com/library/cmd/blcmdl1_pkill.htm"" rel=""noreferrer"">http://linux.about.com/library/cmd/blcmdl1_pkill.htm</a></p>
"
"How best to include other scripts?","192292","<bash>","369","<p>I tend to make my scripts all be relative to one another. 
That way I can use dirname:</p>

<pre><code>#!/bin/sh

my_dir=""$(dirname ""$0"")""

""$my_dir/other_script.sh""
</code></pre>
"
"How to iterate over associative arrays in Bash","3112687","<bash><associative-array><key-value><bash4>","369","<p>The keys are accessed using an exclamation point: <code>${!array[@]}</code>, the <strong><em>values</em></strong> are accessed using <code>${array[@]}</code>.</p>

<p>You can iterate over the key/value pairs like this:</p>

<pre><code>for i in ""${!array[@]}""
do
  echo ""key  : $i""
  echo ""value: ${array[$i]}""
done
</code></pre>

<p>Note the use of quotes around the variable in the <code>for</code> statement (plus the use of <code>@</code> instead of <code>*</code>). This is necessary in case any keys include spaces.</p>

<p>The confusion in the other answer comes from the fact that your question includes ""foo"" and ""bar"" for both the keys <em>and</em> the values.</p>
"
"What is the cleanest way to ssh and run multiple commands in Bash?","4412238","<bash><unix><ssh>","368","<p>How about a Bash <a href=""http://www.tldp.org/LDP/abs/html/here-docs.html"" rel=""noreferrer"">Here Document</a>:</p>

<pre><code>ssh otherhost &lt;&lt; EOF
  ls some_folder; 
  ./someaction.sh 'some params'
  pwd
  ./some_other_action 'other params'
EOF
</code></pre>

<p>To avoid the problems mentioned by @Globalz in the comments, you may be able to (depending what you're doing on the remote site) get away with replacing the first line with</p>

<pre><code>ssh otherhost /bin/bash &lt;&lt; EOF
</code></pre>

<p>Note that you can do variable substitution in the Here document, but you may have to deal with quoting issues. For instance, if you quote the ""limit string"" (ie. <code>EOF</code> in the above), then you can't do variable substitutions. But without quoting the limit string, variables are substituted. For example, if you have defined <code>$NAME</code> above in your shell script, you could do</p>

<pre><code>ssh otherhost /bin/bash &lt;&lt; EOF
touch ""/tmp/${NAME}""
EOF
</code></pre>

<p>and it would create a file on the destination <code>otherhost</code> with the name of whatever you'd assigned to <code>$NAME</code>. Other rules about shell script quoting also apply, but are too complicated to go into here.</p>
"
"An example of how to use getopts in bash","16483119","<bash><shell><getopts>","367","<pre><code>#!/bin/bash

usage() { echo ""Usage: $0 [-s &lt;45|90&gt;] [-p &lt;string&gt;]"" 1&gt;&amp;2; exit 1; }

while getopts "":s:p:"" o; do
    case ""${o}"" in
        s)
            s=${OPTARG}
            ((s == 45 || s == 90)) || usage
            ;;
        p)
            p=${OPTARG}
            ;;
        *)
            usage
            ;;
    esac
done
shift $((OPTIND-1))

if [ -z ""${s}"" ] || [ -z ""${p}"" ]; then
    usage
fi

echo ""s = ${s}""
echo ""p = ${p}""
</code></pre>

<p>Example runs:</p>

<pre><code>$ ./myscript.sh
Usage: ./myscript.sh [-s &lt;45|90&gt;] [-p &lt;string&gt;]

$ ./myscript.sh -h
Usage: ./myscript.sh [-s &lt;45|90&gt;] [-p &lt;string&gt;]

$ ./myscript.sh -s """" -p """"
Usage: ./myscript.sh [-s &lt;45|90&gt;] [-p &lt;string&gt;]

$ ./myscript.sh -s 10 -p foo
Usage: ./myscript.sh [-s &lt;45|90&gt;] [-p &lt;string&gt;]

$ ./myscript.sh -s 45 -p foo
s = 45
p = foo

$ ./myscript.sh -s 90 -p bar
s = 90
p = bar
</code></pre>
"
"Pseudo-terminal will not be allocated because stdin is not a terminal","7114990","<linux><bash><shell><ssh>","366","<p>Try <code>ssh -t -t</code>(or <code>ssh -tt</code> for short) to force pseudo-tty allocation even if stdin isn't a terminal.</p>

<p>See also: <a href=""https://stackoverflow.com/questions/7085429/terminating-ssh-session-executed-by-bash-script"">Terminating SSH session executed by bash script</a></p>

<p>From ssh manpage:</p>

<pre><code>-T      Disable pseudo-tty allocation.

-t      Force pseudo-tty allocation.  This can be used to execute arbitrary 
        screen-based programs on a remote machine, which can be very useful,
        e.g. when implementing menu services.  Multiple -t options force tty
        allocation, even if ssh has no local tty.
</code></pre>
"
"How to put a line comment for a multi-line command","9522631","<bash><shell><comments>","366","<p>I'm afraid that, in general, you can't do what you're asking for. The best you can do is a comment on the lines before the command, or one single comment at the end of the command line, or a comment after the command.</p>

<p>You can't manage to intersperse comments inside a command this way. The <code>\</code>s express an intent to merge lines, so for all intents and purposes you're trying to intersperse comments in a single line, which doesn't work anyway because a <code>\</code> has to be at the end of the line to have that effect.</p>
"
"How to determine SSL cert expiration date from a PEM encoded certificate?","21297853","<linux><bash><ssl><openssl><certificate>","365","<p>With <code>openssl</code>:</p>

<pre><code>openssl x509 -enddate -noout -in file.pem
</code></pre>

<p>The output is on the form:</p>

<pre><code>notAfter=Nov  3 22:23:50 2014 GMT
</code></pre>

<p>Also see <a href=""https://stackoverflow.com/a/31718838/1899640"">MikeW's answer</a> for how to easily check whether the certificate has expired or not, or whether it will within a certain time period, without having to parse the date above.</p>
"
"Delete all local git branches","10610327","<git><bash><ubuntu><version-control><grep>","365","<p>The 'git branch -d' subcommand can delete more than one branch.  So, simplifying @sblom's answer but adding a critical xargs:</p>

<pre><code>git branch -D `git branch --merged | grep -v \* | xargs`
</code></pre>

<p>or, further simplified to:</p>

<pre><code>git branch --merged | grep -v \* | xargs git branch -D 
</code></pre>

<p>Importantly, as noted by @AndrewC, using <code>git branch</code> for scripting is discouraged.  To avoid it use something like:</p>

<pre><code>git for-each-ref --format '%(refname:short)' refs/heads | grep -v master | xargs git branch -D
</code></pre>

<p>Caution warranted on deletes!</p>

<pre><code>$ mkdir br
$ cd br; git init
Initialized empty Git repository in /Users/ebg/test/br/.git/
$ touch README; git add README; git commit -m 'First commit'
[master (root-commit) 1d738b5] First commit
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 README
$ git branch Story-123-a
$ git branch Story-123-b
$ git branch Story-123-c
$ git branch --merged
  Story-123-a
  Story-123-b
  Story-123-c
* master
$ git branch --merged | grep -v \* | xargs
Story-123-a Story-123-b Story-123-c
$ git branch --merged | grep -v \* | xargs git branch -D
Deleted branch Story-123-a (was 1d738b5).
Deleted branch Story-123-b (was 1d738b5).
Deleted branch Story-123-c (was 1d738b5).
</code></pre>
"
"How to limit depth for recursive file list?","4509624","<linux><bash>","364","<p>Checkout the <code>-maxdepth</code> flag of <code>find</code></p>

<pre><code>find . -maxdepth 1 -type d -exec ls -ld ""{}"" \;
</code></pre>

<p>Here I used 1 as max level depth, <code>-type d</code> means find only directories, which then <code>ls -ld</code> lists contents of, in long format.</p>
"
"Extract file basename without path and extension in bash","2664740","<linux><bash><unix><filenames>","362","<p>You don't have to call the external <code>basename</code> command. Instead, you could use the following commands:</p>

<pre><code>$ s=/the/path/foo.txt
$ echo ""${s##*/}""
foo.txt
$ s=${s##*/}
$ echo ""${s%.txt}""
foo
$ echo ""${s%.*}""
foo
</code></pre>

<p>Note that this solution should work in all recent (<em>post 2004</em>) <em>POSIX</em> compliant shells, (e.g. <code>bash</code>, <code>dash</code>, <code>ksh</code>, etc.).</p>

<p>Source: <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02"" rel=""noreferrer"">Shell Command Language 2.6.2 Parameter Expansion</a></p>

<p>More on bash String Manipulations:  <a href=""http://tldp.org/LDP/LG/issue18/bash.html"" rel=""noreferrer"">http://tldp.org/LDP/LG/issue18/bash.html</a></p>
"
"How can I get the current user's username in Bash?","19306771","<bash><username>","362","<p>On the command line, enter</p>

<pre><code>whoami
</code></pre>

<p>or</p>

<pre><code>echo ""$USER""
</code></pre>

<p>To save these values to a variable, do</p>

<pre><code>myvariable=$(whoami)
</code></pre>

<p>or</p>

<pre><code>myvariable=$USER
</code></pre>

<p>Of course, you don't need to make a variable since that is what the <code>$USER</code> variable is for.</p>
"
"How to test if string exists in file with Bash?","4749330","<string><bash><file>","361","<pre><code>grep -Fxq &quot;$FILENAME&quot; my_list.txt
</code></pre>
<p>The exit status is 0 (true) if the name was found, 1 (false) if not, so:</p>
<pre><code>if grep -Fxq &quot;$FILENAME&quot; my_list.txt
then
    # code if found
else
    # code if not found
fi
</code></pre>
<h3>Explanation</h3>
<p>Here are the relevant sections of <a href=""https://linux.die.net/man/1/grep"" rel=""noreferrer"">the man page for <code>grep</code></a>:</p>
<blockquote>
<pre><code>grep [options] PATTERN [FILE...]
</code></pre>
<p><code>-F</code>, <code>--fixed-strings</code></p>
<p>        Interpret PATTERN as a list of fixed strings, separated by  newlines, any of which is to be matched.</p>
<p><code>-x</code>, <code>--line-regexp</code></p>
<p>        Select only those matches that exactly match the whole line.</p>
<p><code>-q</code>, <code>--quiet</code>, <code>--silent</code></p>
<p>        Quiet; do not write anything to standard output. Exit immediately  with  zero status if any match is found, even if an error  was detected. Also see the <code>-s</code> or <code>--no-messages</code> option.</p>
</blockquote>
<h3>Error handling</h3>
<p>As rightfully pointed out in the comments, the above approach silently treats error cases as if the string was found. If you want to handle errors in a different way, you'll have to omit the <code>-q</code> option, and detect errors based on the exit status:</p>
<blockquote>
<p>Normally, the exit status is 0 if selected lines are found and 1 otherwise. But the exit status is 2 if an error occurred, unless the <code>-q</code> or <code>--quiet</code> or <code>--silent</code> option is used and a selected line is found. Note, however, that POSIX only mandates, for programs such as <code>grep</code>, <code>cmp</code>, and <code>diff</code>, that the exit status in case of error be greater than 1; it is therefore advisable, for the sake of portability, to use logic that tests for this general condition instead of strict equality with 2.</p>
</blockquote>
<p>To suppress the normal output from <code>grep</code>, you can redirect it to <code>/dev/null</code>. Note that standard error remains undirected, so any error messages that <code>grep</code> might print will end up on the console as you'd probably want.</p>
<p>To handle the three cases, we can use a <code>case</code> statement:</p>
<pre><code>case `grep -Fx &quot;$FILENAME&quot; &quot;$LIST&quot; &gt;/dev/null; echo $?` in
  0)
    # code if found
    ;;
  1)
    # code if not found
    ;;
  *)
    # code if an error occurred
    ;;
esac
</code></pre>
"
"What is the purpose of the : (colon) GNU Bash builtin?","3224878","<bash><shell><built-in>","359","<p><strong>Historically</strong>, Bourne shells didn't have <code>true</code> and <code>false</code> as built-in commands. <code>true</code> was instead simply aliased to <code>:</code>, and <code>false</code> to something like <code>let 0</code>.</p>

<p><code>:</code> is slightly better than <code>true</code> for portability to ancient Bourne-derived shells. As a simple example, consider having neither the <code>!</code> pipeline operator nor the <code>||</code> list operator (as was the case for some ancient Bourne shells). This leaves the <code>else</code> clause of the <code>if</code> statement as the only means for branching based on exit status:</p>

<pre><code>if command; then :; else ...; fi
</code></pre>

<p>Since <code>if</code> requires a non-empty <code>then</code> clause and comments don't count as non-empty, <code>:</code> serves as a no-op.</p>

<p><strong>Nowadays</strong> (that is: in a modern context) you can usually use either <code>:</code> or <code>true</code>. Both are specified by POSIX, and some find <code>true</code> easier to read. However there is one interesting difference: <code>:</code> is a so-called POSIX <em>special built-in</em>, whereas <code>true</code> is a <em>regular built-in</em>.</p>

<ul>
<li><p>Special built-ins are required to be built into the shell; Regular built-ins are only ""typically"" built in, but it isn't strictly guaranteed. There usually shouldn't be a regular program named <code>:</code> with the function of <code>true</code> in PATH of most systems.</p></li>
<li><p>Probably the most crucial difference is that with special built-ins, any variable set by the built-in - even in the environment during simple command evaluation - persists after the command completes, as demonstrated here using ksh93:</p>

<pre><code>$ unset x; ( x=hi :; echo ""$x"" )
hi
$ ( x=hi true; echo ""$x"" )

$
</code></pre>

<p>Note that Zsh ignores this requirement, as does GNU Bash except when operating in POSIX compatibility mode, but all other major ""POSIX sh derived"" shells observe this including dash, ksh93, and mksh.</p></li>
<li><p>Another difference is that regular built-ins must be compatible with <code>exec</code> - demonstrated here using Bash:</p>

<pre><code>$ ( exec : )
-bash: exec: :: not found
$ ( exec true )
$
</code></pre></li>
<li><p>POSIX also explicitly notes that <code>:</code> may be faster than <code>true</code>, though  this is of course an implementation-specific detail.</p></li>
</ul>
"
"How to check if running in Cygwin, Mac or Linux?","3466166","<bash><shell><cross-platform><cygwin>","358","<p>Usually, <code>uname</code> with its various options will tell you what environment you're running in:</p>

<pre><code>pax&gt; uname -a
CYGWIN_NT-5.1 IBM-L3F3936 1.5.25(0.156/4/2) 2008-06-12 19:34 i686 Cygwin

pax&gt; uname -s
CYGWIN_NT-5.1
</code></pre>

<p>And, according to the very helpful <code>schot</code> (in the comments), <code>uname -s</code> gives <code>Darwin</code> for OSX and <code>Linux</code> for Linux, while my Cygwin gives <code>CYGWIN_NT-5.1</code>. But you may have to experiment with all sorts of different versions.</p>

<p>So the <code>bash</code> code to do such a check would be along the lines of:</p>

<pre><code>unameOut=""$(uname -s)""
case ""${unameOut}"" in
    Linux*)     machine=Linux;;
    Darwin*)    machine=Mac;;
    CYGWIN*)    machine=Cygwin;;
    MINGW*)     machine=MinGw;;
    *)          machine=""UNKNOWN:${unameOut}""
esac
echo ${machine}
</code></pre>

<hr>

<p>Note that I'm assuming here that you're actually running <em>within</em> CygWin (the <code>bash</code> shell of it) so paths should already be correctly set up. As one commenter notes, you can run the <code>bash</code> program, passing the script, from <code>cmd</code> itself and this may result in the paths not being set up as needed.</p>

<p>If you <em>are</em> doing that, it's your responsibility to ensure the correct executables (i.e., the CygWin ones) are being called, possibly by modifying the path beforehand or fully specifying the executable locations (e.g., <code>/c/cygwin/bin/uname</code>).</p>
"
"Return value in a Bash function","17336915","<bash><function><return-value>","357","<p>Although bash has a <code>return</code> statement, the only thing you can specify with it is the function's own <code>exit</code> status (a value between <code>0</code> and <code>255</code>, 0 meaning &quot;success&quot;). So <code>return</code> is not what you want.</p>
<p>You might want to convert your <code>return</code> statement to an <code>echo</code> statement - that way your function output could be captured using <code>$()</code> braces, which seems to be exactly what you want.</p>
<p>Here is an example:</p>
<pre><code>function fun1(){
  echo 34
}

function fun2(){
  local res=$(fun1)
  echo $res
}
</code></pre>
<p>Another way to get the return value (if you just want to return an integer 0-255) is <code>$?</code>.</p>
<pre><code>function fun1(){
  return 34
}

function fun2(){
  fun1
  local res=$?
  echo $res
}
</code></pre>
<p>Also, note that you can use the return value to use boolean logic like <code>fun1 || fun2</code> will only run <code>fun2</code> if <code>fun1</code> returns a non-<code>0</code> value.  The default return value is the exit value of the last statement executed within the function.</p>
"
"Highlight Bash/shell code in Markdown files","20303826","<bash><shell><markdown><github-flavored-markdown>","356","<p>It depends on the Markdown rendering engine and the Markdown flavour. There is no standard for this. If you mean GitHub flavoured Markdown for example, <code>shell</code> should work fine. Aliases are <code>sh</code>, <code>bash</code> or <code>zsh</code>. You can find the list of available syntax lexers <a href=""https://github.com/github/linguist/blob/master/lib/linguist/languages.yml"" rel=""noreferrer"">here</a>.</p>
"
"How to get the primary IP address of the local machine on Linux and OS X?","13322485","<bash><unix><ip><ifconfig>","355","<p>Use <code>grep</code> to filter IP address from <code>ifconfig</code>: </p>

<p><code>ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1'</code></p>

<p>Or with <code>sed</code>:</p>

<p><code>ifconfig | sed -En 's/127.0.0.1//;s/.*inet (addr:)?(([0-9]*\.){3}[0-9]*).*/\2/p'</code></p>

<p>If you are only interested in certain interfaces, wlan0, eth0, etc. then:</p>

<p><code>ifconfig wlan0 | ...</code></p>

<p>You can alias the command in your <code>.bashrc</code> to <em>create</em> your own command called <code>myip</code> for instance.</p>

<p><code>alias myip=""ifconfig | sed -En 's/127.0.0.1//;s/.*inet (addr:)?(([0-9]*\.){3}[0-9]*).*/\2/p'""</code></p>

<p>A much simpler way is <code>hostname -I</code> (<code>hostname -i</code> for older versions of <code>hostname</code> but see comments). However, this is on Linux only. </p>
"
"How to urlencode data for curl command?","296536","<bash><shell><curl><scripting><urlencode>","355","<p>Use <code>curl --data-urlencode</code>; from <code>man curl</code>:</p>

<blockquote>
  <p>This posts data, similar to the other <code>--data</code> options with the exception that this performs URL-encoding. To be CGI-compliant, the <code>&lt;data&gt;</code> part should begin with a name followed by a separator and a content specification.</p>
</blockquote>

<p>Example usage:</p>

<pre><code>curl \
    --data-urlencode ""paramName=value"" \
    --data-urlencode ""secondParam=value"" \
    http://example.com
</code></pre>

<p>See <a href=""https://curl.haxx.se/docs/manpage.html#--data-urlencode"" rel=""noreferrer"">the man page</a> for more info.</p>

<p>This requires <a href=""https://curl.haxx.se/changes.html#7_18_0"" rel=""noreferrer"">curl 7.18.0 or newer (released January 2008)</a>. Use  <code>curl -V</code> to check which version you have.</p>

<p>You can as well encode the <a href=""https://curl.haxx.se/docs/manpage.html#-G"" rel=""noreferrer"">query string</a>:</p>

<pre><code>curl -G \
    --data-urlencode ""p1=value 1"" \
    --data-urlencode ""p2=value 2"" \
    http://example.com
    # http://example.com?p1=value%201&amp;p2=value%202
</code></pre>
"
"Accessing bash command line args $@ vs $*","12314451","<bash><command-line-arguments>","352","<p>The difference appears when the special parameters are quoted. Let me illustrate the differences:</p>

<pre><code>$ set -- ""arg  1"" ""arg  2"" ""arg  3""

$ for word in $*; do echo ""$word""; done
arg
1
arg
2
arg
3

$ for word in $@; do echo ""$word""; done
arg
1
arg
2
arg
3

$ for word in ""$*""; do echo ""$word""; done
arg  1 arg  2 arg  3

$ for word in ""$@""; do echo ""$word""; done
arg  1
arg  2
arg  3
</code></pre>

<hr>

<p>one further example on the importance of quoting: note there are 2 spaces between ""arg"" and the number, but if I fail to quote $word:</p>

<pre><code>$ for word in ""$@""; do echo $word; done
arg 1
arg 2
arg 3
</code></pre>

<p>and in bash, <code>""$@""</code> is the ""default"" list to iterate over:</p>

<pre><code>$ for word; do echo ""$word""; done
arg  1
arg  2
arg  3
</code></pre>
"
"How to make ""if not true condition""?","10552711","<bash><if-statement><syntax><boolean-expression>","349","<p>try</p>

<pre><code>if ! grep -q sysa /etc/passwd ; then
</code></pre>

<p><code>grep</code> returns <code>true</code> if it finds the search target, and <code>false</code> if it doesn't.</p>

<p>So NOT <code>false</code> == <code>true</code>.</p>

<p><code>if</code> evaluation in shells are designed to be very flexible, and many times doesn't require chains of commands (as you have written). </p>

<p>Also, looking at your code as is, your use of the <code>$( ... )</code> form of cmd-substitution is to be commended, but think about what is coming out of the process. Try <code>echo $(cat /etc/passwd | grep ""sysa"")</code> to see what I mean. You can take that further by using the <code>-c</code> (count) option to grep and then do <code>if ! [ $(grep -c ""sysa"" /etc/passwd) -eq 0 ] ; then</code> which works but is rather old school.</p>

<p>BUT, you could use the newest shell features (arithmetic evaluation) like</p>

<pre><code>if ! (( $(grep -c ""sysa"" /etc/passwd) == 0 )) ; then ...`
</code></pre>

<p>which also gives you the benefit of using the c-lang based comparison operators, <code>==,&lt;,&gt;,&gt;=,&lt;=,%</code> and maybe a few others.</p>

<p>In this case, per a comment by  Orwellophile, the arithmetic evaluation can be pared down even further, like</p>

<pre><code>if ! (( $(grep -c ""sysa"" /etc/passwd) )) ; then ....
</code></pre>

<p>OR</p>

<pre><code>if (( ! $(grep -c ""sysa"" /etc/passwd) )) ; then ....
</code></pre>

<p>Finally, there is an <em>award</em> called the <code>Useless Use of Cat (UUOC)</code>. :-) Some people will jump up and down and cry gothca! I'll just say that <code>grep</code> can take a file name on its cmd-line, so why invoke extra processes and pipe constructions when you don't have to? ;-) </p>

<p>I hope this helps.</p>
"
"How to find the last field using 'cut'","22727107","<linux><bash><cut>","348","<p>You could try something like this:</p>

<pre><code>echo 'maps.google.com' | rev | cut -d'.' -f 1 | rev
</code></pre>

<p><strong>Explanation</strong></p>

<ul>
<li><code>rev</code> reverses ""maps.google.com"" to be <code>moc.elgoog.spam</code></li>
<li><code>cut</code> uses dot (ie '.') as the delimiter, and chooses the first field, which is <code>moc</code></li>
<li>lastly, we reverse it again to get <code>com</code></li>
</ul>
"
"Stop on first error","3474526","<bash>","347","<p>Maybe you want <code>set -e</code>:</p>

<p><a href=""http://web.archive.org/web/20110314180918/http://www.davidpashley.com/articles/writing-robust-shell-scripts.html"" rel=""noreferrer"">www.davidpashley.com/articles/writing-robust-shell-scripts.html#id2382181</a>:</p>

<blockquote>
  <p>This tells bash that it should exit the script if any statement returns a non-true return value. The benefit of using -e is that it prevents errors snowballing into serious issues when they could have been caught earlier. Again, for readability you may want to use set -o errexit.</p>
</blockquote>
"
"Remove the last line from a file in Bash","4881930","<bash><command-line><scripting><truncate>","345","<p>Using <a href=""http://www.gnu.org/software/sed/"" rel=""noreferrer""><code>GNU sed</code></a>:</p>

<pre><code>sed -i '$ d' foo.txt
</code></pre>

<p>The <code>-i</code> option does not exist in <code>GNU sed</code> versions older than 3.95, so you have to use it as a filter with a temporary file:</p>

<pre><code>cp foo.txt foo.txt.tmp
sed '$ d' foo.txt.tmp &gt; foo.txt
rm -f foo.txt.tmp
</code></pre>

<p>Of course, in that case you could also use <code>head -n -1</code> instead of <code>sed</code>.</p>

<p><strong>MacOS:</strong></p>

<p>On Mac OS X (as of 10.7.4), the equivalent of the <code>sed -i</code> command above is</p>

<pre><code>sed -i '' -e '$ d' foo.txt
</code></pre>
"
"How do I prevent Conda from activating the base environment by default?","54429210","<bash><conda>","342","<p>I have conda 4.6 with a similar block of code that was added by conda. In my case, there's a conda configuration setting to disable the automatic base activation:</p>

<pre><code>conda config --set auto_activate_base false
</code></pre>

<p>The first time you run it, it'll create a <code>./condarc</code> in your home directory with that setting to override the default.</p>

<p>This wouldn't de-clutter your <code>.bash_profile</code> but it's a cleaner solution without manual editing that section that conda manages.</p>
"
"How can I use inverse or negative wildcards when pattern matching in a unix/linux shell?","216995","<bash><shell><pattern-matching><glob>","342","<p>In Bash you can do it by enabling the <code>extglob</code> option, like this (replace <code>ls</code> with <code>cp</code> and add the target directory, of course)</p>

<pre><code>~/foobar&gt; shopt extglob
extglob        off
~/foobar&gt; ls
abar  afoo  bbar  bfoo
~/foobar&gt; ls !(b*)
-bash: !: event not found
~/foobar&gt; shopt -s extglob  # Enables extglob
~/foobar&gt; ls !(b*)
abar  afoo
~/foobar&gt; ls !(a*)
bbar  bfoo
~/foobar&gt; ls !(*foo)
abar  bbar
</code></pre>

<p>You can later disable extglob with</p>

<pre><code>shopt -u extglob
</code></pre>
"
"Use space as a delimiter with cut command","816820","<bash><unix><cut>","337","<pre><code>cut -d ' ' -f 2
</code></pre>

<p>Where 2 is the field number of the space-delimited field you want.</p>
"
"What does -z mean in Bash?","18096670","<bash>","336","<p><code>-z string</code>   True if the string is null (an empty string)</p>
"
"Why are scripting languages (e.g. Perl, Python, Ruby) not suitable as shell languages?","3637668","<python><ruby><perl><bash><shell>","335","<p>There are a couple of differences that I can think of; just thoughtstreaming here, in no particular order:</p>

<ol>
<li><p>Python &amp; Co. are designed to be good at scripting. Bash &amp; Co. are designed to be <em>only</em> good at scripting, with absolutely no compromise. IOW: Python is designed to be good both at scripting and non-scripting, Bash cares only about scripting.</p></li>
<li><p>Bash &amp; Co. are untyped, Python &amp; Co. are strongly typed, which means that the number <code>123</code>, the string <code>123</code> and the file <code>123</code> are quite different. They are, however, not <em>statically</em> typed, which means they need to have different literals for those, in order to keep them apart.<br>
Example:</p>

<pre><code>                | Ruby             | Bash    
-----------------------------------------
number          | 123              | 123
string          | '123'            | 123
regexp          | /123/            | 123
file            | File.open('123') | 123
file descriptor | IO.open('123')   | 123
URI             | URI.parse('123') | 123
command         | `123`            | 123
</code></pre></li>
<li><p>Python &amp; Co. are designed to scale <em>up</em> to 10000, 100000, maybe even 1000000 line programs, Bash &amp; Co. are designed to scale <em>down</em> to 10 <em>character</em> programs.</p></li>
<li><p>In Bash &amp; Co., files, directories, file descriptors, processes are all first-class objects, in Python, only Python objects are first-class, if you want to manipulate files, directories etc., you have to wrap them in a Python object first.</p></li>
<li><p>Shell programming is basically dataflow programming. Nobody realizes that, not even the people who write shells, but it turns out that shells are quite good at that, and general-purpose languages not so much. In the general-purpose programming world, dataflow seems to be mostly viewed as a concurrency model, not so much as a programming paradigm.</p></li>
</ol>

<p>I have the feeling that trying to address these points by bolting features or DSLs onto a general-purpose programming language doesn't work. At least, I have yet to see a convincing implementation of it. There is <strong>RuSH</strong> (Ruby shell), which tries to implement a shell in Ruby, there is <a href=""http://rush.heroku.com/"" rel=""noreferrer""><strong>rush</strong></a>, which is an internal DSL for shell programming in Ruby, there is <a href=""http://code.google.com/p/hotwire-shell/"" rel=""noreferrer""><strong>Hotwire</strong></a>, which is a Python shell, but IMO none of those come even close to competing with Bash, Zsh, fish and friends.</p>

<p>Actually, IMHO, the best current shell is <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/dd835506%28v=vs.85%29.aspx"" rel=""noreferrer""><strong>Microsoft PowerShell</strong></a>, which is very surprising considering that for several <em>decades</em> now, Microsoft has continually had the <em>worst</em> shells <em>evar</em>. I mean, <code>COMMAND.COM</code>? Really? (Unfortunately, they still have a crappy terminal. It's still the ""command prompt"" that has been around since, what? Windows 3.0?)</p>

<p>PowerShell was basically created by ignoring everything Microsoft has ever done (<code>COMMAND.COM</code>, <code>CMD.EXE</code>, VBScript, JScript) and instead starting from the Unix shell, then removing all backwards-compatibility cruft (like backticks for command substitution) and massaging it a bit to make it more Windows-friendly (like using the now unused backtick as an escape character instead of the backslash which is the path component separator character in Windows). After that, is when the magic happens.</p>

<p>They address <strong>problem 1 and 3</strong> from above, by basically making the opposite choice compared to Python. Python cares about large programs first, scripting second. Bash cares only about scripting. PowerShell cares about scripting first, large programs second. A defining moment for me was watching a video of an interview with Jeffrey Snover (PowerShell's lead designer), when the interviewer asked him how big of a program one could write with PowerShell and Snover answered without missing a beat: ""80 characters."" At that moment I realized that this is <em>finally</em> a guy at Microsoft who ""gets"" shell programming (probably related to the fact that PowerShell was <em>neither</em> developed by Microsoft's programming language group (i.e. lambda-calculus math nerds) nor the OS group (kernel nerds) but rather the server group (i.e. sysadmins who actually <em>use</em> shells)), and that I should probably take a serious look at PowerShell.</p>

<p><strong>Number 2</strong> is solved by having arguments be statically typed. So, you can write just <code>123</code> and PowerShell knows whether it is a string or a number or a file, because the cmdlet (which is what shell commands are called in PowerShell) declares the types of its arguments to the shell. This has pretty deep ramifications: unlike Unix, where each command is responsible for parsing its own arguments (the shell basically passes the arguments as an array of strings), argument parsing in PowerShell is done by the <em>shell</em>. The cmdlets specify all their options and flags and arguments, as well as their types and names and documentation(!) to the shell, which then can perform argument parsing, tab completion, IntelliSense, inline documentation popups etc. in one centralized place. (This is not revolutionary, and the PowerShell designers acknowledge shells like the DIGITAL Command Language (DCL) and the IBM OS/400 Command Language (CL) as prior art. For anyone who has ever used an AS/400, this should sound familiar. In OS/400, you can write a shell command and if you don't know the syntax of certain arguments, you can simply leave them out and hit <kbd>F4</kbd>, which will bring a menu (similar to an HTML form) with labelled fields, dropdown, help texts etc. This is only possible because the OS knows about all the possible arguments and their types.) In the Unix shell, this information is often duplicated three times: in the argument parsing code in the command itself, in the <code>bash-completion</code> script for tab-completion and in the manpage.</p>

<p><strong>Number 4</strong> is solved by the fact that PowerShell operates on strongly typed objects, which includes stuff like files, processes, folders and so on.</p>

<p><strong>Number 5</strong> is particularly interesting, because PowerShell is the only shell I know of, where the people who wrote it were actually <em>aware</em> of the fact that shells are essentially dataflow engines and deliberately implemented it as a dataflow engine.</p>

<p>Another nice thing about PowerShell are the naming conventions: all cmdlets are named <code>Action-Object</code> and moreover, there are also standardized names for specific actions and specific objects. (Again, this should sound familar to OS/400 users.) For example, everything which is related to receiving some information is called <code>Get-Foo</code>. And everything operating on (sub-)objects is called <code>Bar-ChildItem</code>. So, the equivalent to <code>ls</code> is <code>Get-ChildItem</code> (although PowerShell also provides builtin aliases <code>ls</code> and <code>dir</code>&nbsp;&ndash; in fact, whenever it makes sense, they provide both Unix and <code>CMD.EXE</code> aliases as well as abbreviations (<code>gci</code> in this case)).</p>

<p>But the <strong>killer feature</strong> IMO is the strongly typed object pipelines. While PowerShell is derived from the Unix shell, there is one very important distinction: in Unix, all communication (both via pipes and redirections as well as via command arguments) is done with untyped, unstructured strings. In PowerShell, it's all strongly typed, structured objects. This is so incredibly powerful that I seriously wonder why noone else has thought of it. (Well, they have, but they never became popular.) In my shell scripts, I estimate that up to one third of the commands is only there to act as an adapter between two other commands that don't agree on a common textual format. Many of those adapters go away in PowerShell, because the cmdlets exchange structured objects instead of unstructured text. And if you look <em>inside</em> the commands, then they pretty much consist of three stages: parse the textual input into an internal object representation, manipulate the objects, convert them back into text. Again, the first and third stage basically go away, because the data already comes in as objects.</p>

<p>However, the designers have taken great care to preserve the dynamicity and flexibility of shell scripting through what they call an <em>Adaptive Type System</em>. </p>

<p>Anyway, I don't want to turn this into a PowerShell commercial. There are plenty of things that are <em>not</em> so great about PowerShell, although most of those have to do either with Windows or with the specific implementation, and not so much with the concepts. (E.g. the fact that it is implemented in .NET means that the very first time you start up the shell can take up to several seconds if the .NET framework is not already in the filesystem cache due to some other application that needs it. Considering that you often use the shell for well under a second, that is completely unacceptable.)</p>

<p>The most important point I want to make is that if you want to look at existing work in scripting languages and shells, <strong>you shouldn't stop at Unix and the Ruby/Python/Perl/PHP family</strong>. For example, <a href=""http://www.tcl.tk/"" rel=""noreferrer"">Tcl</a> was already mentioned. <a href=""http://en.wikipedia.org/wiki/REXX"" rel=""noreferrer"">Rexx</a> would be another scripting language. <a href=""http://www.gnu.org/software/emacs/emacs.html"" rel=""noreferrer"">Emacs Lisp</a> would be yet another. And in the shell realm there are some of the already mentioned mainframe/midrange shells such as the OS/400 command line and DCL. Also, Plan9's rc.</p>
"
"Check folder size in Bash","16661982","<bash><shell><directory>","335","<p>You can do:</p>

<pre><code>du -h your_directory
</code></pre>

<p>which will give you the size of your target directory.</p>

<p>If you want a brief output, <code>du -hcs your_directory</code> is nice.</p>
"
"Echo tab characters in bash script","525872","<bash><tabs><echo><spaces>","334","<pre><code>echo -e ' \t '
</code></pre>

<p>will echo 'space tab space newline' (<code>-e</code> means 'enable interpretation of backslash escapes'):</p>

<pre><code>$ echo -e ' \t ' | hexdump -C
00000000  20 09 20 0a                                       | . .|
</code></pre>
"
"Difference between wait and sleep","13296863","<bash><shell><wait><sleep>","332","<p><code>wait</code> waits for a process to finish; <code>sleep</code> sleeps for a certain amount of seconds.</p>
"
"How can I recall the argument of the previous bash command?","3371294","<linux><bash><unix><command>","331","<p>You can use <code>$_</code> or <code>!$</code> to recall the last argument of the previous command.</p>

<p>Also <code>Alt + .</code> can be used to recall the last argument of any of the previous commands.</p>
"
"How to represent multiple conditions in a shell if statement?","3826425","<bash><shell><unix>","331","<p>Classic technique (escape metacharacters):</p>

<pre><code>if [ \( ""$g"" -eq 1 -a ""$c"" = ""123"" \) -o \( ""$g"" -eq 2 -a ""$c"" = ""456"" \) ]
then echo abc
else echo efg
fi
</code></pre>

<p>I've enclosed the references to <code>$g</code> in double quotes; that's good practice, in general.  Strictly, the parentheses aren't needed because the precedence of <code>-a</code> and <code>-o</code> makes it correct even without them.</p>

<p>Note that the <code>-a</code> and <code>-o</code> operators are part of the POSIX specification for <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html"" rel=""noreferrer""><code>test</code></a>, aka <code>[</code>, mainly for backwards compatibility (since they were a part of <code>test</code> in 7th Edition UNIX, for example), but they are explicitly marked as 'obsolescent' by POSIX.  Bash (see <a href=""http://www.gnu.org/software/bash/manual/bash.html#Bash-Conditional-Expressions"" rel=""noreferrer"">conditional expressions</a>) seems to preempt the classic and POSIX meanings for <code>-a</code> and <code>-o</code> with its own alternative operators that take arguments.</p>

<hr>

<p>With some care, you can use the more modern <code>[[</code> operator, but be aware that the versions in Bash and Korn Shell (for example) need not be identical.</p>

<pre><code>for g in 1 2 3
do
    for c in 123 456 789
    do
        if [[ ( ""$g"" -eq 1 &amp;&amp; ""$c"" = ""123"" ) || ( ""$g"" -eq 2 &amp;&amp; ""$c"" = ""456"" ) ]]
        then echo ""g = $g; c = $c; true""
        else echo ""g = $g; c = $c; false""
        fi
    done
done
</code></pre>

<p>Example run, using Bash 3.2.57 on Mac OS X:</p>

<pre><code>g = 1; c = 123; true
g = 1; c = 456; false
g = 1; c = 789; false
g = 2; c = 123; false
g = 2; c = 456; true
g = 2; c = 789; false
g = 3; c = 123; false
g = 3; c = 456; false
g = 3; c = 789; false
</code></pre>

<p>You don't need to quote the variables in <code>[[</code> as you do with <code>[</code> because it is not a separate command in the same way that <code>[</code> is.</p>

<hr>

<blockquote>
  <p>Isn't it a classic question?</p>
</blockquote>

<p>I would have thought so.  However, there is another alternative, namely:</p>

<pre><code>if [ ""$g"" -eq 1 -a ""$c"" = ""123"" ] || [ ""$g"" -eq 2 -a ""$c"" = ""456"" ]
then echo abc
else echo efg
fi
</code></pre>

<p>Indeed, if you read the 'portable shell' guidelines for the <code>autoconf</code> tool or related packages, this notation — using '<code>||</code>' and '<code>&amp;&amp;</code>' — is what they recommend.  I suppose you could even go so far as:</p>

<pre><code>if [ ""$g"" -eq 1 ] &amp;&amp; [ ""$c"" = ""123"" ]
then echo abc
elif [ ""$g"" -eq 2 ] &amp;&amp; [ ""$c"" = ""456"" ]
then echo abc
else echo efg
fi
</code></pre>

<p>Where the actions are as trivial as echoing, this isn't bad.  When the action block to be repeated is multiple lines, the repetition is too painful and one of the earlier versions is preferable — or you need to wrap the actions into a function that is invoked in the different <code>then</code> blocks.</p>
"
"Running multiple commands with xargs","6958689","<bash><xargs>","330","<pre><code>cat a.txt | xargs -d $'\n' sh -c 'for arg do command1 ""$arg""; command2 ""$arg""; ...; done' _
</code></pre>

<p>...or, without a <a href=""http://www.catb.org/jargon/html/U/UUOC.html"" rel=""noreferrer"">Useless Use Of cat</a>:</p>

<pre><code>&lt;a.txt xargs -d $'\n' sh -c 'for arg do command1 ""$arg""; command2 ""$arg""; ...; done' _
</code></pre>

<hr>

<p>To explain some of the finer points:</p>

<ul>
<li><p>The use of <code>""$arg""</code> instead of <code>%</code> (and the absence of <code>-I</code> in the <code>xargs</code> command line) is for security reasons: Passing data on <code>sh</code>'s command-line argument list instead of substituting it into code prevents content that data might contain (such as <code>$(rm -rf ~)</code>, to take a particularly malicious example) from being executed as code.</p></li>
<li><p>Similarly, the use of <code>-d $'\n'</code> is a GNU extension which causes <code>xargs</code> to treat each line of the input file as a separate data item. Either this or <code>-0</code> (which expects NULs instead of newlines) is necessary to prevent xargs from trying to apply shell-like (but <em>not quite</em> shell-compatible) parsing to the stream it reads. (If you don't have GNU xargs, you can use <code>tr '\n' '\0' &lt;a.txt | xargs -0 ...</code> to get line-oriented reading without <code>-d</code>).</p></li>
<li><p>The <code>_</code> is a placeholder for <code>$0</code>, such that other data values added by <code>xargs</code> become <code>$1</code> and onward, which happens to be the default set of values a <code>for</code> loop iterates over.</p></li>
</ul>
"
"sed command with -i option failing on Mac, but works on Linux","4247068","<linux><macos><bash><sed>","330","<p>If you use the <code>-i</code> option you need to provide an extension for your backups.</p>

<p>If you have:</p>

<pre><code>File1.txt
File2.cfg
</code></pre>

<p>The command (note the lack of space between <code>-i</code> and <code>''</code> and the <code>-e</code> to make it work on new versions of Mac and on GNU):</p>

<pre><code>sed -i'.original' -e 's/old_link/new_link/g' *
</code></pre>

<p>Create 2 backup files like:</p>

<pre><code>File1.txt.original
File2.cfg.original
</code></pre>

<p>There is no portable way to avoid making backup files because it is impossible to find a mix of sed commands that works on all cases:</p>

<ul>
<li><code>sed -i -e ...</code> - does not work on OS X as it creates <code>-e</code> backups</li>
<li><code>sed -i'' -e ...</code> - does not work on OS X 10.6 but works on 10.9+</li>
<li><code>sed -i '' -e ...</code> - not working on GNU</li>
</ul>

<p><strong>Note</strong> Given that there isn't a sed command working on all platforms, you can try to use another command to achieve the same result.</p>

<p>E.g., <code>perl -i -pe's/old_link/new_link/g' *</code></p>
"
"Is there a better way to run a command N times in bash?","3737740","<bash><loops>","328","<pre><code>for run in {1..10}; do
  command
done
</code></pre>
<p>Or as a one-liner for those that want to copy and paste easily:</p>
<pre><code>for run in {1..10}; do command; done
</code></pre>
"
"Can I export a variable to the environment from a bash script without sourcing it?","16618071","<bash><shell><unix><environment-variables>","328","<blockquote>
  <p>Is there any way to access to the <code>$VAR</code> by just executing <code>export.bash</code> without sourcing it ?</p>
</blockquote>

<p>Quick answer: No.</p>

<p>But there are several possible workarounds.</p>

<p>The most obvious one, which you've already mentioned, is to use <code>source</code> or <code>.</code> to execute the script in the context of the calling shell:</p>

<pre><code>$ cat set-vars1.sh 
export FOO=BAR
$ . set-vars1.sh 
$ echo $FOO
BAR
</code></pre>

<p>Another way is to have the script, rather than setting an environment variable, print commands that will set the environment variable:</p>

<pre><code>$ cat set-vars2.sh
#!/bin/bash
echo export FOO=BAR
$ eval ""$(./set-vars2.sh)""
$ echo ""$FOO""
BAR
</code></pre>

<p>A third approach is to have a script that sets your environment variable(s) internally and then invokes a specified command with that environment:</p>

<pre><code>$ cat set-vars3.sh
#!/bin/bash
export FOO=BAR
exec ""$@""
$ ./set-vars3.sh printenv | grep FOO
FOO=BAR
</code></pre>

<p>This last approach can be quite useful, though it's inconvenient for interactive use since it doesn't give you the settings in your current shell (with all the other settings and history you've built up).</p>
"
"Execute command on all files in a directory","10523415","<bash><scripting>","325","<p>The following bash code will pass $file to command where $file will represent every file in /dir</p>

<pre><code>for file in /dir/*
do
  cmd [option] ""$file"" &gt;&gt; results.out
done
</code></pre>

<p>Example</p>

<pre><code>el@defiant ~/foo $ touch foo.txt bar.txt baz.txt
el@defiant ~/foo $ for i in *.txt; do echo ""hello $i""; done
hello bar.txt
hello baz.txt
hello foo.txt
</code></pre>
"
"How to find out line-endings in a text file?","3569997","<linux><bash><command-line><newline><line-endings>","324","<p>You can use the <code>file</code> utility to give you an indication of the type of line endings.</p>

<p>Unix:</p>

<pre><code>$ file testfile1.txt
testfile.txt: ASCII text
</code></pre>

<p>""DOS"":</p>

<pre><code>$ file testfile2.txt
testfile2.txt: ASCII text, with CRLF line terminators
</code></pre>

<p>To convert from ""DOS"" to Unix:</p>

<pre><code>$ dos2unix testfile2.txt
</code></pre>

<p>To convert from Unix to ""DOS"":</p>

<pre><code>$ unix2dos testfile1.txt
</code></pre>

<p>Converting an already converted file has no effect so it's safe to run blindly (i.e. without testing the format first) although the usual disclaimers apply, as always.</p>
"
"How do I use shell variables in an awk script?","19075671","<bash><shell><awk>","323","<blockquote>
  <h1>Getting shell variables into <code>awk</code></h1>
  
  <p>may be done in several ways. Some are better than others. This should cover most of them.  If you have a comment, please leave below.                                                                                    v1.5</p>
</blockquote>

<hr>

<h2>Using <code>-v</code>  (The best way, most portable)</h2>

<p>Use the <code>-v</code> option: (P.S. use a space after <code>-v</code> or it will be less portable. E.g., <code>awk -v var=</code> not <code>awk -vvar=</code>)</p>

<pre><code>variable=""line one\nline two""
awk -v var=""$variable"" 'BEGIN {print var}'
line one
line two
</code></pre>

<p>This should be compatible with most <code>awk</code>, and the variable is available in the <code>BEGIN</code> block as well:</p>

<p>If you have multiple variables:</p>

<pre><code>awk -v a=""$var1"" -v b=""$var2"" 'BEGIN {print a,b}'
</code></pre>

<p><strong>Warning</strong>.  As Ed Morton writes, escape sequences will be interpreted so <code>\t</code> becomes a real <code>tab</code> and not <code>\t</code> if that is what you search for. Can be solved by using <code>ENVIRON[]</code> or access it via <code>ARGV[]</code></p>

<p><strong>PS</strong> If you like three vertical bar as separator <code>|||</code>, it can't be escaped, so use <code>-F""[|][|][|]""</code></p>

<blockquote>
  <p>Example on getting data from a program/function inn to <code>awk</code> (here date is used)</p>
</blockquote>

<pre><code>awk -v time=""$(date +""%F %H:%M"" -d '-1 minute')"" 'BEGIN {print time}'
</code></pre>

<hr>

<h2>Variable after code block</h2>

<p>Here we get the variable after the <code>awk</code> code. This will work fine as long as you do not need the variable in the <code>BEGIN</code> block:</p>

<pre><code>variable=""line one\nline two""
echo ""input data"" | awk '{print var}' var=""${variable}""
or
awk '{print var}' var=""${variable}"" file
</code></pre>

<ul>
<li>Adding multiple variables:</li>
</ul>

<p><code>awk '{print a,b,$0}' a=""$var1"" b=""$var2"" file</code></p>

<ul>
<li>In this way we can also set different Field Separator <code>FS</code> for each file.</li>
</ul>

<p><code>awk 'some code' FS=',' file1.txt FS=';' file2.ext</code></p>

<ul>
<li>Variable after the code block will not work for the <code>BEGIN</code> block:</li>
</ul>

<p><code>echo ""input data"" | awk 'BEGIN {print var}' var=""${variable}""</code></p>

<hr>

<h2>Here-string</h2>

<p>Variable can also be added to <code>awk</code> using a <a href=""http://en.wikipedia.org/wiki/Here_document"" rel=""noreferrer"">here-string</a> from shells that support them (including Bash):</p>

<pre><code>awk '{print $0}' &lt;&lt;&lt; ""$variable""
test
</code></pre>

<p>This is the same as:</p>

<pre><code>printf '%s' ""$variable"" | awk '{print $0}'
</code></pre>

<p>P.S. this treats the variable as a file input.</p>

<hr>

<h2><code>ENVIRON</code> input</h2>

<p>As TrueY writes, you can use the <code>ENVIRON</code> to print <strong>Environment Variables</strong>.
Setting a variable before running AWK, you can print it out like this:</p>

<pre><code>X=MyVar
awk 'BEGIN{print ENVIRON[""X""],ENVIRON[""SHELL""]}'
MyVar /bin/bash
</code></pre>

<hr>

<h2><code>ARGV</code> input</h2>

<p>As Steven Penny writes, you can use <code>ARGV</code> to get the data into awk:</p>

<pre><code>v=""my data""
awk 'BEGIN {print ARGV[1]}' ""$v""
my data
</code></pre>

<p>To get the data into the code itself, not just the BEGIN:</p>

<pre><code>v=""my data""
echo ""test"" | awk 'BEGIN{var=ARGV[1];ARGV[1]=""""} {print var, $0}' ""$v""
my data test
</code></pre>

<hr>

<h2>Variable within the code: USE WITH CAUTION</h2>

<p>You can use a variable within the <code>awk</code> code, but it's messy and hard to read, and as <code>Charles Duffy</code> points out, this version may also be a victim of code injection.  If someone adds bad stuff to the variable, it will be executed as part of the <code>awk</code> code.</p>

<p>This works by extracting the variable within the code, so it becomes a part of it.</p>

<p>If you want to make an <code>awk</code> that changes dynamically with use of variables, you can do it this way, but DO NOT use it for normal variables.</p>

<pre><code>variable=""line one\nline two""
awk 'BEGIN {print ""'""$variable""'""}'
line one
line two
</code></pre>

<p>Here is an example of code injection:</p>

<pre><code>variable='line one\nline two"" ; for (i=1;i&lt;=1000;++i) print i""'
awk 'BEGIN {print ""'""$variable""'""}'
line one
line two
1
2
3
.
.
1000
</code></pre>

<p>You can add lots of commands to <code>awk</code> this way.  Even make it crash with non valid commands.</p>

<hr>

<h2>Extra info:</h2>

<h3>Use of double quote</h3>

<p>It's always good to double quote variable <code>""$variable""</code><br>
If not, multiple lines will be added as a long single line.</p>

<p>Example:</p>

<pre><code>var=""Line one
This is line two""

echo $var
Line one This is line two

echo ""$var""
Line one
This is line two
</code></pre>

<p>Other errors you can get without double quote:</p>

<pre><code>variable=""line one\nline two""
awk -v var=$variable 'BEGIN {print var}'
awk: cmd. line:1: one\nline
awk: cmd. line:1:    ^ backslash not last character on line
awk: cmd. line:1: one\nline
awk: cmd. line:1:    ^ syntax error
</code></pre>

<p>And with single quote, it does not expand the value of the variable:</p>

<pre><code>awk -v var='$variable' 'BEGIN {print var}'
$variable
</code></pre>

<h3>More info about AWK and variables</h3>

<p><a href=""http://cfajohnson.com/shell/cus-faq-2.html#Q24"" rel=""noreferrer"">Read this faq</a>.</p>
"
"Concatenating multiple text files into a single file in Bash","2150614","<bash><shell>","323","<p>This appends the output to all.txt</p>

<pre><code>cat *.txt &gt;&gt; all.txt
</code></pre>

<p>This overwrites all.txt</p>

<pre><code>cat *.txt &gt; all.txt
</code></pre>
"
"Changing default shell in Linux","13046192","<linux><bash><shell><environment><tcsh>","322","<p>Try linux command <code>chsh</code>.</p>

<p>The detailed command is <code>chsh -s /bin/bash</code>.
It will prompt you to enter your password.
Your default login shell is <code>/bin/bash</code> now. <strong>You must log out and log back in to see this change.</strong></p>

<p>The following is quoted from man page:</p>

<blockquote>
  <p>The chsh command changes the user login shell. This determines the
  name
         of the users initial login command. A normal user may only change the
         login shell for her own account, the superuser may change the login
         shell for any account</p>
</blockquote>

<p>This command will change the default login shell permanently.</p>

<p>Note: If your user account is remote such as on Kerberos authentication (e.g. Enterprise RHEL) then you will not be able to use <code>chsh</code>. </p>
"
"Tar a directory, but don't store full absolute paths in the archive","18681595","<linux><bash><backup><tar>","321","<pre><code>tar -cjf site1.tar.bz2 -C /var/www/site1 .
</code></pre>

<p>In the above example, tar will change to directory <code>/var/www/site1</code> before doing its thing because the option <code>-C /var/www/site1</code> was given.</p>

<p>From <code>man tar</code>:</p>

<pre><code>OTHER OPTIONS

  -C, --directory DIR
       change to directory DIR
</code></pre>
"
"How to pass in password to pg_dump?","2893954","<bash><postgresql><shell><crontab>","320","<p>Create a <code>.pgpass</code> file in the home directory of the account that <code>pg_dump</code> will run as.</p>
<p>The format is:</p>
<pre><code>hostname:port:database:username:password
</code></pre>
<p>Then, set the file's mode to <code>0600</code>. Otherwise, it will be ignored.</p>
<pre><code>chmod 600 ~/.pgpass
</code></pre>
<p>See the Postgresql documentation <a href=""https://www.postgresql.org/docs/current/static/libpq-pgpass.html"" rel=""noreferrer"">libpq-pgpass</a> for more details.</p>
"
"Command to get time in milliseconds","16548528","<linux><bash><shell><time>","320","<p><code>date +%s%N</code> returns the number of seconds + current nanoseconds.</p>

<p>Therefore, <code>echo $(($(date +%s%N)/1000000))</code> is what you need.</p>

<p>Example:</p>

<pre><code>$ echo $(($(date +%s%N)/1000000))
1535546718115
</code></pre>

<p><code>date +%s</code> returns the number of seconds since the epoch, if that's useful.</p>
"
"How to make the 'cut' command treat same sequental delimiters as one?","4143252","<bash><unix><delimiter><cut>","318","<p>Try:</p>

<pre><code>tr -s ' ' &lt;text.txt | cut -d ' ' -f4
</code></pre>

<p>From the <code>tr</code> man page:</p>

<pre>
-s, --squeeze-repeats   replace each input sequence of a repeated character
                        that is listed in SET1 with a single occurrence
                        of that character
</pre>
"
"How can I suppress all output from a command using Bash?","617182","<bash><shell><scripting><echo>","317","<p>The following sends standard output to the null device (bit bucket).</p>

<pre><code>scriptname &gt;/dev/null
</code></pre>

<p>And if you also want error messages to be sent there, use one of (the first may not work in all shells):</p>

<pre><code>scriptname &amp;&gt;/dev/null
scriptname &gt;/dev/null 2&gt;&amp;1
scriptname &gt;/dev/null 2&gt;/dev/null
</code></pre>

<p>And, if you want to record the messages, but not see them, replace <code>/dev/null</code> with an actual file, such as:</p>

<pre><code>scriptname &amp;&gt;scriptname.out
</code></pre>

<p>For completeness, under Windows cmd.exe (where ""nul"" is the equivalent of ""/dev/null""), it is:</p>

<pre><code>scriptname &gt;nul 2&gt;nul
</code></pre>
"
"Getting ssh to execute a command in the background on target machine","29142","<bash><ssh><csh>","314","<p>I had this problem in a program I wrote a year ago -- turns out the answer is rather complicated. You'll need to use nohup as well as output redirection, as explained in the wikipedia artcle on <a href=""http://en.wikipedia.org/wiki/Nohup"" rel=""noreferrer"">nohup</a>, copied here for your convenience. </p>

<blockquote>
  <p>Nohuping backgrounded jobs is for
  example useful when logged in via SSH,
  since backgrounded jobs can cause the
  shell to hang on logout due to a race
  condition [2]. This problem can also
  be overcome by redirecting all three
  I/O streams:</p>

<pre><code>nohup myprogram &gt; foo.out 2&gt; foo.err &lt; /dev/null &amp;
</code></pre>
</blockquote>
"
"OS X Bash, 'watch' command","9574089","<macos><bash><automation><watch>","313","<p>You can emulate the basic functionality with the shell loop:</p>

<pre><code>while :; do clear; your_command; sleep 2; done
</code></pre>

<p>That will loop forever, clear the screen, run your command, and wait two seconds - the basic <code>watch your_command</code> implementation.</p>

<p>You can take this a step further and create a <code>watch.sh</code> script that can accept <code>your_command</code> and <code>sleep_duration</code> as parameters:</p>

<pre><code>#!/bin/bash
# usage: watch.sh &lt;your_command&gt; &lt;sleep_duration&gt;

while :; 
  do 
  clear
  date
  $1
  sleep $2
done
</code></pre>
"
"How to split a string in shell and get the last field","3162385","<bash><split><tokenize><cut>","313","<p>You can use <a href=""http://www.linuxjournal.com/article/8919"" rel=""noreferrer"">string operators</a>:</p>

<pre><code>$ foo=1:2:3:4:5
$ echo ${foo##*:}
5
</code></pre>

<p>This trims everything from the front until a ':', greedily.</p>

<pre><code>${foo  &lt;-- from variable foo
  ##   &lt;-- greedy front trim
  *    &lt;-- matches anything
  :    &lt;-- until the last ':'
 }
</code></pre>
"
"How to view files in binary from bash?","1765311","<bash><shell><binary>","310","<p><a href=""https://linux.die.net/man/1/xxd"" rel=""noreferrer""><code>xxd</code></a> does both binary and hexadecimal.</p>

<p>bin:</p>

<pre><code>xxd -b file
</code></pre>

<p>hex:</p>

<pre><code>xxd file
</code></pre>
"
"Repeat command automatically in Linux","13593771","<linux><bash><ubuntu>","309","<p>Watch every 5 seconds ...</p>

<p><code>watch -n 5 ls -l</code></p>

<p>If you wish to have visual confirmation of changes, append <code>--differences</code> prior to the <code>ls</code> command.</p>

<p>According to the OSX man page, there's also</p>

<blockquote>
  <p>The --cumulative option makes highlighting ""sticky"", presenting a
  running display of  all  positions  that  have  ever changed.  The -t
  or --no-title option turns off the header showing the interval,
  command, and current time at the top of the display, as well as the
  following blank line.</p>
</blockquote>

<p>Linux/Unix man page can be found <a href=""http://linux.die.net/man/1/watch"" rel=""noreferrer"">here</a> </p>
"
"Install MySQL on Ubuntu without a password prompt","7739645","<mysql><bash><ubuntu><apt>","306","<pre><code>sudo debconf-set-selections &lt;&lt;&lt; 'mysql-server mysql-server/root_password password your_password'
sudo debconf-set-selections &lt;&lt;&lt; 'mysql-server mysql-server/root_password_again password your_password'
sudo apt-get -y install mysql-server
</code></pre>

<p>For specific versions, such as <code>mysql-server-5.6</code>, you'll need to specify the version in like this:</p>

<pre><code>sudo debconf-set-selections &lt;&lt;&lt; 'mysql-server-5.6 mysql-server/root_password password your_password'
sudo debconf-set-selections &lt;&lt;&lt; 'mysql-server-5.6 mysql-server/root_password_again password your_password'
sudo apt-get -y install mysql-server-5.6
</code></pre>

<p>For mysql-community-server, the keys are slightly different:</p>

<pre><code>sudo debconf-set-selections &lt;&lt;&lt; 'mysql-community-server mysql-community-server/root-pass password your_password'
sudo debconf-set-selections &lt;&lt;&lt; 'mysql-community-server mysql-community-server/re-root-pass password your_password'
sudo apt-get -y install mysql-community-server
</code></pre>

<p>Replace your_password with the desired root password. (it seems your_password can also be left blank for a blank root password.)</p>

<p>If your shell doesn't support <em>here-strings</em> (<em>zsh</em>, <em>ksh93</em> and <em>bash</em> support them), use:</p>

<pre><code>echo ... | sudo debconf-set-selections 
</code></pre>
"
"Why do you need ./ (dot-slash) before executable or script name to run it in bash?","6331075","<bash><shell><unix><command-line>","306","<p>Because on Unix, usually, the current directory is not in <code>$PATH</code>.</p>

<p>When you type a command the shell looks up a list of directories, as specified by the <code>PATH</code> variable. The current directory is not in that list.</p>

<p>The reason for not having the current directory on that list is security.</p>

<p>Let's say you're root and go into another user's directory and type <code>sl</code> instead of <code>ls</code>. If the current directory is in <code>PATH</code>, the shell will try to execute the <code>sl</code> program in that directory (since there is no other <code>sl</code> program). That <code>sl</code> program might be malicious.</p>

<p>It works with <code>./</code> because <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_09_01_01"" rel=""noreferrer"">POSIX specifies</a> that a command name that contain a <code>/</code> will be used as a filename directly, suppressing a search in <code>$PATH</code>. You could have used full path for the exact same effect, but <code>./</code> is shorter and easier to write.</p>

<p><strong>EDIT</strong></p>

<p>That <code>sl</code> part was just an example. The directories in <code>PATH</code> are searched sequentially and when a match is made that program is executed. So, depending on how <code>PATH</code> looks, typing a normal command may or may not be enough to run the program in the current directory.</p>
"
"How to get arguments with flags in Bash","7069682","<bash><shell>","304","<p>This is the idiom I usually use:</p>

<pre><code>while test $# -gt 0; do
  case ""$1"" in
    -h|--help)
      echo ""$package - attempt to capture frames""
      echo "" ""
      echo ""$package [options] application [arguments]""
      echo "" ""
      echo ""options:""
      echo ""-h, --help                show brief help""
      echo ""-a, --action=ACTION       specify an action to use""
      echo ""-o, --output-dir=DIR      specify a directory to store output in""
      exit 0
      ;;
    -a)
      shift
      if test $# -gt 0; then
        export PROCESS=$1
      else
        echo ""no process specified""
        exit 1
      fi
      shift
      ;;
    --action*)
      export PROCESS=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    -o)
      shift
      if test $# -gt 0; then
        export OUTPUT=$1
      else
        echo ""no output dir specified""
        exit 1
      fi
      shift
      ;;
    --output-dir*)
      export OUTPUT=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    *)
      break
      ;;
  esac
done
</code></pre>

<p>Key points are:</p>

<ul>
<li><code>$#</code> is the number of arguments</li>
<li>while loop looks at all the arguments supplied, matching on their values inside a case statement</li>
<li>shift takes the first one away. You can shift multiple times inside of a case statement to take multiple values.</li>
</ul>
"
"What does `set -x` do?","36273665","<linux><bash><unix><scripting>","301","<p><code>set -x</code> enables a mode of the shell where all executed commands are printed to the terminal.  In your case it's clearly used for debugging, which is a typical use case for <code>set -x</code>: printing every command as it is executed may help you to visualize the control flow of the script if it is not functioning as expected.</p>

<p><code>set +x</code> disables it.</p>
"
"How to redirect both stdout and stderr to a file","7526971","<bash><stdout><io-redirection><stderr>","301","<p>If you want to log to the same file:</p>

<pre><code>command1 &gt;&gt; log_file 2&gt;&amp;1
</code></pre>

<p>If you want different files:</p>

<pre><code>command1 &gt;&gt; log_file 2&gt;&gt; err_file
</code></pre>
"
"How to check if running as root in a bash script","18215973","<bash><shell><root>","301","<p>A few answers have been given, but it appears that the best method is to use is:</p>

<ul>
<li><code>id -u</code> </li>
<li>If run as root, will return an id of 0.</li>
</ul>

<p>This appears to be more reliable than the other methods, and it seems that it return an id of 0 even if the script is run through <code>sudo</code>. </p>
"
"Replacing some characters in a string with another character","2871181","<string><bash>","300","<pre><code>echo ""$string"" | tr xyz _
</code></pre>

<p>would replace each occurrence of <code>x</code>, <code>y</code>, or <code>z</code> with <code>_</code>, giving <code>A__BC___DEF__LMN</code> in your example.</p>

<pre><code>echo ""$string"" | sed -r 's/[xyz]+/_/g'
</code></pre>

<p>would replace repeating occurrences of <code>x</code>, <code>y</code>, or <code>z</code> with a single <code>_</code>, giving <code>A_BC_DEF_LMN</code> in your example.</p>
"
"Suppress warning messages using mysql from within Terminal, but password written in bash script","20751352","<mysql><bash><shell>","300","<p>If your MySQL client/server version is a 5.6.x a way to avoid the WARNING message are using the <strong><a href=""http://dev.mysql.com/doc/refman/5.6/en/mysql-config-editor.html"" rel=""noreferrer"">mysql_config_editor</a></strong> tools:</p>

<pre><code>mysql_config_editor set --login-path=local --host=localhost --user=username --password
</code></pre>

<p>Then you can use in your shell script:</p>

<pre><code>mysql --login-path=local  -e ""statement""
</code></pre>

<p>Instead of:</p>

<pre><code>mysql -u username -p pass -e ""statement""
</code></pre>
"
"'\r': command not found - .bashrc / .bash_profile","11616835","<bash><shell><cygwin><newline>","300","<p><strong>When all else fails in Cygwin...</strong></p>

<p>Try running the <code>dos2unix</code> command on the file in question.</p>

<p>It might help when you see error messages like this: </p>

<p><code>-bash: '\r': command not found</code></p>

<p>Windows style newline characters can cause issues in Cygwin.</p>

<p>The <code>dos2unix</code> command modifies newline characters so they are Unix / Cygwin compatible.</p>

<p><strong>CAUTION:</strong> the dos2unix command modifies files <em>in place</em>, so take precaution if necessary.</p>

<p>If you need to keep the original file, you should back it up first.</p>

<p><strong>Note for Mac users:</strong> The <code>dos2unix</code> command does not exist on Mac OS X.</p>

<p>Check out <a href=""https://stackoverflow.com/q/1251999/778118"">this answer</a> for a variety of solutions using different tools.</p>

<hr>

<p>There is also a <code>unix2dos</code> command that does the reverse:</p>

<p>It modifies Unix newline characters so they're compatible with Windows tools.</p>

<p>If you open a file with Notepad and all the lines run together, try <code>unix2dos filename</code>.</p>
"
"How to use arguments from previous command?","4009412","<bash><command-line><keyboard-shortcuts><input-history>","298","<p>Just as <code>M-.</code> (meta-dot or esc-dot or alt-dot) is the readline function <code>yank-last-arg</code>, <code>M-C-y</code> (meta-control-y or esc-ctrl-y or ctrl-alt-y) is the readline function <code>yank-nth-arg</code>. Without specifying <code>n</code>, it yanks the first argument of the previous command.</p>

<p>To specify an argument, press Escape and a number or hold Alt and press a number. You can do <kbd>Alt</kbd>-<kbd>-</kbd>to begin specifying a negative number then release Alt and press the digit (this will count from the end of the list of arguments.</p>

<p>Example:</p>

<p>Enter the following command</p>

<pre><code>$ echo a b c d e f g
a b c d e f g
</code></pre>

<p>Now at the next prompt, type <code>echo</code> (with a following space), then</p>

<p>Press <kbd>Alt</kbd>-<kbd>Ctrl</kbd>-<kbd>y</kbd> and you'll now see:</p>

<pre><code>$ echo a
</code></pre>

<p>without pressing <kbd>Enter</kbd> yet, do the following</p>

<p>Press <kbd>Alt</kbd>-<kbd>3</kbd>  <kbd>Alt</kbd>-<kbd>Ctrl</kbd>-<kbd>y</kbd></p>

<p>Press <kbd>Alt</kbd>-<kbd>-</kbd> <kbd>2</kbd> <kbd>Alt</kbd>-<kbd>Ctrl</kbd>-<kbd>y</kbd></p>

<p>Now you will see:</p>

<pre><code>$ echo ace
</code></pre>

<p>By the way, you could have put the <code>echo</code> on the line by selecting argument 0:</p>

<p>Press <kbd>Alt</kbd>-<kbd>0</kbd> <kbd>Alt</kbd>-<kbd>Ctrl</kbd>-<kbd>y</kbd></p>

<p><strong>Edit:</strong></p>

<p>To answer the question you added to your original:</p>

<p>You can press <kbd>Alt</kbd>-<kbd>0</kbd> then repeatedly press <kbd>Alt</kbd>-<kbd>.</kbd> to step through the previous commands (arg 0). Similarly <kbd>Alt</kbd>-<kbd>-</kbd> then repeating <kbd>Alt</kbd>-<kbd>.</kbd> would allow you to step through the previous next-to-last arguments.</p>

<p>If there is no appropriate argument on a particular line in history, the bell will be rung.</p>

<p>If there is a particular combination you use frequently, you can define a macro so one keystroke will perform it. This example will recall the second argument from previous commands by pressing <kbd>Alt</kbd>-<kbd>Shift</kbd>-<kbd>Y</kbd>. You could choose any available keystroke you prefer instead of this one. You can press it repeatedly to step through previous ones.</p>

<p>To try it out, enter the macro at a Bash prompt:</p>

<pre><code>bind '""\eY"": ""\e2\e.""'
</code></pre>

<p>To make it persistent, add this line to your <code>~/.inputrc</code> file:</p>

<pre><code>""\eY"": ""\e2\e.""
</code></pre>

<p>Unfortunately, this doesn't seem to work for arg 0 or negative argument numbers.</p>
"
"Using the RUN instruction in a Dockerfile with 'source' does not work","20635472","<bash><shell><docker>","297","<p><code>RUN /bin/bash -c ""source /usr/local/bin/virtualenvwrapper.sh""</code></p>
"
"Running script upon login mac","6442364","<bash><shell><authentication><terminal><osx-snow-leopard>","296","<p>Follow this:</p>

<ul>
<li>start <code>Automator.app</code></li>
<li>select <code>Application</code></li>
<li>click <code>Show library</code> in the toolbar (if hidden)</li>
<li>add <code>Run shell script</code> (from the <code>Actions/Utilities</code>)</li>
<li>copy &amp; paste your script into the window</li>
<li>test it </li>
<li><p>save somewhere (for example you can make an <code>Applications</code> folder in your HOME, you will get an <code>your_name.app</code>)</p></li>
<li><p>go to <code>System Preferences</code> -> <code>Accounts</code> -> <code>Login items</code></p></li>
<li>add this app</li>
<li>test &amp; done ;)</li>
</ul>

<p><strong>EDIT:</strong></p>

<p><em>I've recently earned a ""Good answer"" badge for this answer. While my solution is simple and working, the cleanest way to run any program or shell script at login time is described in <a href=""https://stackoverflow.com/a/13372744/805031"">@trisweb's answer</a></em>, <strong>unless, you want interactivity</strong>.</p>

<p>With automator solution you can do things like next:
<img src=""https://i.stack.imgur.com/sCy4t.png"" alt=""automator screenshot login application""></p>

<p>so, asking to run a script or quit the app, asking passwords, running other automator workflows at login time, conditionally run applications at login time and so on...</p>
"
"Timeout a command in bash without unnecessary delay","687948","<bash><command-line><timeout><utilities>","295","<p>I think this is precisely what you are asking for:</p>

<p><a href=""http://www.bashcookbook.com/bashinfo/source/bash-4.0/examples/scripts/timeout3"" rel=""noreferrer"">http://www.bashcookbook.com/bashinfo/source/bash-4.0/examples/scripts/timeout3</a></p>

<pre><code>#!/bin/bash
#
# The Bash shell script executes a command with a time-out.
# Upon time-out expiration SIGTERM (15) is sent to the process. If the signal
# is blocked, then the subsequent SIGKILL (9) terminates it.
#
# Based on the Bash documentation example.

# Hello Chet,
# please find attached a ""little easier""  :-)  to comprehend
# time-out example.  If you find it suitable, feel free to include
# anywhere: the very same logic as in the original examples/scripts, a
# little more transparent implementation to my taste.
#
# Dmitry V Golovashkin &lt;Dmitry.Golovashkin@sas.com&gt;

scriptName=""${0##*/}""

declare -i DEFAULT_TIMEOUT=9
declare -i DEFAULT_INTERVAL=1
declare -i DEFAULT_DELAY=1

# Timeout.
declare -i timeout=DEFAULT_TIMEOUT
# Interval between checks if the process is still alive.
declare -i interval=DEFAULT_INTERVAL
# Delay between posting the SIGTERM signal and destroying the process by SIGKILL.
declare -i delay=DEFAULT_DELAY

function printUsage() {
    cat &lt;&lt;EOF

Synopsis
    $scriptName [-t timeout] [-i interval] [-d delay] command
    Execute a command with a time-out.
    Upon time-out expiration SIGTERM (15) is sent to the process. If SIGTERM
    signal is blocked, then the subsequent SIGKILL (9) terminates it.

    -t timeout
        Number of seconds to wait for command completion.
        Default value: $DEFAULT_TIMEOUT seconds.

    -i interval
        Interval between checks if the process is still alive.
        Positive integer, default value: $DEFAULT_INTERVAL seconds.

    -d delay
        Delay between posting the SIGTERM signal and destroying the
        process by SIGKILL. Default value: $DEFAULT_DELAY seconds.

As of today, Bash does not support floating point arithmetic (sleep does),
therefore all delay/time values must be integers.
EOF
}

# Options.
while getopts "":t:i:d:"" option; do
    case ""$option"" in
        t) timeout=$OPTARG ;;
        i) interval=$OPTARG ;;
        d) delay=$OPTARG ;;
        *) printUsage; exit 1 ;;
    esac
done
shift $((OPTIND - 1))

# $# should be at least 1 (the command to execute), however it may be strictly
# greater than 1 if the command itself has options.
if (($# == 0 || interval &lt;= 0)); then
    printUsage
    exit 1
fi

# kill -0 pid   Exit code indicates if a signal may be sent to $pid process.
(
    ((t = timeout))

    while ((t &gt; 0)); do
        sleep $interval
        kill -0 $$ || exit 0
        ((t -= interval))
    done

    # Be nice, post SIGTERM first.
    # The 'exit 0' below will be executed if any preceeding command fails.
    kill -s SIGTERM $$ &amp;&amp; kill -0 $$ || exit 0
    sleep $delay
    kill -s SIGKILL $$
) 2&gt; /dev/null &amp;

exec ""$@""
</code></pre>
"
"Find the files existing in one directory but not in the other","16787916","<linux><bash><diff>","295","<pre><code>diff -r dir1 dir2 | grep dir1 | awk '{print $4}' &gt; difference1.txt
</code></pre>

<p><strong>Explanation:</strong></p>

<ul>
<li><p><code>diff -r dir1 dir2</code> shows which files are only in dir1 and those only in dir2 and also the changes of the files present in both directories if any.</p></li>
<li><p><code>diff -r dir1 dir2 | grep dir1</code>  shows which files are only in dir1</p></li>
<li><p><code>awk</code> to print only filename.</p></li>
</ul>
"
"How to programmatically determine the current checked out Git branch","1593051","<git><bash><shell>","292","<p>The correct solution is to take a peek at <a href=""http://git.kernel.org/?p=git/git.git;a=blob;f=contrib/completion/git-completion.bash;hb=HEAD"" rel=""noreferrer"" title=""git.kernel.org - git/git.git/blob - contrib/completion/git-completion.bash"">contrib/completions/git-completion.bash</a> does that for bash prompt in <code>__git_ps1</code>.  Removing all extras like selecting how to describe detached HEAD situation, i.e. when we are on unnamed branch, it is:</p>

<pre><code>branch_name=""$(git symbolic-ref HEAD 2&gt;/dev/null)"" ||
branch_name=""(unnamed branch)""     # detached HEAD

branch_name=${branch_name##refs/heads/}
</code></pre>

<p><a href=""http://www.kernel.org/pub/software/scm/git/docs/git-symbolic-ref.html"" rel=""noreferrer"" title=""git-symbolic-ref - Read and modify symbolic refs"">git symbolic-ref</a> is used to extract fully qualified branch name from symbolic reference; we use it for HEAD, which is currently checked out branch.</p>

<p>Alternate solution could be:</p>

<pre><code>branch_name=$(git symbolic-ref -q HEAD)
branch_name=${branch_name##refs/heads/}
branch_name=${branch_name:-HEAD}
</code></pre>

<p>where in last line we deal with the detached HEAD situation, using simply ""HEAD"" to denote such situation.</p>

<hr>

<p><strong>Added 11-06-2013</strong></p>

<p>Junio C. Hamano (git maintainer) blog post, <a href=""http://git-blame.blogspot.com/2013/06/checking-current-branch-programatically.html"" rel=""noreferrer""><em>Checking the current branch programatically</em></a>, from June 10, 2013 explains <strong><em>whys</em></strong> (and hows) in more detail.</p>
"
"How to convert timestamps to dates in Bash?","2371248","<bash><date><unix-timestamp>","291","<p>On later versions of common Linux distributions you can use:</p>

<pre><code>date -d @1267619929
</code></pre>
"
"Find the files that have been changed in last 24 hours","16085958","<linux><bash><find>","290","<p>To find all files modified in the last 24 hours (last full day) in a particular specific directory and its sub-directories:</p>

<pre><code>find /directory_path -mtime -1 -ls
</code></pre>

<p>Should be to your liking</p>

<p>The <code>-</code> before <code>1</code> is important - it means anything changed one day or less ago.
A <code>+</code> before <code>1</code> would instead mean anything changed at least one day ago, while having nothing before the <code>1</code> would have meant it was changed exacted one day ago, no more, no less.</p>
"
"How to create a CPU spike with a bash command","2925606","<linux><bash><load><cpu>","288","<p>You can also do</p>

<pre><code>dd if=/dev/zero of=/dev/null
</code></pre>

<p>To run more of those to put load on more cores, try to fork it: </p>

<pre><code>fulload() { dd if=/dev/zero of=/dev/null | dd if=/dev/zero of=/dev/null | dd if=/dev/zero of=/dev/null | dd if=/dev/zero of=/dev/null &amp; }; fulload; read; killall dd
</code></pre>

<p>Repeat the command in the curly brackets as many times as the number of threads you want to produce (here 4 threads). 
Simple enter hit will stop it (just make sure no other dd is running on this user or you kill it too). </p>
"
"count number of lines in terminal output","12457457","<bash><terminal>","287","<p>Pipe the result to <a href=""http://en.wikipedia.org/wiki/Wc_%28Unix%29"" rel=""noreferrer""><code>wc</code></a> using the <code>-l</code> (<em>line count</em>) switch:</p>

<pre><code>grep -Rl ""curl"" ./ | wc -l
</code></pre>
"
"How to execute a bash command stored as a string with quotes and asterisk","2005192","<bash><scripting><escaping><quotes>","286","<p>Have you tried:</p>

<pre><code>eval $cmd
</code></pre>

<p>For the follow-on question of how to escape <code>*</code> since it has special meaning when it's naked or in double quoted strings: use single quotes.</p>

<pre><code>MYSQL='mysql AMORE -u username -ppassword -h localhost -e'
QUERY=""SELECT ""'*'"" FROM amoreconfig"" ;# &lt;-- ""double""'single'""double""
eval $MYSQL ""'$QUERY'""
</code></pre>

<p>Bonus: It also reads nice: eval mysql query ;-)</p>
"
"Bash conditionals: how to ""and"" expressions? (if [ ! -z $VAR && -e $VAR ])","8920245","<bash><shell>","285","<pre><code>if [ ! -z ""$var"" ] &amp;&amp; [ -e ""$var"" ]; then
      # something ...
fi
</code></pre>
"
"Can bash show a function's definition?","6916856","<bash><function>","285","<p>Use <code>type</code>. If <code>foobar</code> is e.g. defined in your <code>~/.profile</code>:</p>

<pre><code>$ type foobar
foobar is a function
foobar {
    echo ""I'm foobar""
}
</code></pre>

<p>This does find out what <code>foobar</code> was, and if it was defined as a function it calls <code>declare -f</code> as explained by pmohandras.</p>

<p>To print out just the body of the function (i.e. the code) use <code>sed</code>:</p>

<pre><code>type foobar | sed '1,3d;$d'
</code></pre>
"
"How to check if a file contains a specific string using Bash","11287861","<bash><shell><grep>","285","<pre><code>if grep -q SomeString ""$File""; then
  Some Actions # SomeString was found
fi
</code></pre>

<p>You don't need <code>[[ ]]</code> here. Just run the command directly. Add <code>-q</code> option when you don't need the string displayed when it was found.</p>

<p>The <code>grep</code> command returns 0 or 1 in the exit code depending on
the result of search. 0 if something was found; 1 otherwise.</p>

<pre><code>$ echo hello | grep hi ; echo $?
1
$ echo hello | grep he ; echo $?
hello
0
$ echo hello | grep -q he ; echo $?
0
</code></pre>

<p>You can specify commands as an condition of <code>if</code>. If the command returns 0 in its exitcode that means that the condition is true; otherwise false.</p>

<pre><code>$ if /bin/true; then echo that is true; fi
that is true
$ if /bin/false; then echo that is true; fi
$
</code></pre>

<p>As you can see you run here the programs directly. No additional <code>[]</code> or <code>[[]]</code>.</p>
"
"Open and write data to text file using Bash?","11162406","<bash><shell>","283","<pre><code>echo ""some data for the file"" &gt;&gt; fileName
</code></pre>
"
"How to replace spaces in file names using a bash script","2709458","<linux><bash><whitespace><filenames>","283","<p>Use <code>rename</code> (aka <code>prename</code>) which is a Perl script which may be on your system already. Do it in two steps:</p>

<pre><code>find -name ""* *"" -type d | rename 's/ /_/g'    # do the directories first
find -name ""* *"" -type f | rename 's/ /_/g'
</code></pre>

<p>Based on <strong>Jürgen's</strong> answer and able to handle multiple layers of files and directories in a single bound using the ""Revision 1.5  1998/12/18 16:16:31  rmb1"" version of <code>/usr/bin/rename</code> (a Perl script):</p>

<pre><code>find /tmp/ -depth -name ""* *"" -execdir rename 's/ /_/g' ""{}"" \;
</code></pre>
"
"How to output a multiline string in Bash?","10969953","<bash>","282","<p>Here documents are often used for this purpose.</p>

<pre><code>cat &lt;&lt; EOF
usage: up [--level &lt;n&gt;| -n &lt;levels&gt;][--help][--version]

Report bugs to: 
up home page:
EOF
</code></pre>

<p>They are supported in all Bourne-derived shells including all versions of Bash.</p>
"
"What is the difference between $(command) and `command` in shell programming?","4708549","<bash><shell><ksh><sh>","281","<p>The backticks/gravemarks have been deprecated in favor of <code>$()</code> for command substitution because <code>$()</code> can easily nest within itself as in <code>$(echo foo$(echo bar))</code>.  There are other differences such as how backslashes are parsed in the backtick/gravemark version, etc. </p>

<p>See <a href=""http://mywiki.wooledge.org/BashFAQ/082"" rel=""noreferrer""><strong>BashFAQ/082</strong></a> for several reasons to always prefer the $(...) syntax.</p>

<p>Also see the <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xcu_chap02.html#tag_23_02_06_03"" rel=""noreferrer""><strong>POSIX</strong></a> spec for detailed information on the various differences.</p>
"
"Write to file, but overwrite it if it exists","4676459","<bash><unix>","278","<p>The <code>&gt;&gt;</code> redirection operator will append lines to the end of the specified file, where-as the single greater than <code>&gt;</code> will empty and overwrite the file.</p>
<pre><code>echo &quot;text&quot; &gt; 'Users/Name/Desktop/TheAccount.txt'
</code></pre>
"
"How do I syntax check a Bash script without running it?","171924","<linux><bash><unix><syntax><gnu>","277","<pre><code>bash -n scriptname
</code></pre>

<p>Perhaps an obvious caveat: this validates syntax but won't check if your bash script tries to execute a command that isn't in your path, like <code>ech hello</code> instead of <code>echo hello</code>.</p>
"
"How do I find all of the symlinks in a directory tree?","8513133","<bash><find><symlink>","276","<p>This will recursively traverse the <code>/path/to/folder</code> directory and list only the symbolic links:</p>

<pre><code>ls -lR /path/to/folder | grep ^l
</code></pre>

<p>If your intention is to follow the symbolic links too, you should use your <code>find</code> command but you should include the <code>-L</code> option; in fact the <code>find</code> man page says:</p>

<pre class=""lang-none prettyprint-override""><code>   -L     Follow symbolic links.  When find examines or prints information
          about files, the information used shall be taken from the  prop‐
          erties  of  the file to which the link points, not from the link
          itself (unless it is a broken symbolic link or find is unable to
          examine  the file to which the link points).  Use of this option
          implies -noleaf.  If you later use the -P option,  -noleaf  will
          still  be  in  effect.   If -L is in effect and find discovers a
          symbolic link to a subdirectory during its search, the subdirec‐
          tory pointed to by the symbolic link will be searched.

          When the -L option is in effect, the -type predicate will always
          match against the type of the file that a symbolic  link  points
          to rather than the link itself (unless the symbolic link is bro‐
          ken).  Using -L causes the -lname and -ilname predicates  always
          to return false.
</code></pre>

<p>Then try this:</p>

<pre><code>find -L /var/www/ -type l
</code></pre>

<p>This will probably work: I found in the <code>find</code> man page this diamond: if you are using the <code>-type</code> option you have to change it to the <code>-xtype</code> option:</p>

<pre class=""lang-none prettyprint-override""><code>          l      symbolic link; this is never true if the -L option or the
                 -follow option is in effect, unless the symbolic link  is
                 broken.  If you want to search for symbolic links when -L
                 is in effect, use -xtype.
</code></pre>

<p>Then:</p>

<pre><code>find -L /var/www/ -xtype l
</code></pre>
"
"How do you run multiple programs in parallel from a bash script?","3004811","<bash><parallel-processing>","275","<pre><code>prog1 &amp;
prog2 &amp;
</code></pre>
"
"How to get the first line of a file in a bash script?","2439579","<bash>","273","<p><code>head</code> takes the first lines from a file, and the <code>-n</code> parameter can be used to specify how many lines should be extracted:</p>

<pre><code>line=$(head -n 1 filename)
</code></pre>
"
"Simple logical operators in Bash","6270440","<bash><logical-operators>","273","<p>What you've written actually almost works (it would work if all the variables were numbers), but it's not an idiomatic way at all.</p>

<ul>
<li><code>(…)</code> parentheses indicate a <a href=""http://www.gnu.org/software/bash/manual/bash.html#Command-Grouping"" rel=""noreferrer"">subshell</a>. What's inside them isn't an expression like in many other languages. It's a list of commands (just like outside parentheses). These commands are executed in a separate subprocess, so any redirection, assignment, etc. performed inside the parentheses has no effect outside the parentheses.

<ul>
<li>With a leading dollar sign, <code>$(…)</code> is a <a href=""http://www.gnu.org/software/bash/manual/bash.html#Command-Substitution"" rel=""noreferrer"">command substitution</a>: there is a command inside the parentheses, and the output from the command is used as part of the command line (after extra expansions unless the substitution is between double quotes, but that's <a href=""https://unix.stackexchange.com/questions/131766/why-does-my-shell-script-choke-on-whitespace-or-other-special-characters"">another story</a>).</li>
</ul></li>
<li><code>{ … }</code> braces are like parentheses in that they group commands, but they only influence parsing, not grouping. The program <code>x=2; { x=4; }; echo $x</code> prints 4, whereas <code>x=2; (x=4); echo $x</code> prints 2. (Also braces require spaces around them and a semicolon before closing, whereas parentheses don't. That's just a syntax quirk.)

<ul>
<li>With a leading dollar sign, <code>${VAR}</code> is a <a href=""http://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion"" rel=""noreferrer"">parameter expansion</a>, expanding to the value of a variable, with possible extra transformations.</li>
</ul></li>
<li><code>((…))</code> double parentheses surround an <a href=""http://www.gnu.org/software/bash/manual/bash.html#Shell-Arithmetic"" rel=""noreferrer"">arithmetic instruction</a>, that is, a computation on integers, with a syntax resembling other programming languages. This syntax is mostly used for assignments and in conditionals.

<ul>
<li>The same syntax is used in arithmetic expressions <code>$((…))</code>, which expand to the integer value of the expression.</li>
</ul></li>
<li><code>[[ … ]]</code> double brackets surround <a href=""http://www.gnu.org/software/bash/manual/bash.html#index-_005b_005b"" rel=""noreferrer"">conditional expressions</a>. Conditional expressions are mostly built on <a href=""http://www.gnu.org/software/bash/manual/bash.html#Bash-Conditional-Expressions"" rel=""noreferrer"">operators</a> such as <code>-n $variable</code> to test if a variable is empty and <code>-e $file</code> to test if a file exists. There are also string equality operators: <code>""$string1"" == ""$string2""</code> (beware that the right-hand side is a pattern, e.g. <code>[[ $foo == a* ]]</code> tests if <code>$foo</code> starts with <code>a</code> while <code>[[ $foo == ""a*"" ]]</code> tests if <code>$foo</code> is exactly <code>a*</code>), and the familiar <code>!</code>, <code>&amp;&amp;</code> and <code>||</code> operators for negation, conjunction and disjunction as well as parentheses for grouping. Note that you need a space around each operator (e.g. <code>[[ ""$x"" == ""$y"" ]]</code>, not <s><code>[[ ""$x""==""$y"" ]]</code></s>), and a space or a character like <code>;</code> both inside and outside the brackets (e.g. <code>[[ -n $foo ]]</code>, not <s><code>[[-n $foo]]</code></s>).</li>
<li><code>[ … ]</code> single brackets are an alternate form of conditional expressions with more quirks (but older and more portable). Don't write any for now; start worrying about them when you find scripts that contain them.</li>
</ul>

<p>This is the idiomatic way to write your test in bash:</p>

<pre><code>if [[ $varA == 1 &amp;&amp; ($varB == ""t1"" || $varC == ""t2"") ]]; then
</code></pre>

<p>If you need portability to other shells, this would be the way (note the additional quoting and the separate sets of brackets around each individual test, and the use of the traditional <code>=</code> operator rather than the ksh/bash/zsh <code>==</code> variant):</p>

<pre><code>if [ ""$varA"" = 1 ] &amp;&amp; { [ ""$varB"" = ""t1"" ] || [ ""$varC"" = ""t2"" ]; }; then
</code></pre>
"
"Fast way of finding lines in one file that are not in another?","18204904","<bash><grep><find><diff>","272","<p>You can achieve this by controlling the formatting of the old/new/unchanged lines in GNU <code>diff</code> output:</p>

<pre><code>diff --new-line-format="""" --unchanged-line-format=""""  file1 file2
</code></pre>

<p>The input files <em>should be sorted</em> for this to work. With <code>bash</code> (and <code>zsh</code>) you can sort in-place with process substitution <code>&lt;( )</code>:</p>

<pre><code>diff --new-line-format="""" --unchanged-line-format="""" &lt;(sort file1) &lt;(sort file2)
</code></pre>

<p>In the above <em>new</em> and <em>unchanged</em> lines are suppressed,  so only <em>changed</em> (i.e. removed lines in your case) are output. You may also use a few <code>diff</code> options that other solutions don't offer, such as <code>-i</code> to ignore case, or various whitespace options (<code>-E</code>, <code>-b</code>, <code>-v</code> etc) for less strict matching.</p>

<hr>

<p><strong>Explanation</strong></p>

<p>The options <code>--new-line-format</code>, <code>--old-line-format</code> and <code>--unchanged-line-format</code> let you control the way <code>diff</code> formats the differences, similar to  <code>printf</code> format specifiers. These options format <em>new</em> (added), <em>old</em> (removed) and <em>unchanged</em> lines respectively. Setting one to empty """" prevents output of that kind of line.</p>

<p>If you are familiar with <em>unified diff</em> format, you can partly recreate it with:</p>

<pre><code>diff --old-line-format=""-%L"" --unchanged-line-format="" %L"" \
     --new-line-format=""+%L"" file1 file2
</code></pre>

<p>The <code>%L</code> specifier is the line in question, and we prefix each with ""+"" ""-"" or "" "", like <code>diff -u</code>
(note that it only outputs differences, it lacks the <code>---</code> <code>+++</code> and <code>@@</code> lines at the top of each grouped change).
You can also use this to do other useful things like <a href=""https://unix.stackexchange.com/questions/34874/diff-output-line-numbers"">number each line</a> with <code>%dn</code>.</p>

<hr>

<p>The <code>diff</code> method (along with other suggestions <code>comm</code> and <code>join</code>) only produce the expected output with <em>sorted</em> input, though you can use <code>&lt;(sort ...)</code> to sort in place. Here's a simple <code>awk</code> (nawk) script (inspired by the scripts linked-to in Konsolebox's answer) which accepts arbitrarily ordered input files, <em>and</em> outputs the missing lines in the order they occur in file1.</p>

<pre class=""lang-pl prettyprint-override""><code># output lines in file1 that are not in file2
BEGIN { FS="""" }                         # preserve whitespace
(NR==FNR) { ll1[FNR]=$0; nl1=FNR; }     # file1, index by lineno
(NR!=FNR) { ss2[$0]++; }                # file2, index by string
END {
    for (ll=1; ll&lt;=nl1; ll++) if (!(ll1[ll] in ss2)) print ll1[ll]
}
</code></pre>

<p>This stores the entire contents of file1 line by line in a line-number indexed array <code>ll1[]</code>, and the entire contents of file2 line by line in a line-content indexed associative array <code>ss2[]</code>. After both files are read, iterate over <code>ll1</code> and use the <code>in</code> operator to determine if the line in file1 is present in file2. (This will have have different output to the <code>diff</code> method if there are duplicates.)</p>

<p>In the event that the files are sufficiently large that storing them both causes a memory problem, you can trade CPU for memory by storing only file1 and deleting matches along the way as file2 is read.</p>

<pre class=""lang-pl prettyprint-override""><code>BEGIN { FS="""" }
(NR==FNR) {  # file1, index by lineno and string
  ll1[FNR]=$0; ss1[$0]=FNR; nl1=FNR;
}
(NR!=FNR) {  # file2
  if ($0 in ss1) { delete ll1[ss1[$0]]; delete ss1[$0]; }
}
END {
  for (ll=1; ll&lt;=nl1; ll++) if (ll in ll1) print ll1[ll]
}
</code></pre>

<p>The above stores the entire contents of file1 in two arrays, one indexed by line number <code>ll1[]</code>, one indexed by line content <code>ss1[]</code>. Then as file2 is read, each matching line is deleted from <code>ll1[]</code> and <code>ss1[]</code>. At the end the remaining lines from file1 are output, preserving the original order.</p>

<p>In this case, with the problem as stated, you can also <em>divide and conquer</em> using GNU <code>split</code> (filtering is a GNU extension), repeated runs with chunks of file1 and reading file2 completely each time:</p>

<pre><code>split -l 20000 --filter='gawk -f linesnotin.awk - file2' &lt; file1
</code></pre>

<p>Note the use and placement of <code>-</code> meaning <code>stdin</code> on the <code>gawk</code> command line. This is provided by <code>split</code> from file1 in chunks of 20000 line per-invocation.</p>

<p>For users on non-GNU systems, there is almost certainly a GNU coreutils package you can obtain, including on OSX as part of the <a href=""https://developer.apple.com/xcode/features/"" rel=""noreferrer"">Apple Xcode</a> tools which provides GNU <code>diff</code>, <code>awk</code>, though only a POSIX/BSD <code>split</code> rather than a GNU version.</p>
"
"Select objects based on value of variable in object using jq","18592173","<json><bash><select><jq>","272","<p>Adapted from this post on <a href=""https://zerokspot.com/weblog/2013/07/18/processing-json-with-jq/"" rel=""noreferrer"">Processing JSON with jq</a>, you can use the <a href=""https://stedolan.github.io/jq/manual/#select(boolean_expression)"" rel=""noreferrer""><code>select(bool)</code></a> like this:</p>

<pre class=""lang-sh prettyprint-override""><code>$ jq '.[] | select(.location==""Stockholm"")' json
{
  ""location"": ""Stockholm"",
  ""name"": ""Walt""
}
{
  ""location"": ""Stockholm"",
  ""name"": ""Donald""
}
</code></pre>
"
"How to find whether or not a variable is empty in Bash?","3061036","<bash><shell><is-empty>","271","<p>In Bash at least the following command tests <strong>if $var is empty</strong>:</p>

<pre><code>if [[ -z ""$var"" ]]; then
   # Do what you want
fi
</code></pre>

<p>The command <code>man test</code> is your friend.</p>
"
"How do I run a shell script without using ""sh"" or ""bash"" commands?","8779951","<bash><shell><alias><sh>","271","<p>Add a ""shebang"" at the top of your file:</p>

<pre><code>#!/bin/bash
</code></pre>

<p>And make your file executable (<code>chmod +x script.sh</code>).</p>

<p>Finally, modify your path to add the directory where your script is located:</p>

<pre><code>export PATH=$PATH:/appropriate/directory
</code></pre>

<p>(typically, you want <code>$HOME/bin</code> for storing your own scripts)</p>
"
"Test if a command outputs an empty string","12137431","<bash><shell>","269","<p><sub>Previously, the question asked how to check whether there are files in a directory.  The following code achieves that, but see <a href=""https://stackoverflow.com/a/35165216/58635"">rsp's answer</a> for a better solution.</sub></p>

<hr>

<h2>Empty output</h2>

<p>Commands don’t <em>return</em> values – they output them. You can capture this output by using <em><a href=""http://mywiki.wooledge.org/CommandSubstitution"" rel=""noreferrer"">command substitution</a></em>; e.g. <code>$(ls -A)</code>. You can test for a non-empty string in Bash like this:</p>

<pre><code>if [[ $(ls -A) ]]; then
    echo ""there are files""
else
    echo ""no files found""
fi
</code></pre>

<p>Note that I've used <code>-A</code> rather than <code>-a</code>, since it omits the symbolic current (<code>.</code>) and parent (<code>..</code>) directory entries.</p>

<p><strong>Note:</strong> As pointed out in the comments, command substitution <strong>doesn't capture trailing newlines</strong>.  Therefore, if the command outputs <em>only</em> newlines, the substitution will capture nothing and the test will return false.  While very unlikely, this is possible in the above example, since a single newline is a valid filename!  More information in <a href=""https://stackoverflow.com/a/15184414/58635"">this answer</a>.</p>

<hr>

<h2>Exit code</h2>

<p>If you want to check that the command completed successfully, you can inspect <code>$?</code>, which contains the exit code of the last command (zero for success, non-zero for failure). For example:</p>

<pre><code>files=$(ls -A)
if [[ $? != 0 ]]; then
    echo ""Command failed.""
elif [[ $files ]]; then
    echo ""Files found.""
else
    echo ""No files found.""
fi
</code></pre>

<p>More info <a href=""http://www.tldp.org/LDP/abs/html/exit-status.html"" rel=""noreferrer"">here</a>.</p>
"
"How to detect if my shell script is running through a pipe?","911168","<bash><shell><pipe>","268","<p>In a pure POSIX shell,</p>

<pre><code>if [ -t 1 ] ; then echo terminal; else echo ""not a terminal""; fi
</code></pre>

<p>returns ""terminal"", because the output is sent to your terminal, whereas </p>

<pre><code>(if [ -t 1 ] ; then echo terminal; else echo ""not a terminal""; fi) | cat
</code></pre>

<p>returns ""not a terminal"", because the output of the parenthetic is piped to <code>cat</code>.</p>

<hr>

<p>The <code>-t</code> flag is described in man pages as</p>

<blockquote>
  <p>-t fd  True if file descriptor fd is open and refers to a terminal.</p>
</blockquote>

<p>... where <code>fd</code> can be one of the usual file descriptor assignments:</p>

<pre><code>0:     stdin  
1:     stdout  
2:     stderr
</code></pre>
"
"How does one output bold text in Bash?","2924697","<bash><console><formatting><echo>","268","<p>The most compatible way of doing this is using <code>tput</code> to discover the right sequences to send to the terminal:</p>

<pre><code>bold=$(tput bold)
normal=$(tput sgr0)
</code></pre>

<p>then you can use the variables <code>$bold</code> and <code>$normal</code> to format things:</p>

<pre><code>echo ""this is ${bold}bold${normal} but this isn't""
</code></pre>

<p>gives</p>

<blockquote>
  <p>this is <strong>bold</strong> but this isn't</p>
</blockquote>
"
"How to get the start time of a long-running Linux process?","5731234","<linux><bash><process>","267","<p>You can specify a formatter and use <code>lstart</code>, like this command:</p>

<pre><code>ps -eo pid,lstart,cmd
</code></pre>

<p>The above command will output all processes, with formatters to get PID, command run, and date+time started.</p>

<p>Example (from Debian/Jessie command line)</p>

<pre><code>$ ps -eo pid,lstart,cmd
  PID CMD                                          STARTED
    1 Tue Jun  7 01:29:38 2016 /sbin/init                  
    2 Tue Jun  7 01:29:38 2016 [kthreadd]                  
    3 Tue Jun  7 01:29:38 2016 [ksoftirqd/0]               
    5 Tue Jun  7 01:29:38 2016 [kworker/0:0H]              
    7 Tue Jun  7 01:29:38 2016 [rcu_sched]                 
    8 Tue Jun  7 01:29:38 2016 [rcu_bh]                    
    9 Tue Jun  7 01:29:38 2016 [migration/0]               
   10 Tue Jun  7 01:29:38 2016 [kdevtmpfs]                 
   11 Tue Jun  7 01:29:38 2016 [netns]                     
  277 Tue Jun  7 01:29:38 2016 [writeback]                 
  279 Tue Jun  7 01:29:38 2016 [crypto]                    
      ...
</code></pre>

<p>You can read <code>ps</code>'s manpage or <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/"" rel=""noreferrer"">check Opengroup's page</a> for the other formatters.</p>
"
"How can I use "":"" as an AWK field separator?","2609552","<bash><awk>","266","<p>&quot;-F&quot; is a command line argument, not AWK syntax. Try:</p>
<pre><code> echo &quot;1: &quot; | awk -F  &quot;:&quot; '/1/ {print $1}'
</code></pre>
"
"How can I ssh directly to a particular directory?","626533","<bash><shell><scripting><ssh>","266","<p>You can do the following:</p>
<pre><code>ssh -t xxx.xxx.xxx.xxx &quot;cd /directory_wanted ; bash --login&quot;
</code></pre>
<p>This way, you will get a login shell right on the directory_wanted.</p>
<hr />
<p>Explanation</p>
<blockquote>
<p><code>-t</code> Force pseudo-terminal allocation.  This can be used to execute arbitrary screen-based programs on a remote machine, which can be very useful, e.g. when implementing menu services.</p>
<p>Multiple <code>-t</code> options force tty allocation, even if ssh has no local tty.</p>
</blockquote>
<ul>
<li>If you don't use <code>-t</code> then no prompt will appear.</li>
<li>If you don't add <code>; bash</code> then the connection will get closed and return control to your local machine</li>
<li>If you don't add <code>bash --login</code> then it will not use your configs because its not a login shell</li>
</ul>
"
"How to use 'find' to search for files created on a specific date?","158044","<bash><unix><find>","264","<p>As pointed out by Max, you can't, but checking files modified or accessed is not all that hard.  I wrote a <a href=""http://virtuelvis.com/2008/10/how-to-use-find-to-search-for-files-created-on-a-specific-date/"" rel=""noreferrer"">tutorial</a> about this, as late as today. The essence of which is to use <code>-newerXY</code> and <code>! -newerXY</code>:</p>

<p>Example: To find all files modified on the 7th of June, 2007:</p>

<pre><code>$ find . -type f -newermt 2007-06-07 ! -newermt 2007-06-08
</code></pre>

<p>To find all files accessed on the 29th of september, 2008:</p>

<pre><code>$ find . -type f -newerat 2008-09-29 ! -newerat 2008-09-30
</code></pre>

<p>Or, files which had their permission changed on the same day:</p>

<pre><code>$ find . -type f -newerct 2008-09-29 ! -newerct 2008-09-30
</code></pre>

<p>If you don't change permissions on the file, 'c' would normally correspond to the creation date, though.</p>
"
"Can I change the name of `nohup.out`?","4549489","<bash><logging><nohup>","264","<pre><code>nohup some_command &amp;&gt; nohup2.out &amp;
</code></pre>

<p>and voila.</p>

<hr>

<p>Older syntax for Bash version &lt; 4:</p>

<pre><code>nohup some_command &gt; nohup2.out 2&gt;&amp;1 &amp;
</code></pre>
"
"Checking Bash exit status of several commands efficiently","5195607","<bash><exit>","263","<p>You can write a function that launches and tests the command for you. Assume <code>command1</code> and <code>command2</code> are environment variables that have been set to a command.</p>

<pre><code>function mytest {
    ""$@""
    local status=$?
    if (( status != 0 )); then
        echo ""error with $1"" &gt;&amp;2
    fi
    return $status
}

mytest ""$command1""
mytest ""$command2""
</code></pre>
"
"How can I convert tabs to spaces in every file of a directory?","11094383","<bash><shell><unix><spaces><in-place>","263","<blockquote>
<h2>Warning: This will break your repo.</h2>
<p>This <strong>will corrupt binary files</strong>, including those under <code>svn</code>, <code>.git</code>! Read the comments before using!</p>
</blockquote>
<p><code>find . -iname '*.java' -type f -exec sed -i.orig 's/\t/    /g' {} +</code></p>
<p>The original file is saved as <code>[filename].orig</code>.</p>
<p>Replace '*.java' with the file ending of the file type you are looking for. This way you can prevent accidental corruption of binary files.</p>
<p>Downsides:</p>
<ul>
<li>Will replace tabs everywhere in a file.</li>
<li>Will take a long time if you happen to have a 5GB SQL dump in this directory.</li>
</ul>
"
"How can I print each command before executing?","5750450","<bash>","263","<pre><code>set -o xtrace
</code></pre>

<p>or</p>

<pre><code>bash -x myscript.sh
</code></pre>

<p><em>This works with standard /bin/sh as well IIRC (it might be a POSIX thing then)</em></p>

<p>And remember, there is <a href=""http://bashdb.sourceforge.net"" rel=""noreferrer""><strong>bashdb</strong></a> (<code>bash Shell Debugger, release 4.0-0.4</code>)</p>

<hr>

<p>To revert to normal, exit the subshell or</p>

<pre><code>set +o xtrace
</code></pre>
"
"How to simulate the environment cron executes a script with?","2135478","<bash><scripting><cron>","262","<p>Add this to your crontab (temporarily):</p>

<pre><code>* * * * * env &gt; ~/cronenv
</code></pre>

<p>After it runs, do this:</p>

<pre><code>env - `cat ~/cronenv` /bin/sh
</code></pre>

<p>This assumes that your cron runs /bin/sh, which is the default regardless of the user's default shell.</p>
"
"Shell script - remove first and last quote ("") from a variable","9733338","<string><bash><shell><unix><sed>","260","<p>There's a simpler and more efficient way, using the native shell prefix/suffix removal feature:</p>

<pre><code>temp=""${opt%\""}""
temp=""${temp#\""}""
echo ""$temp""
</code></pre>

<p><code>${opt%\""}</code> will remove the suffix <code>""</code> (escaped with a backslash to prevent shell interpretation).</p>

<p><code>${temp#\""}</code> will remove the prefix <code>""</code> (escaped with a backslash to prevent shell interpretation).</p>

<p>Another advantage is that it will remove surrounding quotes only if there are surrounding quotes.</p>

<p>BTW, your solution always removes the first and last character, whatever they may be (of course, I'm sure you know your data, but it's always better to be sure of what you're removing).</p>

<p>Using sed:</p>

<pre><code>echo ""$opt"" | sed -e 's/^""//' -e 's/""$//'
</code></pre>

<p><strong>(Improved version, as indicated by jfgagne, getting rid of echo)</strong></p>

<pre><code>sed -e 's/^""//' -e 's/""$//' &lt;&lt;&lt;""$opt""
</code></pre>

<p>So it replaces a leading <code>""</code> with nothing, and a trailing <code>""</code> with nothing too. In the same invocation (there isn't any need to pipe and start another sed. Using <code>-e</code> you can have multiple text processing).</p>
"
"How to read from a file or STDIN in Bash?","6980090","<bash><stdin>","260","<p>The following solution reads from a file if the script is called
with a file name as the first parameter <code>$1</code> otherwise from standard input.    </p>

<pre><code>while read line
do
  echo ""$line""
done &lt; ""${1:-/dev/stdin}""
</code></pre>

<p>The substitution <code>${1:-...}</code> takes <code>$1</code> if defined otherwise
the file name of the standard input of the own process is used.</p>
"
"Run git pull over all subdirectories","3497123","<git><bash>","258","<p>Run the following from the parent directory, <code>plugins</code> in this case:</p>

<pre><code>find . -type d -depth 1 -exec git --git-dir={}/.git --work-tree=$PWD/{} pull origin master \;
</code></pre>

<p>To clarify:</p>

<ul>
<li><code>find .</code> searches the current directory</li>
<li><code>-type d</code> to find directories, not files</li>
<li><code>-depth 1</code> for a maximum depth of one sub-directory</li>
<li><code>-exec {} \;</code> runs a custom command for every find</li>
<li><code>git --git-dir={}/.git --work-tree=$PWD/{} pull</code> git pulls the individual directories</li>
</ul>

<p>To play around with find, I recommend using <code>echo</code> after <code>-exec</code> to preview, e.g.:</p>

<pre><code>find . -type d -depth 1 -exec echo git --git-dir={}/.git --work-tree=$PWD/{} status \;
</code></pre>

<p>Note: if the <code>-depth 1</code> option is not available, try <code>-mindepth 1 -maxdepth 1</code>.</p>
"
"How can you run a command in bash over and over until success?","5274294","<bash><command><while-loop>","257","<pre><code>until passwd
do
  echo ""Try again""
done
</code></pre>

<p>or</p>

<pre><code>while ! passwd
do
  echo ""Try again""
done
</code></pre>
"
"How can I repeat a character in Bash?","5349718","<bash><shell><echo>","256","<p>You can use:</p>

<pre><code>printf '=%.0s' {1..100}
</code></pre>

<p>How this works:</p>

<p>Bash expands {1..100} so the command becomes:</p>

<pre><code>printf '=%.0s' 1 2 3 4 ... 100
</code></pre>

<p>I've set printf's format to <code>=%.0s</code> which means that it will always print a single <code>=</code> no matter what argument it is given. Therefore it prints 100 <code>=</code>s.</p>
"
"What's the difference between nohup and ampersand","15595374","<linux><bash><nohup>","256","<p><code>nohup</code> catches the hangup signal (see <code>man 7 signal</code>) while the ampersand doesn't (except the shell is confgured that way or doesn't send <code>SIGHUP</code> at all).</p>

<p>Normally, when running a command using <code>&amp;</code> and exiting the shell afterwards, the shell will terminate the sub-command with the hangup signal (<code>kill -SIGHUP &lt;pid&gt;</code>). This can be prevented using <code>nohup</code>, as it catches the signal and ignores it so that it never reaches the actual application. </p>

<p>In case you're using bash, you can use the command <code>shopt | grep hupon</code> to find out whether
your shell sends SIGHUP to its child processes or not. If it is off, processes won't be 
terminated, as it seems to be the case for you. More information on how bash terminates
applications can be found <a href=""https://stackoverflow.com/questions/4298741/how-bash-handles-the-jobs-when-logout"">here</a>.</p>

<p>There are cases where <code>nohup</code> does not work, for example when the process you start reconnects
the <code>SIGHUP</code> signal, as it is the case <a href=""https://stackoverflow.com/questions/12486691/how-do-i-get-my-golang-web-server-to-run-in-the-background/12486810#12486810"">here</a>.</p>
"
"How do I use floating-point division in bash?","12722095","<bash><floating-point><arithmetic-expressions>","255","<p>You can't. bash <em>only</em> does integers; you <em>must</em> delegate to a tool such as <code>bc</code>.</p>
"
"How to recursively find the latest modified file in a directory?","4561895","<bash><filesystems><find>","253","<pre><code>find . -type f -printf '%T@ %p\n' \
| sort -n | tail -1 | cut -f2- -d&quot; &quot;
</code></pre>
<p>For a huge tree, it might be hard for <code>sort</code> to keep everything in memory.</p>
<p><code>%T@</code> gives you the modification time like a unix timestamp, <code>sort -n</code> sorts numerically, <code>tail -1</code> takes the last line (highest timestamp), <code>cut -f2 -d&quot; &quot;</code> cuts away the first field (the timestamp) from the output.</p>
<p><strong>Edit:</strong> Just as <code>-printf</code> is probably GNU-only, ajreals usage of <code>stat -c</code> is too. Although it is possible to do the same on BSD, the options for formatting is different (<code>-f &quot;%m %N&quot;</code> it would seem)</p>
<p>And I missed the part of plural; if you want more then <em>the</em> latest file, just bump up the tail argument.</p>
"
"Select unique or distinct values from a list in UNIX shell script","618378","<bash><unique><distinct><ksh><sh>","251","<p>You might want to look at the <code>uniq</code> and <code>sort</code> applications.</p>

<pre>
./yourscript.ksh | sort | uniq
</pre>

<p>(FYI, yes, the sort is necessary in this command line, <code>uniq</code> only strips duplicate lines that are immediately after each other)</p>

<p><strong>EDIT:</strong></p>

<p>Contrary to what has been posted by <a href=""https://stackoverflow.com/questions/618378/select-unique-or-distinct-values-from-a-list-in-unix-shell-script/618382#618382"">Aaron Digulla</a> in relation to <code>uniq</code>'s commandline options:</p>

<p>Given the following input:</p>

<pre>
class
jar
jar
jar
bin
bin
java
</pre>

<p><code>uniq</code> will output all lines exactly once:</p>

<pre>
class
jar
bin
java
</pre>

<p><code>uniq -d</code> will output all lines that appear more than once, and it will print them once:</p>

<pre>
jar
bin
</pre>

<p><code>uniq -u</code> will output all lines that appear exactly once, and it will print them once:</p>

<pre>
class
java
</pre>
"
"What is a unix command for deleting the first N characters of a line?","971879","<bash><unix><command><truncate>","251","<p>Use <code>cut</code>.  Eg. to strip the first 4 characters of each line (i.e. start on the 5th char):</p>

<pre><code>tail -f logfile | grep org.springframework | cut -c 5-
</code></pre>
"
"""unary operator expected"" error in Bash if condition","13617843","<bash><shell>","251","<p>If you know you're always going to use bash, it's much easier to always use the double bracket conditional compound command <code>[[ ... ]]</code>, instead of the Posix-compatible  single bracket version <code>[ ... ]</code>. Inside a <code>[[ ... ]]</code> compound, word-splitting and pathname expansion are not applied to words, so you can rely on</p>

<pre><code>if [[ $aug1 == ""and"" ]];
</code></pre>

<p>to compare the value of <code>$aug1</code> with the string <code>and</code>.</p>

<p>If you use <code>[ ... ]</code>, you always need to remember to double quote variables like this:</p>

<pre><code>if [ ""$aug1"" = ""and"" ];
</code></pre>

<p>If you don't quote the variable expansion and the variable is undefined or empty, it vanishes from the scene of the crime, leaving only</p>

<pre><code>if [ = ""and"" ]; 
</code></pre>

<p>which is not a valid syntax. (It would also fail with a different error message if <code>$aug1</code> included white space or shell metacharacters.)</p>

<p>The modern <code>[[</code> operator has lots of other nice features, including regular expression matching.</p>
"
"Git doesn't work on MacOS Catalina: ""xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing""","58280652","<bash><git><macos><zsh><macos-catalina>","250","<p>You'll need to reinstall the command line tools:</p>

<pre><code>$ xcode-select --install
</code></pre>
"
"Renaming files in a folder to sequential numbers","3211595","<bash><rename><batch-rename>","250","<p>Try to use a loop, <code>let</code>, and <code>printf</code> for the padding:</p>

<pre><code>a=1
for i in *.jpg; do
  new=$(printf ""%04d.jpg"" ""$a"") #04 pad to length of 4
  mv -i -- ""$i"" ""$new""
  let a=a+1
done
</code></pre>

<p>using the <code>-i</code> flag prevents automatically overwriting existing files.</p>
"
"Docker: How to use bash with an Alpine based docker image?","40944479","<bash><docker><dockerfile><alpine>","250","<p>Alpine docker image doesn't have bash installed by default. You will need to add following commands to get <code>bash</code>:</p>

<pre><code>RUN apk update &amp;&amp; apk add bash
</code></pre>

<p>If youre using <code>Alpine 3.3+</code> then you can just do</p>

<pre><code>RUN apk add --no-cache bash
</code></pre>

<p>to keep docker image size small. (Thanks to comment from @sprkysnrky)</p>
"
"How to write multiple line string using Bash with variables?","7875540","<linux><bash><bash4>","248","<p>The syntax (<code>&lt;&lt;&lt;</code>) and the command used (<code>echo</code>) is wrong.</p>

<p>Correct would be:</p>

<pre><code>#!/bin/bash

kernel=""2.6.39""
distro=""xyz""
cat &gt;/etc/myconfig.conf &lt;&lt;EOL
line 1, ${kernel}
line 2, 
line 3, ${distro}
line 4 line
... 
EOL

cat /etc/myconfig.conf
</code></pre>

<p>This construction is referred to as a <a href=""https://en.wikipedia.org/wiki/Here_document"" rel=""noreferrer"">Here Document</a> and can be found in the Bash man pages under <code>man --pager='less -p ""\s*Here Documents""' bash</code>.</p>
"
"Test whether a glob has any matches in bash","2937407","<bash><glob>","248","<blockquote>
  <p><strong>Bash</strong> specific solution:</p>
</blockquote>

<pre><code>compgen -G ""&lt;glob-pattern&gt;""
</code></pre>

<p>Escape the pattern or it'll get pre-expanded into matches.  </p>

<p>Exit status is:</p>

<ul>
<li>1 for no-match, </li>
<li>0 for 'one or more matches'</li>
</ul>

<p><code>stdout</code> is a list of <strong>files matching the glob</strong>.<br>
I think this is the best option in terms of conciseness and minimizing potential side effects.</p>

<p><strong>UPDATE</strong>: Example usage requested.</p>

<pre><code>if compgen -G ""/tmp/someFiles*"" &gt; /dev/null; then
    echo ""Some files exist.""
fi
</code></pre>
"
"if arguments is equal to this string, define a variable like this string","9727695","<bash><scripting><arguments>","247","<p>Don't forget about spaces:</p>

<pre><code>source=""""
samples=("""")
if [ $1 = ""country"" ]; then
   source=""country""
   samples=""US Canada Mexico...""
else
  echo ""try again""
fi
</code></pre>
"
"How to pipe stdout while keeping it on screen ? (and not to a output file)","5677201","<bash><shell><pipe><output><stdout>","246","<p>Here is a solution that works at on any Unix / Linux implementation, assuming it cares to follow the <code>POSIX</code> standard. It works on some non Unix environments like <code>cygwin</code> too.</p>

<pre><code>echo 'ee' | tee /dev/tty | foo
</code></pre>

<p>Reference:  <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/"" rel=""noreferrer"">The Open Group Base Specifications Issue 7
IEEE Std 1003.1, 2013 Edition, §10.1</a>:</p>

<blockquote>
  <p><strong>/dev/tty</strong></p>
  
  <p>Associated with the process group of that process, if any. <strong>It is
  useful for programs or shell procedures that wish to be sure of
  writing messages to</strong> or reading data from <strong>the terminal no matter how
  output has been redirected.</strong> It can also be used for applications that
  demand the name of a file for output, when typed output is desired and
  it is tiresome to find out what terminal is currently in use. In each process, a synonym for the controlling terminal</p>
</blockquote>

<p>Some environments like Google Colab have been reported not to implement <code>/dev/tty</code> while still having their <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/"" rel=""noreferrer""><code>tty</code></a> command returning a usable device. Here is a workaround:</p>

<pre><code>tty=$(tty)
echo 'ee' | tee $tty | foo
</code></pre>

<p>or with an ancient Bourne shell:  </p>

<pre><code>tty=`tty`
echo 'ee' | tee $tty | foo
</code></pre>
"
"Best way to simulate ""group by"" from bash?","380817","<bash><scripting>","246","<pre><code>sort ip_addresses | uniq -c
</code></pre>

<p>This will print the count first, but other than that it should be exactly what you want.</p>
"
"How to place the ~/.composer/vendor/bin directory in your PATH?","25373188","<bash><laravel><path>","246","<p>To put this folder on the PATH environment variable type</p>

<pre><code>export PATH=""$PATH:$HOME/.composer/vendor/bin""
</code></pre>

<p>This appends the folder to your existing PATH, however, it is only active for your current terminal session.</p>

<p>If you want it to be automatically set, it depends on the shell you are using. For bash, you can append this line to <code>$HOME/.bashrc</code> using your favorite editor or type the following on the shell</p>

<pre><code>echo 'export PATH=""$PATH:$HOME/.composer/vendor/bin""' &gt;&gt; ~/.bashrc
</code></pre>

<p>In order to check if it worked, logout and login again or execute</p>

<pre><code>source ~/.bashrc
</code></pre>

<p>on the shell.</p>

<p>PS: For other systems where there is no <code>~/.bashrc</code>, you can also put this into <code>~/.bash_profile</code></p>

<p>PSS: For more recent laravel you need to put <code>$HOME/.config/composer/vendor/bin</code> on the <code>PATH</code>.</p>

<p>PSSS: If you want to put this folder on the path also for other shells or on the GUI, you should append the said <code>export</code> command to <code>~/.profile</code> (cf. <a href=""https://help.ubuntu.com/community/EnvironmentVariables"" rel=""noreferrer"">https://help.ubuntu.com/community/EnvironmentVariables</a>).</p>
"
"Get last dirname/filename in a file path argument in Bash","3294072","<linux><bash><shell><svn>","245","<p><a href=""http://swoolley.org/man.cgi/basename"" rel=""noreferrer""><code>basename</code></a> does remove the directory prefix of a path:</p>

<pre><code>$ basename /usr/local/svn/repos/example
example
$ echo ""/server/root/$(basename /usr/local/svn/repos/example)""
/server/root/example
</code></pre>
"
"""find: paths must precede expression:"" How do I specify a recursive search that also finds files in the current directory?","6495501","<linux><bash><find>","245","<p>Try putting it in quotes -- you're running into the shell's wildcard expansion, so what you're acually passing to find will look like:</p>

<pre><code>find . -name bobtest.c cattest.c snowtest.c
</code></pre>

<p>...causing the syntax error. So try this instead:</p>

<pre><code>find . -name '*test.c'
</code></pre>

<p>Note the single quotes around your file expression -- these will stop the shell (bash) expanding your wildcards.</p>
"
"How to exit if a command failed?","3822621","<linux><bash><exit><exitstatus>","245","<p>Try:</p>

<pre><code>my_command || { echo 'my_command failed' ; exit 1; }
</code></pre>

<p>Four changes:</p>

<ul>
<li>Change <code>&amp;&amp;</code> to <code>||</code></li>
<li>Use <code>{ }</code> in place of <code>( )</code></li>
<li>Introduce <code>;</code> after <code>exit</code> and</li>
<li>spaces after <code>{</code> and before <code>}</code></li>
</ul>

<p>Since you want to print the message and exit only when the command fails ( exits with non-zero value) you need a <code>||</code> not an <code>&amp;&amp;</code>.</p>

<pre><code>cmd1 &amp;&amp; cmd2
</code></pre>

<p>will run <code>cmd2</code> when <code>cmd1</code> succeeds(exit value <code>0</code>). Where as</p>

<pre><code>cmd1 || cmd2
</code></pre>

<p>will run <code>cmd2</code> when <code>cmd1</code> fails(exit value non-zero).</p>

<p>Using <code>( )</code> makes the command inside them run in a <strong><em>sub-shell</em></strong> and calling a <code>exit</code> from there causes you to exit the sub-shell and not your original shell, hence execution continues in your original shell.</p>

<p>To overcome this use <code>{ }</code></p>

<p>The last two changes are required by bash.</p>
"
"Print array elements on separate lines in Bash?","15691942","<arrays><bash>","245","<p>Try doing this :</p>

<pre><code>$ printf '%s\n' ""${my_array[@]}""
</code></pre>

<p>The difference between <code>$@</code> and <code>$*</code>:</p>

<ul>
<li><p>Unquoted, the results are unspecified. In Bash, both expand to separate args
and then wordsplit and globbed.</p></li>
<li><p>Quoted, <code>""$@""</code> expands each element as a separate argument, while <code>""$*""</code>
expands to the args merged into one argument: <code>""$1c$2c...""</code> (where <code>c</code> is
the first char of <code>IFS</code>).</p></li>
</ul>

<p>You almost always want <code>""$@""</code>. Same goes for <code>""${arr[@]}""</code>.</p>

<p><strong>Always quote them!</strong></p>
"
"What is the Linux equivalent to DOS pause?","92802","<linux><bash><shell>","244","<p><code>read</code> does this:</p>

<pre><code>user@host:~$ read -n1 -r -p ""Press any key to continue..."" key
[...]
user@host:~$ 
</code></pre>

<p>The <code>-n1</code> specifies that it only waits for a single character. The <code>-r</code> puts it into raw mode, which is necessary because otherwise, if you press something like backslash, it doesn't register until you hit the next key.  The <code>-p</code> specifies the prompt, which must be quoted if it contains spaces.  The <code>key</code> argument is only necessary if you want to know which key they pressed, in which case you can access it through <code>$key</code>.</p>

<p>If you are using Bash, you can also specify a timeout with <code>-t</code>, which causes read to return a failure when a key isn't pressed. So for example:</p>

<pre><code>read -t5 -n1 -r -p 'Press any key in the next five seconds...' key
if [ ""$?"" -eq ""0"" ]; then
    echo 'A key was pressed.'
else
    echo 'No key was pressed.'
fi
</code></pre>
"
"How to list running screen sessions?","537942","<linux><bash><command-line><gnu-screen>","243","<p>To list all of the screen sessions for a user, run the following command as that user:</p>

<pre><code>screen -ls
</code></pre>

<p>To see all screen sessions on a specific machine you can do:</p>

<pre><code>ls -laR /var/run/screen/
</code></pre>

<p>I get this on my machine:</p>

<pre><code>gentle ~ # ls -laR /var/run/screen/

/var/run/screen/:
total 1
drwxrwxr-x  4 root utmp   96 Mar  1  2005 .
drwxr-xr-x 10 root root  840 Feb  1 03:10 ..
drwx------  2 josh users  88 Jan 13 11:33 S-josh
drwx------  2 root root   48 Feb 11 10:50 S-root

/var/run/screen/S-josh:
total 0
drwx------ 2 josh users 88 Jan 13 11:33 .
drwxrwxr-x 4 root utmp  96 Mar  1  2005 ..
prwx------ 1 josh users  0 Feb 11 10:41 12931.pts-0.gentle

/var/run/screen/S-root:
total 0
drwx------ 2 root root 48 Feb 11 10:50 .
drwxrwxr-x 4 root utmp 96 Mar  1  2005 ..
</code></pre>

<p>This is a rather brilliantly Unixy use of Unix Sockets wrapped in filesystem permissions to handle security, state, and streams.</p>
"
"Replace one character with another in Bash","5928156","<string><bash><replace>","243","<p>Use inline shell string replacement. Example:</p>

<pre><code>foo=""  ""

# replace first blank only
bar=${foo/ /.}

# replace all blanks
bar=${foo// /.}
</code></pre>

<p>See <a href=""http://tldp.org/LDP/abs/html/string-manipulation.html"">http://tldp.org/LDP/abs/html/string-manipulation.html</a> for more details.</p>
"
"How to implement common bash idioms in Python?","209470","<python><bash><shell>","242","<p>Any shell has several sets of features.</p>
<ul>
<li><p>The Essential Linux/Unix commands.  All of these are available through the <a href=""https://docs.python.org/3/library/subprocess.html"" rel=""noreferrer"">subprocess</a> library.  This isn't always the best first choice for doing <em>all</em> external commands.  Look also at <a href=""https://docs.python.org/3/library/shutil.html"" rel=""noreferrer"">shutil</a> for some commands that are separate Linux commands, but you could probably implement directly in your Python scripts.  Another huge batch of Linux commands are in the <a href=""https://docs.python.org/3/library/os.html"" rel=""noreferrer"">os</a> library; you can do these more simply in Python.</p>
<p>And -- bonus! -- more quickly.  Each separate Linux command in the shell (with a few exceptions) forks a subprocess.  By using Python <code>shutil</code> and <code>os</code> modules, you don't fork a subprocess.</p>
</li>
<li><p>The shell environment features.  This includes stuff that sets a command's environment (current directory and environment variables and what-not).  You can easily manage this from Python directly.</p>
</li>
<li><p>The shell programming features.  This is all the process status code checking, the various logic commands (if, while, for, etc.) the test command and all of it's relatives.  The function definition stuff.  This is all much, much easier in Python.  This is one of the huge victories in getting rid of bash and doing it in Python.</p>
</li>
<li><p>Interaction features.  This includes command history and what-not.  You don't need this for writing shell scripts.  This is only for human interaction, and not for script-writing.</p>
</li>
<li><p>The shell file management features.  This includes redirection and pipelines.  This is trickier.  Much of this can be done with subprocess.  But some things that are easy in the shell are unpleasant in Python.  Specifically stuff like <code>(a | b; c ) | something &gt;result</code>.  This runs two processes in parallel (with output of <code>a</code> as input to <code>b</code>), followed by a third process.  The output from that sequence is run in parallel with <code>something</code> and the output is collected into a file named <code>result</code>.  That's just complex to express in any other language.</p>
</li>
</ul>
<p>Specific programs (awk, sed, grep, etc.) can often be rewritten as Python modules.  Don't go overboard.  Replace what you need and evolve your &quot;grep&quot; module.  Don't start out writing a Python module that replaces &quot;grep&quot;.</p>
<p>The best thing is that you can do this in steps.</p>
<ol>
<li>Replace AWK and PERL with Python.  Leave everything else alone.</li>
<li>Look at replacing GREP with Python.  This can be a bit more complex, but your version of GREP can be tailored to your processing needs.</li>
<li>Look at replacing FIND with Python loops that use <code>os.walk</code>.  This is a big win because you don't spawn as many processes.</li>
<li>Look at replacing common shell logic (loops, decisions, etc.) with Python scripts.</li>
</ol>
"
"How to calculate time elapsed in bash script?","8903239","<bash><date>","241","<p>Bash has a handy <code>SECONDS</code> builtin variable that tracks the number of seconds that have passed since the shell was started. This variable retains its properties when assigned to, and the value returned after the assignment is the number of seconds since the assignment plus the assigned value.</p>

<p>Thus, you can just set <code>SECONDS</code> to 0 before starting the timed event, simply read <code>SECONDS</code> after the event, and do the time arithmetic before displaying.</p>

<pre><code>SECONDS=0
# do some work
duration=$SECONDS
echo ""$(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed.""
</code></pre>

<p>As this solution doesn't depend on <code>date +%s</code> (which is a GNU extension), it's portable to all systems supported by Bash.</p>
"
"How to create a temporary directory?","4632028","<bash><temporary-directory>","241","<p>Use <a href=""http://www.mktemp.org/"" rel=""noreferrer""><code>mktemp -d</code></a>. It creates a temporary directory with a random name and makes sure that file doesn't already exist. You need to remember to delete the directory after using it though.</p>
"
"How to detect if a script is being sourced","2683279","<bash><ksh>","241","<p>This seems to be portable between Bash and Korn:</p>

<pre><code>[[ $_ != $0 ]] &amp;&amp; echo ""Script is being sourced"" || echo ""Script is a subshell""
</code></pre>

<p>A line similar to this or an assignment like <code>pathname=""$_""</code> (with a later test and action) must be on the first line of the script or on the line after the shebang (which, if used, should be for ksh in order for it to work under the most circumstances).</p>
"
"How do I write a bash script to restart a process if it dies?","696839","<bash><scripting><cron>","240","<p>Avoid PID-files, crons, or anything else that tries to evaluate processes that aren't their children.</p>

<p>There is a very good reason why in UNIX, you can ONLY wait on your children.  Any method (ps parsing, pgrep, storing a PID, ...) that tries to work around that is flawed and has gaping holes in it.  Just say <strong>no</strong>.</p>

<p>Instead you need the process that monitors your process to be the process' parent.  What does this mean?  It means only the process that <em>starts</em> your process can reliably wait for it to end.  In bash, this is absolutely trivial.</p>

<pre><code>until myserver; do
    echo ""Server 'myserver' crashed with exit code $?.  Respawning.."" &gt;&amp;2
    sleep 1
done
</code></pre>

<p>The above piece of bash code runs <code>myserver</code> in an <code>until</code> loop.  The first line starts <code>myserver</code> and waits for it to end.  When it ends, <code>until</code> checks its exit status.  If the exit status is <code>0</code>, it means it ended gracefully (which means you asked it to shut down somehow, and it did so successfully).  In that case we don't want to restart it (we just asked it to shut down!).  If the exit status is <em>not</em> <code>0</code>, <code>until</code> will run the loop body, which emits an error message on STDERR and restarts the loop (back to line 1) <em>after 1 second</em>.</p>

<p>Why do we wait a second?  Because if something's wrong with the startup sequence of <code>myserver</code> and it crashes immediately, you'll have a very intensive loop of constant restarting and crashing on your hands.  The <code>sleep 1</code> takes away the strain from that.</p>

<p>Now all you need to do is start this bash script (asynchronously, probably), and it will monitor <code>myserver</code> and restart it as necessary.  If you want to start the monitor on boot (making the server ""survive"" reboots), you can schedule it in your user's cron(1) with an <code>@reboot</code> rule.  Open your cron rules with <code>crontab</code>:</p>

<pre><code>crontab -e
</code></pre>

<p>Then add a rule to start your monitor script:</p>

<pre><code>@reboot /usr/local/bin/myservermonitor
</code></pre>

<hr>

<p>Alternatively; look at inittab(5) and /etc/inittab.  You can add a line in there to have <code>myserver</code> start at a certain init level and be respawned automatically.</p>

<hr>

<p>Edit.</p>

<p>Let me add some information on why <strong>not</strong> to use PID files.  While they are very popular; they are also very flawed and there's no reason why you wouldn't just do it the correct way.</p>

<p>Consider this:</p>

<ol>
<li><p>PID recycling (killing the wrong process):</p>

<ul>
<li><code>/etc/init.d/foo start</code>: start <code>foo</code>, write <code>foo</code>'s PID to <code>/var/run/foo.pid</code></li>
<li>A while later: <code>foo</code> dies somehow.</li>
<li>A while later: any random process that starts (call it <code>bar</code>) takes a random PID, imagine it taking <code>foo</code>'s old PID.</li>
<li>You notice <code>foo</code>'s gone: <code>/etc/init.d/foo/restart</code> reads <code>/var/run/foo.pid</code>, checks to see if it's still alive, finds <code>bar</code>, thinks it's <code>foo</code>, kills it, starts a new <code>foo</code>.</li>
</ul></li>
<li><p>PID files go stale.  You need over-complicated (or should I say, non-trivial) logic to check whether the PID file is stale, and any such logic is again vulnerable to <code>1.</code>.</p></li>
<li><p>What if you don't even have write access or are in a read-only environment?</p></li>
<li><p>It's pointless overcomplication; see how simple my example above is.  No need to complicate that, at all.</p></li>
</ol>

<p>See also: <a href=""https://stackoverflow.com/questions/25906020/are-pid-files-still-flawed-when-doing-it-right/25933330#25933330"">Are PID-files still flawed when doing it &#39;right&#39;?</a></p>

<p>By the way; <strong>even worse than PID files is parsing <code>ps</code>!</strong>  Don't ever do this.</p>

<ol>
<li><code>ps</code> is very unportable.  While you find it on almost every UNIX system; its arguments vary greatly if you want non-standard output.  And standard output is ONLY for human consumption, not for scripted parsing!</li>
<li>Parsing <code>ps</code> leads to a LOT of false positives.  Take the <code>ps aux | grep PID</code> example, and now imagine someone starting a process with a number somewhere as argument that happens to be the same as the PID you stared your daemon with!  Imagine two people starting an X session and you grepping for X to kill yours.  It's just all kinds of bad.</li>
</ol>

<p>If you don't want to manage the process yourself; there are some perfectly good systems out there that will act as monitor for your processes.  Look into <a href=""http://smarden.org/runit/"" rel=""noreferrer"">runit</a>, for example.</p>
"
"How to split one string into multiple strings separated by at least one space in bash shell?","1469849","<bash><shell><string><split>","240","<p>Did you try just passing the string variable to a <code>for</code> loop? Bash, for one, will split on whitespace automatically.</p>

<pre><code>sentence=""This is   a sentence.""
for word in $sentence
do
    echo $word
done
</code></pre>

<p>&nbsp;</p>

<pre><code>This
is
a
sentence.
</code></pre>
"
"How do I list the functions defined in my shell?","4471364","<bash><shell><function><unix>","238","<p><code>declare -F</code></p>

<blockquote>
  <p>Function names and definitions may be listed with the <code>-f</code> option to the
  <code>declare</code> builtin command (see Bash Builtins). The <code>-F</code> option to <code>declare</code>
  will list the function names only
  (and optionally the source file and line number).</p>
</blockquote>

<p><a href=""http://gnu.org/software/bash/manual/bashref"" rel=""noreferrer"">Bash Reference Manual</a></p>
"
"redirect COPY of stdout to log file from within bash script itself","3173131","<bash><shell><redirect><logging>","237","<pre><code>#!/usr/bin/env bash

# Redirect stdout ( &gt; ) into a named pipe ( &gt;() ) running ""tee""
exec &gt; &gt;(tee -i logfile.txt)

# Without this, only stdout would be captured - i.e. your
# log file would not contain any error messages.
# SEE (and upvote) the answer by Adam Spiers, which keeps STDERR
# as a separate stream - I did not want to steal from him by simply
# adding his answer to mine.
exec 2&gt;&amp;1

echo ""foo""
echo ""bar"" &gt;&amp;2
</code></pre>

<p>Note that this is <code>bash</code>, not <code>sh</code>. If you invoke the script with <code>sh myscript.sh</code>, you will get an error along the lines of <code>syntax error near unexpected token '&gt;'</code>.</p>

<p>If you are working with signal traps, you might want to use the <code>tee -i</code> option to avoid disruption of the output if a signal occurs. (Thanks to  JamesThomasMoon1979 for the comment.)</p>

<hr>

<p>Tools that change their output depending on whether they write to a pipe or a terminal (<code>ls</code> using colors and columnized output, for example) will detect the above construct as meaning that they output to a pipe.</p>

<p>There are options to enforce the colorizing / columnizing (e.g. <code>ls -C --color=always</code>). Note that this will result in the color codes being written to the logfile as well, making it <em>less</em> readable.</p>
"
"Check if an apt-get package is installed and then install it if it's not on Linux","1298066","<bash><shell><apt-get>","237","<p>To check if <code>packagename</code> was installed, type:</p>

<pre><code>dpkg -s &lt;packagename&gt;
</code></pre>

<p>You can also use <code>dpkg-query</code> that has a neater output for your purpose, and accepts wild cards, too.</p>

<pre><code>dpkg-query -l &lt;packagename&gt;
</code></pre>

<p>To find what package owns the <code>command</code>, try:</p>

<pre><code>dpkg -S `which &lt;command&gt;`
</code></pre>

<p>For further details, see article <em><a href=""http://www.cyberciti.biz/faq/find-out-if-package-is-installed-in-linux/"" rel=""noreferrer"">Find out if package is installed in Linux</a></em> and <a href=""http://www.cyberciti.biz/howto/question/linux/dpkg-cheat-sheet.php"" rel=""noreferrer"">dpkg cheat sheet</a>.</p>
"
"In Bash, how to add ""Are you sure [Y/n]"" to any command or alias?","3231804","<bash><alias><confirmation>","236","<p>These are more compact and versatile forms of <a href=""https://stackoverflow.com/questions/3231804/in-bash-how-to-add-are-you-sure-y-n-to-any-command-or-alias/3231821#3231821""><strong>Hamish's</strong> answer</a>. They handle any mixture of upper and lower case letters:</p>

<pre><code>read -r -p ""Are you sure? [y/N] "" response
case ""$response"" in
    [yY][eE][sS]|[yY]) 
        do_something
        ;;
    *)
        do_something_else
        ;;
esac
</code></pre>

<p>Or, for Bash >= version 3.2:</p>

<pre><code>read -r -p ""Are you sure? [y/N] "" response
if [[ ""$response"" =~ ^([yY][eE][sS]|[yY])$ ]]
then
    do_something
else
    do_something_else
fi
</code></pre>

<p>Note: If <code>$response</code> is an empty string, it will give an error. To fix, simply add quotation marks: <code>""$response""</code>. – Always use double quotes in variables containing strings (e.g.: prefer to use <code>""$@""</code> instead <code>$@</code>).</p>

<p>Or, Bash 4.x:</p>

<pre><code>read -r -p ""Are you sure? [y/N] "" response
response=${response,,}    # tolower
if [[ ""$response"" =~ ^(yes|y)$ ]]
...
</code></pre>

<p><strong>Edit:</strong></p>

<p>In response to your edit, here's how you'd create and use a <code>confirm</code> command based on the first version in my answer (it would work similarly with the other two):</p>

<pre><code>confirm() {
    # call with a prompt string or use a default
    read -r -p ""${1:-Are you sure? [y/N]} "" response
    case ""$response"" in
        [yY][eE][sS]|[yY]) 
            true
            ;;
        *)
            false
            ;;
    esac
}
</code></pre>

<p>To use this function:</p>

<pre><code>confirm &amp;&amp; hg push ssh://..
</code></pre>

<p>or</p>

<pre><code>confirm ""Would you really like to do a push?"" &amp;&amp; hg push ssh://..
</code></pre>
"
"How do you echo a 4-digit Unicode character in Bash?","602912","<bash><shell><unicode><character-encoding>","235","<p>In UTF-8 it's actually 6 digits (or 3 bytes).</p>

<pre><code>$ printf '\xE2\x98\xA0'
☠
</code></pre>

<p>To check how it's encoded by the console, use hexdump:</p>

<pre><code>$ printf ☠ | hexdump
0000000 98e2 00a0                              
0000003
</code></pre>
"
"Sorting data based on second column of a file","6438896","<bash><shell><unix>","235","<p>You can use the <a href=""https://linux.die.net/man/1/sort"" rel=""noreferrer""><code>sort</code> command</a>:</p>
<pre><code>sort -k2 -n yourfile
</code></pre>
<blockquote>
<p><code>-n</code>, <code>--numeric-sort</code> compare according to string numerical value</p>
</blockquote>
<p>For example:</p>
<pre class=""lang-sh prettyprint-override""><code>$ cat ages.txt 
Bob 12
Jane 48
Mark 3
Tashi 54

$ sort -k2 -n ages.txt 
Mark 3
Bob 12
Jane 48
Tashi 54
</code></pre>
"
"How to create User/Database in script for Docker Postgres","26598738","<bash><postgresql><docker><dockerhub>","234","<h2>EDIT - since Jul 23, 2015</h2>

<p>The <a href=""https://hub.docker.com/_/postgres/"" rel=""noreferrer"">official postgres docker image</a> will run <code>.sql</code> scripts found in the <code>/docker-entrypoint-initdb.d/</code> folder. </p>

<p>So all you need is to create the following sql script: </p>

<p><em>init.sql</em></p>

<pre><code>CREATE USER docker;
CREATE DATABASE docker;
GRANT ALL PRIVILEGES ON DATABASE docker TO docker;
</code></pre>

<p>and add it in your Dockerfile:</p>

<p><em>Dockerfile</em></p>

<pre><code>FROM library/postgres
COPY init.sql /docker-entrypoint-initdb.d/
</code></pre>

<hr>

<p>But since July 8th, 2015, <strong>if all you need is to create a user and database</strong>, it is easier to just make use to the <code>POSTGRES_USER</code>, <code>POSTGRES_PASSWORD</code> and <code>POSTGRES_DB</code> environment variables:</p>

<pre><code>docker run -e POSTGRES_USER=docker -e POSTGRES_PASSWORD=docker -e POSTGRES_DB=docker library/postgres
</code></pre>

<p>or with a Dockerfile:</p>

<pre><code>FROM library/postgres
ENV POSTGRES_USER docker
ENV POSTGRES_PASSWORD docker
ENV POSTGRES_DB docker
</code></pre>

<hr>

<h2>for images older than Jul 23, 2015</h2>

<p>From <a href=""https://registry.hub.docker.com/_/postgres/"" rel=""noreferrer"">the documentation of the postgres Docker image</a>, it is said that</p>

<blockquote>
  <p>[...] it will source any *.sh script found in that directory [<code>/docker-entrypoint-initdb.d</code>] to do further initialization before starting the service</p>
</blockquote>

<p>What's important here is <em>""before starting the service""</em>. This means your script <em>make_db.sh</em> will be executed before the postgres service would be started, hence the error message <em>""could not connect to database postgres""</em>.</p>

<p>After that there is another useful piece of information:</p>

<blockquote>
  <p>If you need to execute SQL commands as part of your initialization, the use of Postgres single user mode is highly recommended.</p>
</blockquote>

<p>Agreed this can be a bit mysterious at the first look. What it says is that your initialization script should start the postgres service in single mode before doing its actions. So you could change your <em>make_db.ksh</em> script as follows and it should get you closer to what you want:</p>

<p><strong>NOTE</strong>, this has changed recently <a href=""https://github.com/docker-library/postgres/pull/75/commits"" rel=""noreferrer"">in the following commit</a>.  This will work with the latest change:</p>

<pre class=""lang-sh prettyprint-override""><code>export PGUSER=postgres
psql &lt;&lt;- EOSQL
    CREATE USER docker;
    CREATE DATABASE docker;
    GRANT ALL PRIVILEGES ON DATABASE docker TO docker;
EOSQL
</code></pre>

<p>Previously, the use of <code>--single</code> mode was required:</p>

<pre class=""lang-sh prettyprint-override""><code>gosu postgres postgres --single &lt;&lt;- EOSQL
    CREATE USER docker;
    CREATE DATABASE docker;
    GRANT ALL PRIVILEGES ON DATABASE docker TO docker;
EOSQL
</code></pre>
"
"What is the best practice for dealing with passwords in git repositories?","2397822","<git><bash><security><github><passwords>","233","<p>The typical way to do this is to read the password info from a configuration file. If your configuration file is called <code>foobar.config</code>, then you would commit a file called <code>foobar.config.example</code> to the repository, containing sample data. To run your program, you would create a local (not tracked) file called <code>foobar.config</code> with your <em>real</em> password data.</p>

<p>To filter out your existing password from previous commits, see the GitHub help page on <a href=""http://help.github.com/removing-sensitive-data/"" rel=""noreferrer"">Removing sensitive data</a>.</p>
"
"How to check if an environment variable exists and get its value?","39296472","<bash><shell>","233","<p><code>[ -z ""${DEPLOY_ENV}"" ]</code> checks whether <code>DEPLOY_ENV</code> has length equal to zero. So you could run:</p>

<pre><code>if [[ -z ""${DEPLOY_ENV}"" ]]; then
  MY_SCRIPT_VARIABLE=""Some default value because DEPLOY_ENV is undefined""
else
  MY_SCRIPT_VARIABLE=""${DEPLOY_ENV}""
fi

# or using a short-hand version

[[ -z ""${DEPLOY_ENV}"" ]] &amp;&amp; MyVar='default' || MyVar=""${DEPLOY_ENV}""

# or even shorter use

MyVar=""${DEPLOY_ENV:-default_value}""
</code></pre>
"
"How to install Homebrew on OS X?","20381128","<macos><bash><installation><homebrew>","231","<p>It's on the top of the <a href=""http://brew.sh/"" rel=""noreferrer"">Homebrew homepage</a>.</p>
<p>From a Terminal prompt:</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<p>The command <code>brew install wget</code> is an example of how to use Homebrew to install another application (in this case, <code>wget</code>) after brew is already installed.</p>
<p><strong>Edit:</strong></p>
<p>Above command to install the Brew is migrated to:</p>
<pre><code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;
</code></pre>
"
"Returning a boolean from a Bash function","5431909","<bash><shell><boolean>","231","<p>Use 0 for true and 1 for false.</p>

<p>Sample:</p>

<pre><code>#!/bin/bash

isdirectory() {
  if [ -d ""$1"" ]
  then
    # 0 = true
    return 0 
  else
    # 1 = false
    return 1
  fi
}


if isdirectory $1; then echo ""is directory""; else echo ""nopes""; fi
</code></pre>

<p><strong>Edit</strong></p>

<p>From @amichair's comment, these are also possible</p>

<pre><code>isdirectory() {
  if [ -d ""$1"" ]
  then
    true
  else
    false
  fi
}


isdirectory() {
  [ -d ""$1"" ]
}
</code></pre>
"
"Getting the parent of a directory in Bash","8426058","<bash><directory><dirname>","231","<pre><code>dir=/home/smith/Desktop/Test
parentdir=""$(dirname ""$dir"")""
</code></pre>

<p>Works if there is a trailing slash, too.</p>
"
"Is there a ""goto"" statement in bash?","9639103","<linux><bash><shell><goto>","229","<p>No, there is not; see <a href=""http://www.gnu.org/software/bash/manual/bashref.html#Compound-Commands"" rel=""noreferrer"">&sect;3.2.4 ""Compound Commands"" in the <em>Bash Reference Manual</em></a> for information about the control structures that <em>do</em> exist. In particular, note the mention of <code>break</code> and <code>continue</code>, which aren't as flexible as <code>goto</code>, but are more flexible in Bash than in some languages, and may help you achieve what you want. (Whatever it is that you want . . .)</p>
"
"Check if a string matches a regex in Bash script","21112707","<regex><bash><shell><scripting>","229","<p>You can use the test construct, <code>[[ ]]</code>, along with the regular expression match operator, <code>=~</code>, to check if a string matches a regex pattern.</p>
<p>For your specific case, you can write:</p>
<pre><code>[[ $date =~ ^[0-9]{8}$ ]] &amp;&amp; echo &quot;yes&quot;
</code></pre>
<p>Or more a accurate test:</p>
<pre><code>[[ $date =~ ^[0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])$ ]] &amp;&amp; echo &quot;yes&quot;
#           |^^^^^^^^ ^^^^^^ ^^^^^^  ^^^^^^ ^^^^^^^^^^ ^^^^^^ |
#           |   |     ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^ |
#           |   |          |                   |              |
#           |   |           \                  |              |
#           | --year--   --month--           --day--          |
#           |          either 01...09      either 01..09     end of line
# start of line            or 10,11,12         or 10..29
#                                              or 30, 31
</code></pre>
<p>That is, you can define a regex in <em>Bash</em> matching the format you want. This way you can do:</p>
<pre><code>[[ $date =~ ^regex$ ]] &amp;&amp; echo &quot;matched&quot; || echo &quot;did not match&quot;
</code></pre>
<p>where commands after <code>&amp;&amp;</code> are executed if the test is successful, and commands after <code>||</code> are executed if the test is unsuccessful.</p>
<p>Note this is based on the solution by Aleks-Daniel Jakimenko in <a href=""https://stackoverflow.com/a/18748968/1983854"">User input date format verification in bash</a>.</p>
<hr />
<p>In other shells you can use <strong>grep</strong>. If your shell is POSIX compliant, do</p>
<pre><code>(echo &quot;$date&quot; | grep -Eq  ^regex$) &amp;&amp; echo &quot;matched&quot; || echo &quot;did not match&quot;
</code></pre>
<p>In <a href=""https://fishshell.com/"" rel=""noreferrer"">fish</a>, which is not POSIX-compliant, you can do</p>
<pre><code>echo &quot;$date&quot; | grep -Eq &quot;^regex\$&quot;; and echo &quot;matched&quot;; or echo &quot;did not match&quot;
</code></pre>
"
"Why is #!/usr/bin/env bash superior to #!/bin/bash?","21612980","<bash><shebang>","228","<p><code>#!/usr/bin/env</code> searches <code>PATH</code> for <code>bash</code>, and <code>bash</code> is not always in <code>/bin</code>, particularly on non-Linux systems.  For example, on my OpenBSD system, it's in <code>/usr/local/bin</code>, since it was installed as an optional package.</p>

<p>If you are absolutely sure <code>bash</code> is in <code>/bin</code> and will always be, there's no harm in putting it directly in your shebang—but I'd recommend against it because scripts and programs all have lives beyond what we initially believe they will have.</p>
"
"How to insert a text at the beginning of a file?","9533679","<linux><bash><sed>","228","<p><code>sed</code> can operate on an address:</p>

<pre><code>$ sed -i '1s/^/&lt;added text&gt; /' file
</code></pre>

<p>What is this magical <code>1s</code> you see on every answer here? <a href=""https://www.gnu.org/software/sed/manual/html_node/Addresses.html"" rel=""noreferrer"">Line addressing!</a>.</p>

<p>Want to add <code>&lt;added text&gt;</code> on the first 10 lines?</p>

<pre><code>$ sed -i '1,10s/^/&lt;added text&gt; /' file
</code></pre>

<p>Or you can use <a href=""http://www.gnu.org/software/bash/manual/bash.html#Command-Grouping"" rel=""noreferrer""><code>Command Grouping</code></a>:</p>

<pre><code>$ { echo -n '&lt;added text&gt; '; cat file; } &gt;file.new
$ mv file{.new,}
</code></pre>
"
"Multiple commands in an alias for bash","756756","<bash><configuration>","228","<p>Try:</p>

<pre><code>alias lock='gnome-screensaver; gnome-screensaver-command --lock'
</code></pre>

<p>or</p>

<pre><code>lock() {
    gnome-screensaver
    gnome-screensaver-command --lock
}
</code></pre>

<p>in your .bashrc</p>

<p>The second solution allows you to use arguments.</p>
"
"How to remove last n characters from a string in Bash?","27658675","<bash>","227","<p>First, it's usually better to be explicit about your intent. So if you know the string ends in <code>.rtf</code>, and you want to remove that <code>.rtf</code>, you can just use <code>var2=${var%.rtf}</code>. One potentially-useful aspect of this approach is that if the string <em>doesn't</em> end in <code>.rtf</code>, it is not changed at all; <code>var2</code> will contain an unmodified copy of <code>var</code>.</p>
<p>If you want to remove a filename suffix but don't know or care exactly what it is, you can use <code>var2=${var%.*}</code> to remove everything starting with the last <code>.</code>. Or, if you only want to keep everything up to but not including the <em>first</em> <code>.</code>, you can use <code>var2=${var%%.*}</code>. Those options have the same result if there's only one <code>.</code>, but if there might be more than one, you get to pick which end of the string to work from. On the other hand, if there's no <code>.</code> in the string at all, <code>var2</code> will again be an unchanged copy of <code>var</code>.</p>
<p>If you really want to always remove a specific <em>number</em> of characters, here are some options.</p>
<p>You tagged this <code>bash</code> specifically, so we'll start with bash builtins. The one which has worked the longest is the same suffix-removal syntax I used above: to remove four characters, use <code>var2=${var%????}</code>. Or to remove four characters only if the first one is a dot, use <code>var2=${var%.???}</code>, which is like <code>var2=${var%.*}</code> but only removes the suffix if the part after the dot is exactly three characters. As you can see, to count characters this way, you need one question mark per unknown character removed, so this approach gets unwieldy for larger substring lengths.</p>
<p>An option in newer shell versions is substring extraction: <code>var2=${var:0:${#var}-4}</code>. Here you can put any number in place of the <code>4</code> to remove a different number of characters. The <code>${#var}</code> is replaced by the length of the string, so this is actually asking to extract and keep all the characters from indexes 0 to (length - 4), inclusive. With this approach, you lose the option to make the change only if the string matches a pattern; no matter what the actual value of the string is, the copy will include all but its last four characters.</p>
<p>Bash lets you leave the start index out; it defaults to 0, so you can shorten that to just <code>var2=${var::${#var}-4}</code>. In fact, newer versions of bash (specifically 4+, which means the one that ships with MacOS won't work) recognize negative indexes as counting back from the end of the string, so you can get rid of the length expression, too: <code>var2=${var::-4}</code>.</p>
<p>If you're not actually using bash but some other POSIX-type shell, the pattern-based suffix removal with <code>%</code> will still work – even in plain old dash, where the index-based substring extraction won't. Ksh and zsh do both support substring extraction, but require the explicit 0 start index; zsh also supports the negative end index, while ksh requires the length expression.</p>
<p>Instead of using built-in shell parameter expansion, you can of course run some utility program to modify the string and capture its output with command substitution. There are plenty that will work, but something like <code>var2=$(cut -c -4 &lt;&lt;&lt;&quot;$var&quot;)</code> is probably the shortest option.</p>
"
"How can I get `find` to ignore .svn directories?","2314643","<linux><find><bash><grep><svn>","227","<p>For searching, can I suggest you look at <a href=""http://www.betterthangrep.com"" rel=""noreferrer"">ack</a> ? It's a source-code aware <code>find</code>, and as such will automatically ignore many file types, including source code repository info such as the above.</p>
"
"Subtract two variables in Bash","8385627","<bash><shell><unix>","227","<p>You just need a little extra whitespace around the minus sign, and backticks:</p>

<pre><code>COUNT=`expr $FIRSTV - $SECONDV`
</code></pre>

<p>Be aware of the exit status:</p>

<p>The exit status is 0 if EXPRESSION is neither null nor 0, <strong>1 if EXPRESSION is null or 0</strong>.</p>

<p>Keep this in mind when using the expression in a bash script in combination with <strong>set -e</strong> which will exit immediately if a command exits with a non-zero status.</p>
"
"Which characters need to be escaped when using Bash?","15783701","<bash><shell><unix><escaping><special-characters>","226","<p>There are two easy and safe rules which work not only in <code>sh</code> but also <code>bash</code>.</p>
<h2>1. Put the whole string in single quotes</h2>
<p>This works for all chars except single quote itself. To escape the single quote, close the quoting before it, insert the single quote, and re-open the quoting.</p>
<pre><code>'I'\''m a s@fe $tring which ends in newline
'
</code></pre>
<p>sed command: <code>sed -e &quot;s/'/'\\\\''/g; 1s/^/'/; \$s/\$/'/&quot;</code></p>
<h2>2. Escape every char with a backslash</h2>
<p>This works for all characters except newline. For newline characters use single or double quotes. <em>Empty strings must still be handled - replace with <code>&quot;&quot;</code></em></p>
<pre><code>\I\'\m\ \a\ \s\@\f\e\ \$\t\r\i\n\g\ \w\h\i\c\h\ \e\n\d\s\ \i\n\ \n\e\w\l\i\n\e&quot;
&quot;
</code></pre>
<p>sed command: <code>sed -e 's/./\\&amp;/g; 1{$s/^$/&quot;&quot;/}; 1!s/^/&quot;/; $!s/$/&quot;/'</code>.</p>
<h3>2b. More readable version of 2</h3>
<p>There's an easy safe set of characters, like <code>[a-zA-Z0-9,._+:@%/-]</code>, which can be left unescaped to keep it more readable</p>
<pre><code>I\'m\ a\ s@fe\ \$tring\ which\ ends\ in\ newline&quot;
&quot;
</code></pre>
<p>sed command: <code>LC_ALL=C sed -e 's/[^a-zA-Z0-9,._+@%/-]/\\&amp;/g; 1{$s/^$/&quot;&quot;/}; 1!s/^/&quot;/; $!s/$/&quot;/'</code>.</p>
<hr />
<p>Note that in a sed program, one can't know whether the last line of input ends with a newline byte (except when it's empty). That's why both above sed commands assume it does not. You can add a quoted newline manually.</p>
<p>Note that shell variables are only defined for text in the POSIX sense. Processing binary data is not defined. For the implementations that matter, binary works with the exception of NUL bytes (because variables are implemented with C strings, and meant to be used as C strings, namely program arguments), but you should switch to a &quot;binary&quot; locale such as latin1.</p>
<hr />
<p>(You can easily validate the rules by reading the POSIX spec for <code>sh</code>. For bash, check the <a href=""http://www.gnu.org/software/bash/manual/bashref.html#Quoting"" rel=""noreferrer"">reference manual</a> linked by @AustinPhillips)</p>
"
"Ubuntu says ""bash: ./program Permission denied""","18960689","<bash><shell><sh>","226","<p><code>chmod u+x program_name</code>. Then execute it.</p>

<p>If that does not work, copy the program from the USB device to a native volume on the system. Then <code>chmod u+x program_name</code> on the local copy and execute that.</p>

<p>Unix and Unix-like systems generally will not execute a program unless it is marked with permission to execute. The way you copied the file from one system to another (or mounted an external volume) may have turned off execute permission (as a safety feature). The command <code>chmod u+x name</code> adds permission for the user that owns the file to execute it.</p>

<p>That command only changes the permissions associated with the file; it does not change the security controls associated with the entire volume. If it is security controls on the volume that are interfering with execution (for example, a <code>noexec</code> option may be specified for a volume in the Unix <code>fstab</code> file, which says not to allow execute permission for files on the volume), then you can remount the volume with options to allow execution. However, copying the file to a local volume may be a quicker and easier solution.</p>
"
"How can I convert a series of images to a PDF from the command line on linux?","8955425","<image><bash><pdf>","226","<p>Using <a href=""http://www.imagemagick.org/script/index.php"" rel=""noreferrer"">imagemagick</a>, you can try:</p>

<pre><code>convert page.png page.pdf
</code></pre>

<p>Or for multiple images:</p>

<pre><code>convert page*.png mydoc.pdf
</code></pre>
"
"How can I use Bash syntax in Makefile targets?","589276","<bash><shell><makefile>","225","<p>From the GNU Make documentation,</p>

<pre class=""lang-none prettyprint-override""><code>5.3.1 Choosing the Shell
------------------------

The program used as the shell is taken from the variable `SHELL'.  If
this variable is not set in your makefile, the program `/bin/sh' is
used as the shell.
</code></pre>

<p>So put <code>SHELL := /bin/bash</code> at the top of your makefile, and you should be good to go.</p>

<p>BTW: You can also do this for one target, at least for GNU Make. Each target can have its own variable assignments, like this:</p>

<pre class=""lang-make prettyprint-override""><code>all: a b

a:
    @echo ""a is $$0""

b: SHELL:=/bin/bash   # HERE: this is setting the shell for b only
b:
    @echo ""b is $$0""
</code></pre>

<p>That'll print:</p>

<pre class=""lang-none prettyprint-override""><code>a is /bin/sh
b is /bin/bash
</code></pre>

<p>See ""Target-specific Variable Values"" in the documentation for more details. That line can go anywhere in the Makefile, it doesn't have to be immediately before the target.</p>
"
"How to remove double-quotes in jq output for parsing json files in bash?","44656515","<bash><awk><sed><jq>","225","<p>Use the <code>-r</code> (or <code>--raw-output</code>) option to emit raw strings as output:</p>

<pre><code>jq -r '.name' &lt;json.txt
</code></pre>
"
"Meaning of ""[: too many arguments"" error from if [] (square brackets)","13781216","<bash><if-statement><arguments>","225","<p>If your <code>$VARIABLE</code> is a string containing spaces or other special characters, <a href=""https://serverfault.com/questions/52034/what-is-the-difference-between-double-and-single-square-brackets-in-bash"">and single square brackets are used</a> (which is a shortcut for the <code>test</code> command), then the string may be split out into multiple words. Each of these is treated as a separate argument. </p>

<p>So that <strong>one variable is split out into many arguments</strong>:</p>

<pre><code>VARIABLE=$(/some/command);  
# returns ""hello world""

if [ $VARIABLE == 0 ]; then
  # fails as if you wrote:
  # if [ hello world == 0 ]
fi 
</code></pre>

<p>The same will be true for any function call that puts down a string containing spaces or other special characters.</p>

<hr>

<h2>Easy fix</h2>

<p>Wrap the variable output in double quotes, forcing it to stay as one string (therefore one argument). For example,</p>

<pre><code>VARIABLE=$(/some/command);
if [ ""$VARIABLE"" == 0 ]; then
  # some action
fi 
</code></pre>

<p><strong>Simple as that.</strong> But skip to ""Also beware..."" below if you also can't guarantee your variable won't be an empty string, or a string that contains nothing but whitespace.</p>

<hr>

<p>Or, an <strong>alternate fix</strong> is to use double square brackets (which is a shortcut for the <code>new test</code> command). </p>

<p>This exists only in bash (and apparently korn and zsh) however, and so may not be compatible with default shells called by <code>/bin/sh</code> etc. </p>

<p>This means on some systems, <strong>it might work from the console but not when called elsewhere, like from <code>cron</code></strong>, depending on how everything is configured. </p>

<p>It would look like this:</p>

<pre><code>VARIABLE=$(/some/command);
if [[ $VARIABLE == 0 ]]; then
  # some action
fi 
</code></pre>

<p>If your command contains double square brackets like this and you get errors in logs but it works from the console, try swapping out the <code>[[</code> for an alternative suggested here, or, ensure that whatever runs your script uses a shell that supports <code>[[</code> aka <code>new test</code>.</p>

<hr>

<h2>Also beware of the <code>[: unary operator expected</code> error</h2>

<p>If you're seeing the ""too many arguments"" error, chances are you're getting a string from a function with unpredictable output. <strong>If it's also possible to get an empty string</strong> (or all whitespace string), this would be treated as zero arguments even with the above ""quick fix"", and would fail with <code>[: unary operator expected</code> </p>

<p>It's the same 'gotcha' if you're used to other languages - you don't expect the contents of a variable to be effectively printed into the code like this before it is evaluated.</p>

<p>Here's an example that prevents both the <code>[: too many arguments</code> and the <code>[: unary operator expected</code> errors: replacing the output with a default value if it is empty (in this example, <code>0</code>), with double quotes wrapped around the whole thing:</p>

<pre><code>VARIABLE=$(/some/command);
if [ ""${VARIABLE:-0}"" == 0 ]; then
  # some action
fi 
</code></pre>

<p>(here, the action will happen if $VARIABLE is 0, or empty. Naturally, you should change the 0 (the default value) to a different default value if different behaviour is wanted)</p>

<hr>

<p><strong>Final note:</strong> Since <code>[</code> is a shortcut for <code>test</code>, all the above is also true for the error <code>test: too many arguments</code> (and also <code>test: unary operator expected</code>)</p>
"
"How to resolve symbolic links in a shell script","7665","<bash><shell><scripting><symlink>","225","<p>According to the standards, <code>pwd -P</code> should return the path with symlinks resolved.</p>

<p>C function <code>char *getcwd(char *buf, size_t size)</code> from <code>unistd.h</code> should have the same behaviour.</p>

<p><a href=""http://www.opengroup.org/onlinepubs/009695399/functions/getcwd.html"" rel=""noreferrer"">getcwd</a>
<a href=""http://www.opengroup.org/onlinepubs/009695399/utilities/pwd.html"" rel=""noreferrer"">pwd</a></p>
"
"How do I redirect output to a variable in shell?","2559076","<bash><shell>","224","<p>Use the <code>$( ... )</code> construct:</p>

<pre><code>hash=$(genhash --use-ssl -s $IP -p 443 --url $URL | grep MD5 | grep -c $MD5)
</code></pre>
"
"How to generate a core dump in Linux on a segmentation fault?","17965","<linux><bash><unix><coredump><tcsh>","224","<p>This depends on what shell you are using.  If you are using bash, then the ulimit command controls several settings relating to program execution, such as whether you should dump core.  If you type</p>

<pre><code>ulimit -c unlimited
</code></pre>

<p>then that will tell bash that its programs can dump cores of any size.  You can specify a size such as 52M instead of unlimited if you want, but in practice this shouldn't be necessary since the size of core files will probably never be an issue for you.</p>

<p>In tcsh, you'd type</p>

<pre><code>limit coredumpsize unlimited
</code></pre>
"
"How to sort a file in-place","29244351","<linux><bash><shell><unix>","224","<p>You can use file redirection to redirected the sorted output:</p>
<pre><code>sort input-file &gt; output_file
</code></pre>
<p>Or you can use the <code>-o</code>, <code>--output=FILE</code> option of sort to indicate the same input and output file:</p>
<pre><code>sort -o file file
</code></pre>
<p>⚠️ <strong>Note:</strong> A common mistake is to try to redirect the output to the same input file
(e.g. <code>sort file &gt; file</code>).  This does not work as the shell is making the redirections (not the <strong>sort(1)</strong> program) and the input file (as being the output also) will be erased just before giving the <strong>sort(1)</strong> program the opportunity of reading it.</p>
"
"Command to get nth line of STDOUT","1429556","<bash><shell><sed><stdout>","223","<p>Using <code>sed</code>, just for variety:</p>

<pre><code>ls -l | sed -n 2p
</code></pre>

<p>Using this alternative, which looks more efficient since it stops reading the input when the required line is printed, may generate a SIGPIPE in the feeding process, which may in turn generate an unwanted error message:</p>

<pre><code>ls -l | sed -n -e '2{p;q}'
</code></pre>

<p>I've seen that often enough that I usually use the first (which is easier to type, anyway), though <code>ls</code> is not a command that complains when it gets SIGPIPE.</p>

<p>For a range of lines:</p>

<pre><code>ls -l | sed -n 2,4p
</code></pre>

<p>For several ranges of lines:</p>

<pre><code>ls -l | sed -n -e 2,4p -e 20,30p
ls -l | sed -n -e '2,4p;20,30p'
</code></pre>
"
"How to get the process ID to kill a nohup process?","17385794","<linux><bash><grep><nohup>","223","<p>When using <code>nohup</code> and you put the task in the background, the background operator (<code>&amp;</code>) will give you the PID at the command prompt. If your plan is to manually manage the process, you can save that PID and use it later to kill the process if needed, via <code>kill PID</code> or <code>kill -9 PID</code> (if you need to force kill). Alternatively, you can find the PID later on by <code>ps -ef | grep &quot;command name&quot;</code> and locate the PID from there. Note that <code>nohup</code> keyword/command itself does not appear in the <code>ps</code> output for the command in question.</p>
<p>If you use a script, you could do something like this in the script:</p>
<pre><code>nohup my_command &gt; my.log 2&gt;&amp;1 &amp;
echo $! &gt; save_pid.txt
</code></pre>
<p>This will run <code>my_command</code> saving all output into <code>my.log</code> (in a script, <code>$!</code> represents the PID of the last process executed). The <code>2</code> is the file descriptor for standard error (<code>stderr</code>) and <code>2&gt;&amp;1</code> tells the shell to route standard error output to the standard output (file descriptor <code>1</code>). It requires <code>&amp;1</code> so that the shell knows it's a file descriptor in that context instead of just a file named <code>1</code>. The <code>2&gt;&amp;1</code> is needed to capture any error messages that normally are written to standard error into our <code>my.log</code> file (which is coming from standard output). See <a href=""http://www.tldp.org/LDP/abs/html/io-redirection.html"" rel=""noreferrer"">I/O Redirection</a> for more details on handling I/O redirection with the shell.</p>
<p>If the command sends output on a regular basis, you can check the output occasionally with <code>tail my.log</code>, or if you want to follow it &quot;live&quot; you can use <code>tail -f my.log</code>. Finally, if you need to kill the process, you can do it via:</p>
<pre><code>kill -9 `cat save_pid.txt`
rm save_pid.txt
</code></pre>
"
"How do you normalize a file path in Bash?","284662","<linux><bash><unix><shell>","222","<p>if you're wanting to chomp part of a filename from the path, ""dirname"" and ""basename"" are your friends, and ""realpath"" is handy too. </p>

<pre><code>dirname /foo/bar/baz 
# /foo/bar 
basename /foo/bar/baz
# baz
dirname $( dirname  /foo/bar/baz  ) 
# /foo 
realpath ../foo
# ../foo: No such file or directory
realpath /tmp/../tmp/../tmp
# /tmp
</code></pre>

<p><b><code>realpath</code> alternatives</b></p>

<p>If <code>realpath</code> is not supported by your shell, you can try </p>

<pre><code>readlink -f /path/here/.. 
</code></pre>

<p>Also</p>

<pre><code>readlink -m /path/there/../../ 
</code></pre>

<p>Works the same as </p>

<pre><code>realpath -s /path/here/../../
</code></pre>

<p>in that the path doesn't need to exist to be normalized. </p>
"
"Bash: If/Else statement in one line","17203122","<bash>","221","<p>There is no need to explicitly check <code>$?</code>.  Just do:</p>

<pre><code>ps aux | grep some_proces[s] &gt; /tmp/test.txt &amp;&amp; echo 1 || echo 0 
</code></pre>

<p>Note that this relies on echo not failing, which is certainly not guaranteed.  A more reliable way to write this is:</p>

<pre><code>if ps aux | grep some_proces[s] &gt; /tmp/test.txt; then echo 1; else echo 0; fi
</code></pre>
"
"How to check if a symlink exists","5767062","<bash><symlink>","221","<p><code>-L</code> returns true if the ""file"" exists and is a symbolic link (the linked file may or may not exist). You want <code>-f</code> (returns true if file exists and is a regular file) or maybe just <code>-e</code> (returns true if file exists regardless of type).</p>

<p>According to the <a href=""http://linux.die.net/man/1/test"" rel=""noreferrer"">GNU manpage</a>, <code>-h</code> is identical to <code>-L</code>, but according to the <a href=""https://www.freebsd.org/cgi/man.cgi?test"" rel=""noreferrer"">BSD manpage</a>, it should not be used:</p>

<blockquote>
  <p><code>-h file</code>       True if file exists and is a symbolic link.  This operator is retained for compatibility with previous versions of this program. Do not rely on its existence; use -L instead.</p>
</blockquote>
"
"find: missing argument to -exec","2961673","<bash><shell><find><arguments><exec>","220","<p>I figured it out now. When you need to run two commands in exec in a find you need to actually have two separate execs. This finally worked for me.</p>

<pre><code>find . -type f -name ""*.rm"" -exec ffmpeg -i {} -sameq {}.mp3 \; -exec rm {} \;
</code></pre>
"
"How do I read the first line of a file using cat?","6114119","<bash><file-io><cat>","219","<p>You don't need <code>cat</code>.  </p>

<pre><code>head -1 file
</code></pre>

<p>will work fine.</p>
"
"How to evaluate http response codes from bash/shell script?","2220301","<http><bash><shell><http-headers>","219","<p>I haven't tested this on a 500 code, but it works on others like 200, 302 and 404.</p>
<pre><code>response=$(curl --write-out '%{http_code}' --silent --output /dev/null servername)
</code></pre>
<p>Note, format provided for --write-out should be quoted.
As suggested by @ibai, add <code>--head</code> to make a HEAD only request. This will save time when the retrieval is successful since the page contents won't be transmitted.</p>
"
"Reading a delimited string into an array in Bash","9293887","<arrays><string><bash><shell>","219","<p>In order to convert a string into an array, please use</p>

<pre><code>arr=($line)
</code></pre>

<p>or</p>

<pre><code>read -a arr &lt;&lt;&lt; $line
</code></pre>

<p>It is crucial not to use quotes since this does the trick.</p>
"
"Bash: Strip trailing linebreak from output","12524308","<bash><newline><line-breaks>","217","<p><strong>If your expected output is a single line</strong>, you can simply remove all newline characters from the output. It would not be uncommon to pipe to the <code>tr</code> utility, or to Perl if preferred:</p>
<pre><code>wc -l &lt; log.txt | tr -d '\n'

wc -l &lt; log.txt | perl -pe 'chomp'
</code></pre>
<p>You can also use command substitution to remove the trailing newline:</p>
<pre><code>echo -n &quot;$(wc -l &lt; log.txt)&quot;

printf &quot;%s&quot; &quot;$(wc -l &lt; log.txt)&quot;
</code></pre>
<hr />
<p><strong>If your expected output may contain multiple lines</strong>, you have another decision to make:</p>
<p>If you want to remove MULTIPLE newline characters from the end of the file, again use cmd substitution:</p>
<pre><code>printf &quot;%s&quot; &quot;$(&lt; log.txt)&quot;
</code></pre>
<p>If you want to strictly remove THE LAST newline character from a file, use Perl:</p>
<pre><code>perl -pe 'chomp if eof' log.txt
</code></pre>
<hr />
<p>Note that if you are certain you have a trailing newline character you want to remove, you can use <code>head</code> from GNU coreutils to select everything except the last byte. This should be quite quick:</p>
<pre><code>head -c -1 log.txt
</code></pre>
<p>Also, for completeness, you can quickly check where your newline (or other special) characters are in your file using <code>cat</code> and the 'show-all' flag <code>-A</code>. The dollar sign character will indicate the end of each line:</p>
<pre><code>cat -A log.txt
</code></pre>
"
"Quick unix command to display specific lines in the middle of a file?","191364","<linux><bash><unix><text>","216","<p>with GNU-grep you could just say </p>

<pre>grep --context=10 ...</pre>
"
"Execute command without keeping it in history","8473121","<linux><bash><unix>","215","<p>Start your command with a space and it won't be included in the history.</p>

<p>Be aware that this does require the environment variable <code>$HISTCONTROL</code> to be set.</p>

<ul>
<li><p>Check that the following command returns <code>ignorespace</code> or
<code>ignoreboth</code></p>

<pre><code>#&gt; echo $HISTCONTROL
</code></pre></li>
<li><p>To add the environment variable if missing, the following line can be
added to the bash profile. E.g. <code>%HOME/.bashrc</code></p>

<pre><code>export HISTCONTROL=ignorespace
</code></pre></li>
</ul>

<p>After sourcing the profile again space prefixed commands will not be written to <code>$HISTFILE</code></p>
"
"Switching from zsh to bash on OSX, and back again?","10341271","<bash><terminal><zsh>","215","<p>You can just use <code>exec</code> to replace your current shell with a new shell:</p>

<p>Switch to <code>bash</code>:</p>

<pre><code>exec bash
</code></pre>

<p>Switch to <code>zsh</code>:</p>

<pre><code>exec zsh
</code></pre>

<p>This won't affect new terminal windows or anything, but it's convenient.</p>
"
"Unable to forward search Bash history similarly as with CTRL-r","791765","<bash><search>","214","<p>You can search forward as well. From the bash info manual, ""<a href=""http://www.gnu.org/software/bash/manual/html_node/Searching.html"" rel=""noreferrer"">8.2.5 Searching for Commands in the History</a>"":</p>

<blockquote>
  <p>To search backward in the history for a particular string, type <code>C-r</code>.
  Typing <code>C-s</code> searches forward through the history.</p>
</blockquote>

<p>The problem with Ctrl-S however is that sometimes collides with XON/XOFF flow control (in Konsole for instance). The searching is a readline feature however, and you should be able to bind it to some other key. Update: Simpler and better is just to disable XON/XOFF by running</p>

<pre><code>stty -ixon
</code></pre>
"
"How to redirect output of an entire shell script within the script itself?","314675","<bash><shell><sh>","214","<p>Addressing the question as updated.</p>

<pre><code>#...part of script without redirection...

{
    #...part of script with redirection...
} &gt; file1 2&gt;file2 # ...and others as appropriate...

#...residue of script without redirection...
</code></pre>

<p>The braces '{ ... }' provide a unit of I/O redirection.  The braces must appear where a command could appear - simplistically, at the start of a line or after a semi-colon.  (<em>Yes, that can be made more precise; if you want to quibble, let me know.</em>)</p>

<p>You are right that you can preserve the original stdout and stderr with the redirections you showed, but it is usually simpler for the people who have to maintain the script later to understand what's going on if you scope the redirected code as shown above.</p>

<p>The relevant sections of the Bash manual are <a href=""https://www.gnu.org/software/bash/manual/bash.html#Command-Grouping"" rel=""noreferrer"">Grouping Commands</a> and <a href=""https://www.gnu.org/software/bash/manual/bash.html#Redirections"" rel=""noreferrer"">I/O Redirection</a>.  The relevant sections of the POSIX shell specification are <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_09_04"" rel=""noreferrer"">Compound Commands</a> and <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_07"" rel=""noreferrer"">I/O Redirection</a>.  Bash has some extra notations, but is otherwise similar to the POSIX shell specification.</p>
"
"Read lines from a file into a Bash array","11393817","<arrays><bash>","213","<p>Latest revision based on comment from <a href=""https://stackoverflow.com/questions/11393817/bash-read-lines-in-file-into-an-array/11393884?noredirect=1#comment56571512_11393884"">BinaryZebra's comment</a>
and <a href=""https://gist.github.com/nhed/d36ea500986d8fb6211c"" rel=""noreferrer"">tested here</a>.  The addition of <code>command eval</code> allows for the expression to be kept in the present execution environment while the expressions before are only held for the duration of the eval.</p>

<p>Use $IFS that has no spaces\tabs, just newlines/CR</p>

<pre><code>$ IFS=$'\r\n' GLOBIGNORE='*' command eval  'XYZ=($(cat /etc/passwd))'
$ echo ""${XYZ[5]}""
sync:x:5:0:sync:/sbin:/bin/sync
</code></pre>

<p>Also note that you may be setting the array just fine but reading it wrong - be sure to use both double-quotes <code>""""</code> and braces <code>{}</code> as in the example above</p>

<hr>

<p><strong>Edit:</strong></p>

<p>Please note the many warnings about my answer in comments about possible glob expansion, specifically <a href=""https://stackoverflow.com/questions/11393817/bash-read-lines-in-file-into-an-array/11393884?noredirect=1#comment35615660_11393884"">gniourf-gniourf's comments</a> about my prior attempts to work around</p>

<p>With all those warnings in mind I'm still leaving this answer here  (yes, bash 4 has been out for many years but I recall that some macs only 2/3 years old have pre-4 as default shell)</p>

<p><strong>Other notes:</strong></p>

<p>Can also follow drizzt's suggestion below and replace a forked subshell+cat with </p>

<pre><code>$(&lt;/etc/passwd)
</code></pre>

<p>The other option I sometimes use is just set IFS into XIFS, then restore after.  See also <a href=""https://stackoverflow.com/a/11394045/652904"">Sorpigal's answer</a> which does not need to bother with this</p>
"
"invalid command code ., despite escaping periods, using sed","19456518","<bash><macos><sed>","213","<p>If you are on a OS X, this probably has nothing to do with the sed command. On the OSX version of <code>sed</code>, the <code>-i</code> option expects an <code>extension</code> argument so your command is actually parsed as the <code>extension</code> argument and the file path is interpreted as the command code.</p>

<p>Try adding the <code>-e</code> argument explicitly and giving <code>''</code> as argument to <code>-i</code>:</p>

<pre><code>find ./ -type f -exec sed -i '' -e ""s/192.168.20.1/new.domain.com/"" {} \;
</code></pre>

<p>See <a href=""https://stackoverflow.com/questions/7573368/in-place-edits-with-sed-on-os-x"">this</a>. </p>
"
"Read values into a shell variable from a pipe","2746553","<linux><bash><pipe>","212","<p>Use</p>

<pre><code>IFS= read var &lt;&lt; EOF
$(foo)
EOF
</code></pre>

<p>You <em>can</em> trick <code>read</code> into accepting from a pipe like this:</p>

<pre><code>echo ""hello world"" | { read test; echo test=$test; }
</code></pre>

<p>or even write a function like this:</p>

<pre><code>read_from_pipe() { read ""$@"" &lt;&amp;0; }
</code></pre>

<p>But there's no point - your variable assignments may not last! A pipeline may spawn a subshell, where the environment is inherited by value, not by reference. This is why <code>read</code> doesn't bother with input from a pipe - it's undefined.</p>

<p>FYI, <a href=""http://www.etalabs.net/sh_tricks.html"" rel=""noreferrer"">http://www.etalabs.net/sh_tricks.html</a> is a nifty collection of the cruft necessary to fight the oddities and incompatibilities of bourne shells, sh.</p>
"
"Save file to specific folder with curl command","16362402","<bash><shell><curl><directory>","212","<p>I don't think you can give a path to curl, but you can CD to the location, download and CD back.</p>

<pre><code>cd target/path &amp;&amp; { curl -O URL ; cd -; }
</code></pre>

<p>Or using subshell.</p>

<pre><code>(cd target/path &amp;&amp; curl -O URL)
</code></pre>

<p>Both ways will only download if path exists. <code>-O</code> keeps remote file name. After download it will return to original location.</p>

<p>If you need to set filename explicitly, you can use small <code>-o</code> option:</p>

<pre><code>curl -o target/path/filename URL
</code></pre>
"
"How to undo the effect of ""set -e"" which makes bash exit immediately if any command fails?","3517162","<bash><exit>","212","<p>With <code>set +e</code>.  Yeah, it's backward that you <em>enable</em> shell options with <code>set -</code> and <em>disable</em> them with <code>set +</code>.  Historical raisins, donchanow.</p>
"
"How to copy a file to multiple directories using the gnu cp command","195655","<linux><bash><shell>","212","<p>No, <code>cp</code> can copy multiple sources but will only copy to a single destination. You need to arrange to invoke <code>cp</code> multiple times - once per destination - for what you want to do; using, as you say, a loop or some other tool.</p>
"
"`date` command on OS X doesn't have ISO 8601 `-I` option?","7216358","<bash><macos><iso8601>","212","<p>You could use </p>

<pre><code>date ""+%Y-%m-%d""
</code></pre>

<p>Or for a fully <a href=""http://en.wikipedia.org/wiki/ISO_8601"" rel=""noreferrer"">ISO-8601 compliant date</a>, use one of the following formats:</p>

<pre><code>date -u +""%Y-%m-%dT%H:%M:%SZ""
</code></pre>

<p>Output:</p>

<pre><code>2011-08-27T23:22:37Z
</code></pre>

<p><em>or</em></p>

<pre><code>date +%Y-%m-%dT%H:%M:%S%z
</code></pre>

<p>Output:</p>

<pre><code>2011-08-27T15:22:37-0800
</code></pre>
"
"Random number from a range in a Bash Script","2556190","<bash><shell><scripting>","211","<pre><code>shuf -i 2000-65000 -n 1
</code></pre>

<p>Enjoy!</p>

<p><em>Edit</em>: The range is inclusive.</p>
"
"How to redirect the output of the time command to a file in Linux?","13356628","<linux><bash><time>","211","<p>Try</p>

<pre><code>{ time sleep 1 ; } 2&gt; time.txt
</code></pre>

<p>which combines the STDERR of ""time"" and your command into time.txt</p>

<p>Or use</p>

<pre><code>{ time sleep 1 2&gt; sleep.stderr ; } 2&gt; time.txt
</code></pre>

<p>which puts STDERR from ""sleep"" into the file ""sleep.stderr"" and only STDERR from ""time"" goes into ""time.txt""</p>
"
"How to get Maven project version to the bash command line","3545292","<bash><command-line><maven-2>","211","<p>The <a href=""http://maven.apache.org/plugins/maven-help-plugin/"" rel=""noreferrer"">Maven Help Plugin</a> is somehow already proposing something for this:</p>

<blockquote>
  <ul>
  <li><a href=""http://maven.apache.org/plugins/maven-help-plugin/evaluate-mojo.html"" rel=""noreferrer""><code>help:evaluate</code></a> evaluates Maven expressions given by the user in an interactive mode.</li>
  </ul>
</blockquote>

<p>Here is how you would invoke it on the command line to get the <code>${project.version}</code>:</p>

<pre><code>mvn org.apache.maven.plugins:maven-help-plugin:2.1.1:evaluate \
    -Dexpression=project.version
</code></pre>
"
"Pass all variables from one shell script to another?","9772036","<bash><shell>","210","<p>You have basically two options:</p>

<ol>
<li>Make the variable an environment variable (<code>export TESTVARIABLE</code>) before executing the 2nd script.</li>
<li>Source the 2nd script, i.e. <code>. test2.sh</code> and it will run in the same shell. This would let you share more complex variables like arrays easily, but also means that the other script could modify variables in the source shell.</li>
</ol>

<p><strong>UPDATE:</strong></p>

<p>To use <code>export</code> to set an environment variable, you can either use an existing variable:</p>

<pre><code>A=10
# ...
export A
</code></pre>

<p>This ought to work in both <code>bash</code> and <code>sh</code>.  <code>bash</code> also allows it to be combined like so:</p>

<pre><code>export A=10
</code></pre>

<p>This also works in <em>my</em> <code>sh</code> (which happens to be <code>bash</code>, you can use <code>echo $SHELL</code> to check).  But I don't believe that that's guaranteed to work in all <code>sh</code>, so best to play it safe and separate them.</p>

<p>Any variable you export in this way will be visible in scripts you execute, for example:</p>

<p><strong>a.sh:</strong></p>

<pre><code>#!/bin/sh

MESSAGE=""hello""
export MESSAGE
./b.sh
</code></pre>

<p><strong>b.sh:</strong></p>

<pre><code>#!/bin/sh

echo ""The message is: $MESSAGE""
</code></pre>

<p>Then:</p>

<pre><code>$ ./a.sh
The message is: hello
</code></pre>

<p>The fact that these are both shell scripts is also just incidental.  Environment variables can be passed to any process you execute, for example if we used python instead it might look like:</p>

<p><strong>a.sh:</strong></p>

<pre><code>#!/bin/sh

MESSAGE=""hello""
export MESSAGE
./b.py
</code></pre>

<p><strong>b.py:</strong></p>

<pre><code>#!/usr/bin/python

import os

print 'The message is:', os.environ['MESSAGE']
</code></pre>

<p><strong>Sourcing:</strong></p>

<p>Instead we could source like this:</p>

<p><strong>a.sh:</strong></p>

<pre><code>#!/bin/sh

MESSAGE=""hello""

. ./b.sh
</code></pre>

<p><strong>b.sh:</strong></p>

<pre><code>#!/bin/sh

echo ""The message is: $MESSAGE""
</code></pre>

<p>Then:</p>

<pre><code>$ ./a.sh
The message is: hello
</code></pre>

<p>This more or less ""imports"" the contents of <code>b.sh</code> directly and executes it in the <em>same shell</em>. Notice that we didn't have to export the variable to access it. This implicitly shares all the variables you have, as well as allows the other script to add/delete/modify variables in the shell.  Of course, in this model both your scripts should be the same language (<code>sh</code> or <code>bash</code>). To give an example how we could pass messages back and forth:</p>

<p><strong>a.sh:</strong></p>

<pre><code>#!/bin/sh

MESSAGE=""hello""

. ./b.sh

echo ""[A] The message is: $MESSAGE""
</code></pre>

<p><strong>b.sh:</strong></p>

<pre><code>#!/bin/sh

echo ""[B] The message is: $MESSAGE""

MESSAGE=""goodbye""
</code></pre>

<p>Then:</p>

<pre><code>$ ./a.sh
[B] The message is: hello
[A] The message is: goodbye
</code></pre>

<p>This works equally well in <code>bash</code>.  It also makes it easy to share more complex data which you could not express as an environment variable (at least without some heavy lifting on your part), like arrays or associative arrays.</p>
"
"Read a variable in bash with a default value","2642585","<bash><shell>","210","<p>You can use <a href=""https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html"" rel=""noreferrer"">parameter expansion</a>, e.g.</p>
<pre><code>read -p &quot;Enter your name [Richard]: &quot; name
name=${name:-Richard}
echo $name
</code></pre>
<p>Including the default value in the prompt between brackets is a fairly common convention</p>
<p>What does the <code>:-Richard</code> part do? From the bash manual:</p>
<blockquote>
<p><code>${parameter:-word}</code>
If parameter is unset or null, the expansion of word is substituted. Otherwise, the value of parameter is substituted.</p>
</blockquote>
<p>Also worth noting that...</p>
<blockquote>
<p>In each of the cases below, word is subject to tilde expansion, parameter expansion, command substitution, and arithmetic expansion.</p>
</blockquote>
<p>So if you use <code>webpath=${webpath:-~/httpdocs}</code> you will get a result of <code>/home/user/expanded/path/httpdocs</code> not <code>~/httpdocs</code>, etc.</p>
"
"Perform an action in every sub-directory using Bash","4000613","<bash><command><directory-traversal>","209","<pre><code>for D in `find . -type d`
do
    //Do whatever you need with D
done
</code></pre>
"
"How to ignore xargs commands if stdin input is empty?","8296710","<bash><centos><xargs>","209","<p>For GNU <code>xargs</code>, you can use the <code>-r</code> or <code>--no-run-if-empty</code> option:</p>

<blockquote>
  <p><code>--no-run-if-empty</code> <br>
         <code>-r</code>  <br>   If the standard input does not contain any nonblanks, do not run the command.  Normally, the command is run once even if there is no input.  This option is a GNU extension.</p>
</blockquote>
"
"Looping over arrays, printing both index and value","6723426","<bash>","208","<p>You would find the array keys with <code>""${!foo[@]}""</code> (<a href=""http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion"" rel=""noreferrer"">reference</a>), so:</p>

<pre><code>for i in ""${!foo[@]}""; do 
  printf ""%s\t%s\n"" ""$i"" ""${foo[$i]}""
done
</code></pre>

<p>Which means that indices will be in <code>$i</code> while the elements themselves have to be accessed via <code>${foo[$i]}</code></p>
"
"Iterate over a list of files with spaces","7039130","<linux><bash><shell>","208","<p>You could replace the word-based iteration with a line-based one:</p>

<pre><code>find . -iname ""foo*"" | while read f
do
    # ... loop body
done
</code></pre>
"
"A variable modified inside a while loop is not remembered","16854280","<bash><while-loop><scope><sh>","208","<pre><code>echo -e $lines | while read line 
    ...
done
</code></pre>

<p>The <code>while</code> loop is executed in a subshell. So any changes you do to the variable will not be available once the subshell exits.</p>

<p>Instead you can use a <a href=""https://www.gnu.org/software/bash/manual/bashref.html#Here-Strings"" rel=""noreferrer""><em>here string</em></a> to re-write the while loop to be in the main shell process; only <code>echo -e $lines</code> will run in a subshell:</p>

<pre><code>while read line
do
    if [[ ""$line"" == ""second line"" ]]
    then
        foo=2
        echo ""Variable \$foo updated to $foo inside if inside while loop""
    fi
    echo ""Value of \$foo in while loop body: $foo""
done &lt;&lt;&lt; ""$(echo -e ""$lines"")""
</code></pre>

<p>You can get rid of the rather ugly <code>echo</code> in the here-string above by expanding the backslash sequences immediately when assigning <code>lines</code>. The <code>$'...'</code> form of quoting can be used there:</p>

<pre><code>lines=$'first line\nsecond line\nthird line'
while read line; do
    ...
done &lt;&lt;&lt; ""$lines""
</code></pre>
"
"[ :Unexpected operator in shell programming","3411048","<linux><bash><shell>","207","<p>There is no mistake in your <strong>bash</strong> script. But you are executing it with <strong>sh</strong> which has a less extensive syntax ;)</p>

<p>So, run <code>bash ./choose.sh</code> instead :)</p>
"
"Longest line in a file","1655372","<bash><shell><utilities>","207","<p>Using wc (GNU coreutils) 7.4:</p>

<pre><code>wc -L filename
</code></pre>

<p>gives:</p>

<pre><code>101 filename
</code></pre>
"
"What does $@ mean in a shell script?","9994295","<linux><bash><shell><unix><sh>","207","<p><code>$@</code> is <strong>all</strong> of the parameters passed to the script. </p>

<p>For instance, if you call <code>./someScript.sh foo bar</code> then <code>$@</code> will be equal to <code>foo bar</code>.</p>

<p>If you do:</p>

<pre><code>./someScript.sh foo bar
</code></pre>

<p>and then inside <code>someScript.sh</code> reference:</p>

<pre><code>umbrella_corp_options ""$@""
</code></pre>

<p>this will be passed to <code>umbrella_corp_options</code> with each individual parameter enclosed in double quotes, allowing to take parameters with blank space from the caller and pass them on.</p>
"
"How to automatically add user account AND password with a Bash script?","2150882","<linux><bash><passwd>","206","<p>You can run the passwd command and send it piped input.  So, do something like:</p>

<pre><code>echo thePassword | passwd theUsername --stdin
</code></pre>
"
"How can I quickly sum all numbers in a file?","2702564","<linux><perl><bash><shell><awk>","206","<p>For a Perl one-liner, it's basically the same thing as the <code>awk</code> solution in <a href=""https://stackoverflow.com/questions/2702564/script-to-sum-all-numbers-in-a-file-linux/2702577#2702577"">Ayman Hourieh's answer</a>:</p>

<pre><code> % perl -nle '$sum += $_ } END { print $sum'
</code></pre>

<p>If you're curious what Perl one-liners do, you can deparse them:</p>

<pre><code> %  perl -MO=Deparse -nle '$sum += $_ } END { print $sum'
</code></pre>

<p>The result is a more verbose version of the program, in a form that no one would ever write on their own:</p>

<pre><code>BEGIN { $/ = ""\n""; $\ = ""\n""; }
LINE: while (defined($_ = &lt;ARGV&gt;)) {
    chomp $_;
    $sum += $_;
}
sub END {
    print $sum;
}
-e syntax OK
</code></pre>

<p>Just for giggles, I tried this with a file containing 1,000,000 numbers (in the range 0 - 9,999). On my Mac Pro, it returns virtually instantaneously. That's too bad, because I was hoping using <code>mmap</code> would be really fast, but it's just the same time:</p>

<pre><code>use 5.010;
use File::Map qw(map_file);

map_file my $map, $ARGV[0];

$sum += $1 while $map =~ m/(\d+)/g;

say $sum;
</code></pre>
"
"When to wrap quotes around a shell variable?","10067266","<linux><bash><shell><unix><quotes>","205","<p>General rule: quote it if it can either be empty or contain spaces (or any whitespace really) or special characters (wildcards). Not quoting strings with spaces often leads to the shell breaking apart a single argument into many.</p>

<p><code>$?</code> doesn't need quotes since it's a numeric value. Whether <code>$URL</code> needs it depends on what you allow in there and whether you still want an argument if it's empty.</p>

<p>I tend to always quote strings just out of habit since it's safer that way.</p>
"
"How to delete files older than X hours","249578","<bash>","204","<p>Does your <a href=""http://man7.org/linux/man-pages/man1/find.1.html"" rel=""noreferrer""><code>find</code></a> have the <code>-mmin</code> option? That can let you test the number of mins since last modification:</p>

<pre><code>find $LOCATION -name $REQUIRED_FILES -type f -mmin +360 -delete
</code></pre>

<p>Or maybe look at using <a href=""http://linux.about.com/library/cmd/blcmdl8_tmpwatch.htm"" rel=""noreferrer""><code>tmpwatch</code></a> to do the same job. phjr also recommended <a href=""http://linux.about.com/cs/linux101/g/tmpreaper.htm"" rel=""noreferrer""><code>tmpreaper</code></a> in the comments.</p>
"
"How to slice an array in Bash","1335815","<arrays><bash><slice>","204","<p>See the <a href=""https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion"" rel=""noreferrer"">Parameter Expansion</a> section in the Bash <code>man</code> page. <code>A[@]</code> returns the contents of the array, <code>:1:2</code> takes a slice of length 2, starting at index 1. </p>

<pre><code>A=( foo bar ""a  b c"" 42 )
B=(""${A[@]:1:2}"")
C=(""${A[@]:1}"")       # slice to the end of the array
echo ""${B[@]}""        # bar a  b c
echo ""${B[1]}""        # a  b c
echo ""${C[@]}""        # bar a  b c 42
echo ""${C[@]: -2:2}""  # a  b c 42 # The space before the - is necesssary
</code></pre>

<p>Note that the fact that ""a  b c"" is one array element (and that it contains an extra space) is preserved.</p>
"
"Using variables inside a bash heredoc","4937792","<bash><variables><sh><heredoc>","204","<p>In answer to your first question, there's no parameter substitution because you've put the delimiter in quotes - <a href=""http://www.gnu.org/software/bash/manual/bashref.html#Redirections"" rel=""noreferrer"">the bash manual says</a>:</p>

<blockquote>
  <p>The format of here-documents is:</p>

<pre><code>      &lt;&lt;[-]word
              here-document
      delimiter
</code></pre>
  
  <p>No  parameter expansion, command substitution, arithmetic expansion, or
  pathname expansion is performed on <em>word</em>.  If any characters in <em>word</em> are
  quoted,  the  <em>delimiter</em> is the result of quote removal on word, and the
  lines in the here-document are not expanded.  If <em>word</em> is unquoted,  all
  lines  of  the here-document are subjected to parameter expansion, command substitution, and arithmetic expansion. [...]</p>
</blockquote>

<p>If you change your first example to use <code>&lt;&lt;EOF</code> instead of <code>&lt;&lt; ""EOF""</code> you'll find that it works.</p>

<p>In your second example, the shell invokes <code>sudo</code> only with the parameter <code>cat</code>, and the redirection applies to the output of <code>sudo cat</code> as the original user.  It'll work if you try:</p>

<pre><code>sudo sh -c ""cat &gt; /path/to/outfile"" &lt;&lt;EOT
my text...
EOT
</code></pre>
"
"How to apply shell command to each line of a command output?","2711001","<bash>","204","<p>It's probably easiest to use <code>xargs</code>. In your case:</p>

<pre><code>ls -1 | xargs -L1 echo
</code></pre>

<p>The <code>-L</code> flag ensures the input is read properly. From the man page of <code>xargs</code>:</p>

<pre><code>-L number
    Call utility for every number non-empty lines read. 
    A line ending with a space continues to the next non-empty line. [...]
</code></pre>
"
"Change the current directory from a Bash script","874452","<bash><environment>","204","<p>You need to convert your script to a shell function:</p>

<pre><code>#!/bin/bash
#
# this script should not be run directly,
# instead you need to source it from your .bashrc,
# by adding this line:
#   . ~/bin/myprog.sh
#

function myprog() {
  A=$1
  B=$2
  echo ""aaa ${A} bbb ${B} ccc""
  cd /proc
}
</code></pre>

<p>The reason is that each process has its own current directory, and when you execute a program from the shell it is run in a new process. The standard ""cd"", ""pushd"" and ""popd"" are builtin to the shell interpreter so that they affect the shell process.</p>

<p>By making your program a shell function, you are adding your own in-process command and then any directory change gets reflected in the shell process.</p>
"
"Repeatedly run a shell command until it fails?","12967232","<bash>","204","<p><code>while</code> takes a command to execute, so you can use the simpler</p>

<pre><code>while ./runtest; do :; done
</code></pre>

<p>This will stop the loop when <code>./runtest</code> returns a <em>nonzero</em> exit code (which is usually indicative of failure).</p>

<p>To further simplify your current solution though, you should just change your untilfail script to look like this:</p>

<pre><code>#!/bin/bash

while ""$@""; do :; done
</code></pre>

<p>And then you can call it with whatever command you're already using: </p>

<pre><code>untilfail ./runTest --and val1,val2 -o option1 ""argument two""
</code></pre>
"
"What command means ""do nothing"" in a conditional in Bash?","17583578","<bash><conditional><noop>","203","<p>The no-op command in shell is <code>:</code> (colon).</p>

<pre><code>if [ ""$a"" -ge 10 ]
then
    :
elif [ ""$a"" -le 5 ]
then
    echo ""1""
else
    echo ""2""
fi
</code></pre>

<p>From the <a href=""https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html#Bourne-Shell-Builtins"" rel=""noreferrer"">bash manual</a>:</p>

<blockquote>
  <p><code>:</code> (a colon)<br>
  Do nothing beyond expanding arguments and performing redirections. The return status is zero.</p>
</blockquote>
"
"How to check if a file is empty in Bash?","9964823","<linux><bash><unix><file-handling><is-empty>","203","<p>Misspellings are irritating, aren't they?  Check your spelling of <code>empty</code>, but then also try this:</p>

<pre><code>#!/bin/bash -e

if [ -s diff.txt ]
then
        rm -f empty.txt
        touch full.txt
else
        rm -f full.txt
        touch empty.txt
fi
</code></pre>

<p>I like shell scripting a lot, but one disadvantage of it is that the shell cannot help you when you misspell, whereas a compiler like your C++ compiler can help you.</p>

<p>Notice incidentally that I have swapped the roles of <code>empty.txt</code> and <code>full.txt</code>, as @Matthias suggests.</p>
"
"Correct Bash and shell script variable capitalization","673055","<bash><shell><scripting><naming-conventions><capitalization>","203","<p>By convention, environment variables (<code>PAGER</code>, <code>EDITOR</code>, ...) and internal shell variables (<code>SHELL</code>, <code>BASH_VERSION</code>, ...) are capitalized. All other variable names should be lower case.</p>

<p>Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.</p>

<p>Keeping to this convention, you can rest assured that you don't need to know every environment variable used by UNIX tools or shells in order to avoid overwriting them.  If it's your variable, lowercase it.  If you export it, uppercase it.</p>
"
"RE error: illegal byte sequence on Mac OS X","19242275","<regex><macos><bash><sed>","202","<p><sup>A sample command that exhibits the symptom: <code>sed 's/./@/' &lt;&lt;&lt;$'\xfc'</code> fails, because byte <code>0xfc</code> is not a valid UTF-8 char.<br>
Note that, by contrast, <em>GNU</em> <code>sed</code> (Linux, but also installable on macOS) simply passes the invalid byte through, without reporting an error.</sup></p>

<p>Using the <strong><a href=""https://stackoverflow.com/a/19770395/45375"">formerly accepted answer</a> is an option if you don't mind losing support for your true locale</strong> (if you're on a US system and you never need to deal with foreign characters, that may be fine.)</p>

<p>However, the <strong>same effect can be had <em>ad-hoc</em> for a <em>single command</em> only</strong>:</p>

<pre><code>LC_ALL=C sed -i """" 's|""iphoneos-cross"",""llvm-gcc:-O3|""iphoneos-cross"",""clang:-Os|g' Configure
</code></pre>

<p>Note: What matters is an <em>effective</em> <code>LC_CTYPE</code> setting of <code>C</code>, so <code>LC_CTYPE=C sed ...</code> would <em>normally</em> also work, but if <code>LC_ALL</code> happens to be set (to something other than <code>C</code>), it will override individual <code>LC_*</code>-category variables such as <code>LC_CTYPE</code>. Thus, the most robust approach is to set <code>LC_ALL</code>.</p>

<p>However, (effectively) setting <code>LC_CTYPE</code> to <code>C</code> treats strings <strong>as if each byte were its own character</strong> (<em>no</em> interpretation based on encoding rules is performed), with <strong>no regard</strong> for the - multibyte-on-demand - <strong>UTF-8 encoding</strong> that OS X employs by default, where <strong>foreign characters</strong> have <strong>multibyte encodings</strong>.</p>

<p>In a nutshell: <strong>setting <code>LC_CTYPE</code> to <code>C</code></strong> causes the shell and utilities to only recognize basic English letters as letters (the ones in the 7-bit ASCII range), so that <strong>foreign chars. will not be treated as letters</strong>, causing, for instance, upper-/lowercase conversions to fail.</p>

<p>Again, this may be fine if you needn't <em>match</em> multibyte-encoded characters such as <code>é</code>, and simply want to <em>pass such characters through</em>.</p>

<p>If this is insufficient and/or you want to <strong>understand the cause</strong> of the original error (including determining what input bytes caused the problem) and <strong>perform encoding conversions</strong> on demand, <strong>read on</strong> below.</p>

<hr>

<p>The problem is that the input file's encoding does not match the shell's.<br>
More specifically, <strong>the input file contains characters encoded in a way that is not valid in UTF-8</strong> (as @Klas Lindbäck stated in a comment) - that's what the <code>sed</code> error message is trying to say by <code>invalid byte sequence</code>.</p>

<p>Most likely, your input file uses a <strong>single-byte 8-bit encoding</strong> such as <code>ISO-8859-1</code>, frequently used to encode ""Western European"" languages.</p>

<p><strong>Example:</strong> </p>

<p>The accented letter <code>à</code> has Unicode codepoint <code>0xE0</code> (224) - the same as in <code>ISO-8859-1</code>. However, due to the nature of <em>UTF-8</em> encoding, this single codepoint is represented as <em>2</em> bytes - <code>0xC3 0xA0</code>, whereas trying to pass the <em>single byte</em> <code>0xE0</code> is <em>invalid</em> under UTF-8.</p>

<p>Here's a <strong>demonstration of the problem</strong> using the string <code>voilà</code> encoded as <code>ISO-8859-1</code>, with the <code>à</code> represented as <em>one</em> byte (via an ANSI-C-quoted bash string (<code>$'...'</code>) that uses <code>\x{e0}</code> to create the byte):</p>

<p>Note that the <code>sed</code> command is effectively a no-op that simply passes the input through, but we need it to provoke the error:</p>

<pre><code>  # -&gt; 'illegal byte sequence': byte 0xE0 is not a valid char.
sed 's/.*/&amp;/' &lt;&lt;&lt;$'voil\x{e0}'
</code></pre>

<p>To simply <strong><em>ignore</em> the problem</strong>, the above <code>LCTYPE=C</code> approach can be used:</p>

<pre><code>  # No error, bytes are passed through ('á' will render as '?', though).
LC_CTYPE=C sed 's/.*/&amp;/' &lt;&lt;&lt;$'voil\x{e0}'
</code></pre>

<p>If you want to <strong>determine which parts of the input cause the problem</strong>, try the following:</p>

<pre><code>  # Convert bytes in the 8-bit range (high bit set) to hex. representation.
  # -&gt; 'voil\x{e0}'
iconv -f ASCII --byte-subst='\x{%02x}' &lt;&lt;&lt;$'voil\x{e0}'
</code></pre>

<p>The output will show you all bytes that have the high bit set (bytes that exceed the 7-bit ASCII range) in hexadecimal form. (Note, however, that that also includes correctly encoded UTF-8 multibyte sequences - a more sophisticated approach would be needed to specifically identify invalid-in-UTF-8 bytes.)</p>

<hr>

<p><strong>Performing encoding conversions on demand</strong>:</p>

<p>Standard utility <code>iconv</code> can be used to convert to (<code>-t</code>) and/or from (<code>-f</code>) encodings; <code>iconv -l</code> lists all supported ones.</p>

<p><strong>Examples:</strong></p>

<p>Convert FROM <code>ISO-8859-1</code> to the encoding in effect in the shell (based on <code>LC_CTYPE</code>, which is <code>UTF-8</code>-based by default), building on the above example:</p>

<pre><code>  # Converts to UTF-8; output renders correctly as 'voilà'
sed 's/.*/&amp;/' &lt;&lt;&lt;""$(iconv -f ISO-8859-1 &lt;&lt;&lt;$'voil\x{e0}')""
</code></pre>

<p>Note that this <em>conversion allows you to properly match foreign characters</em>:</p>

<pre><code>  # Correctly matches 'à' and replaces it with 'ü': -&gt; 'voilü'
sed 's/à/ü/' &lt;&lt;&lt;""$(iconv -f ISO-8859-1 &lt;&lt;&lt;$'voil\x{e0}')""
</code></pre>

<p>To convert the input BACK to <code>ISO-8859-1</code> after processing, simply pipe the result to another <code>iconv</code> command:</p>

<pre><code>sed 's/à/ü/' &lt;&lt;&lt;""$(iconv -f ISO-8859-1 &lt;&lt;&lt;$'voil\x{e0}')"" | iconv -t ISO-8859-1
</code></pre>
"
"How to gzip all files in all sub-directories into one compressed file in bash","12331633","<linux><bash><shell><gzip>","202","<pre><code>tar -zcvf compressFileName.tar.gz folderToCompress
</code></pre>

<p>everything in folderToCompress will go to compressFileName</p>

<p>Edit: After review and comments I realized that people may get confused with compressFileName without an extension. If you want you can use .tar.gz extension(as suggested) with the compressFileName</p>
"
"find -exec a shell function in Linux?","4321456","<linux><bash><shell><find><bsd>","201","<p>Since only the shell knows how to run shell functions, you have to run a shell to run a function.  You also need to mark your function for export with <code>export -f</code>, otherwise the subshell won't inherit them:</p>

<pre><code>export -f dosomething
find . -exec bash -c 'dosomething ""$0""' {} \;
</code></pre>
"
"Copy Paste in Bash on Ubuntu on Windows","38832230","<bash><ubuntu><command-line><windows-10><windows-subsystem-for-linux>","201","<p><strong>Update 2019/04/16:</strong> It seems copy/paste is now officially supported in Windows build &gt;= 17643. Take a look at <a href=""https://stackoverflow.com/a/50050642/2047843"">Rich Turner's answer</a>. This can be enabled through the same settings menu described below by clicking the checkbox next to &quot;Use Ctrl+Shift+C/V as Copy/Paste&quot;.</p>
<hr />
<p>Another solution would be to enable &quot;QuickEdit Mode&quot; and then you can paste by right-clicking in the terminal.</p>
<p>To enable QuickEdit Mode, right-click on the toolbar (or simply click on the icon in the upper left corner), select Properties, and in the Options tab, click the checkbox next to QuickEdit Mode.</p>
<p>With this mode enabled, you can also copy text in the terminal by clicking and dragging. Once a selection is made, you can press Enter or right-click to copy.</p>
"
"How do I get bash completion to work with aliases?","342969","<git><bash><shell><unix><autocomplete>","201","<p>As stated in the comments above,</p>

<pre><code>complete -o default -o nospace -F _git_checkout gco
</code></pre>

<p>will no longer work. However, there's a <code>__git_complete</code> function in git-completion.bash which can be used to set up completion for aliases like so:</p>

<pre><code>__git_complete gco _git_checkout
</code></pre>
"
"How to create nonexistent subdirectories recursively using Bash?","1731767","<bash><shell><recursion><subdirectory>","200","<p>You can use the <code>-p</code> parameter, which is <a href=""http://unixhelp.ed.ac.uk/CGI/man-cgi?mkdir"" rel=""noreferrer"">documented as</a>:</p>
<blockquote>
<p>-p, --parents</p>
<p>no error if existing, make parent directories as needed</p>
</blockquote>
<p>So:</p>
<pre><code>mkdir -p &quot;$BACKUP_DIR/$client/$year/$month/$day&quot;
</code></pre>
"
"Passing arrays as parameters in bash","1063347","<arrays><bash>","199","<p>You can pass <strong>multiple arrays as arguments</strong> using something like this:</p>

<pre><code>takes_ary_as_arg()
{
    declare -a argAry1=(""${!1}"")
    echo ""${argAry1[@]}""

    declare -a argAry2=(""${!2}"")
    echo ""${argAry2[@]}""
}
try_with_local_arys()
{
    # array variables could have local scope
    local descTable=(
        ""sli4-iread""
        ""sli4-iwrite""
        ""sli3-iread""
        ""sli3-iwrite""
    )
    local optsTable=(
        ""--msix  --iread""
        ""--msix  --iwrite""
        ""--msi   --iread""
        ""--msi   --iwrite""
    )
    takes_ary_as_arg descTable[@] optsTable[@]
}
try_with_local_arys
</code></pre>

<h3>will echo:</h3>

<pre><code>sli4-iread sli4-iwrite sli3-iread sli3-iwrite  
--msix  --iread --msix  --iwrite --msi   --iread --msi   --iwrite
</code></pre>

<p><strong>Edit/notes:</strong> (from comments below)</p>

<ul>
<li><code>descTable</code> and <code>optsTable</code> are passed as names and are expanded in the function. Thus no <code>$</code> is needed when given as parameters.</li>
<li>Note that this still works even with <code>descTable</code> etc being defined with <code>local</code>, because locals are visible to the functions they call.</li>
<li>The <code>!</code> in <code>${!1}</code> expands the arg 1 variable.</li>
<li><code>declare -a</code> just makes the indexed array explicit, it is not strictly necessary.</li>
</ul>
"
"Efficiently test if a port is open on Linux?","9609130","<linux><bash><shell><port>","199","<p>A surprise I found out recently is that Bash natively supports <a href=""http://tldp.org/LDP/abs/html/devref1.html"" rel=""noreferrer"">tcp connections as file descriptors</a>. To use:</p>

<pre><code>exec 6&lt;&gt;/dev/tcp/ip.addr.of.server/445
echo -e ""GET / HTTP/1.0\n"" &gt;&amp;6
cat &lt;&amp;6
</code></pre>

<p>I'm using 6 as the file descriptor because 0,1,2 are stdin, stdout, and stderr. 5 is sometimes used by <a href=""http://tldp.org/LDP/abs/html/io-redirection.html"" rel=""noreferrer"">Bash for child processes</a>, so 3,4,6,7,8, and 9 should be safe.</p>

<p>As per the comment below, to test for listening on a <em>local server</em> in a script:</p>

<pre><code>exec 6&lt;&gt;/dev/tcp/127.0.0.1/445 || echo ""No one is listening!""
exec 6&gt;&amp;- # close output connection
exec 6&lt;&amp;- # close input connection
</code></pre>

<p>To determine if someone is listening, attempt to connect by loopback. If it fails, then the port is closed or we aren't allowed access. Afterwards, close the connection. </p>

<p>Modify this for your use case, such as sending an email, exiting the script on failure, or starting the required service.</p>
"
"How to count items in JSON object using command line?","21334348","<json><bash><curl><jq>","199","<p>Just throwing another solution in the mix...</p>

<p>Try <a href=""http://stedolan.github.io/jq/"" rel=""noreferrer""><code>jq</code></a>, a lightweight and flexible command-line JSON processor:</p>

<pre><code>jq length /tmp/test.json
</code></pre>

<p>Prints the length of the array of objects.</p>
"
"Execute bash script from URL","5735666","<linux><bash><curl>","199","<pre><code>source &lt;(curl -s http://mywebsite.com/myscript.txt)
</code></pre>

<p>ought to do it.  Alternately, leave off the initial redirection on yours, which is redirecting standard input; <code>bash</code> takes a filename to execute just fine without redirection, and <code>&lt;(command)</code> syntax provides a path.</p>

<pre><code>bash &lt;(curl -s http://mywebsite.com/myscript.txt)
</code></pre>

<p>It may be clearer if you look at the output of <code>echo &lt;(cat /dev/null)</code></p>
"
"linux: kill background task","1624691","<linux><bash><unix><kill><job-control>","198","<p>There's a special variable for this in bash:</p>

<pre><code>kill $!
</code></pre>

<p>$! expands to the PID of the last process executed in the background.</p>
"
"Copy folder recursively, excluding some folders","2193584","<bash><unix><shell><scripting>","198","<p>Use rsync:</p>

<pre><code>rsync -av --exclude='path1/to/exclude' --exclude='path2/to/exclude' source destination
</code></pre>

<p>Note that using <code>source</code> and <code>source/</code> are different.  A trailing slash means to copy the contents of the folder <code>source</code> into <code>destination</code>.  Without the trailing slash, it means copy the folder <code>source</code> into <code>destination</code>.</p>

<p>Alternatively, if you have lots of directories (or files) to exclude, you can use <code>--exclude-from=FILE</code>, where <code>FILE</code> is the name of a file containing files or directories to exclude.</p>

<p><code>--exclude</code> may also contain wildcards, such as <code>--exclude=*/.svn*</code></p>
"
"How do I create a Bash alias?","8967843","<macos><bash><shell>","197","<p>You can add an <code>alias</code> or a <code>function</code> in your startup script file. Usually this is <code>.bashrc</code>, <code>.bash_login</code> or <code>.profile</code> file in your home directory. </p>

<p>Since these files are hidden you will have to do an <code>ls -a</code> to list them. If you don't have one you can create one.</p>

<hr>

<p>If I remember correctly, when I had bought my Mac, the <code>.bash_login</code> file wasn't there. I had to create it for myself so that I could put <code>prompt info</code>, <code>alias</code>, <code>functions</code>, etc. in it. </p>

<p>Here are the steps if you would like to create one:</p>

<ol>
<li>Start up Terminal</li>
<li>Type <code>cd ~/</code> to go to your home folder</li>
<li>Type <code>touch .bash_profile</code> to create your new file.</li>
<li>Edit <code>.bash_profile</code> with your favorite editor (or you can just type <code>open -e .bash_profile</code> to open it in TextEdit.</li>
<li>Type <code>. .bash_profile</code> to reload <code>.bash_profile</code> and update any alias you add.</li>
</ol>
"
"Any way to exit bash script, but not quitting the terminal","9640660","<linux><bash>","197","<p>The ""problem"" really is that you're sourcing and not executing the script. When you source a file, its contents will be executed in the current shell, instead of spawning a subshell. So everything, including exit, will affect the current shell.</p>

<p>Instead of using <code>exit</code>, you will want to use <code>return</code>.</p>
"
"What is the benefit of using $() instead of backticks in shell scripts?","9449778","<bash><syntax><sh><backticks>","197","<p>The major one is the ability to <em>nest</em> them, commands within commands, without losing your sanity trying to figure out if some form of escaping will work on the backticks.</p>

<p>An example, though somewhat contrived:</p>

<pre><code>deps=$(find /dir -name $(ls -1tr 201112[0-9][0-9]*.txt | tail -1l) -print)
</code></pre>

<p>which will give you a list of all files in the <code>/dir</code> directory tree which have the same name as the earliest dated text file from December 2011 <sup>(a)</sup>.</p>

<p>Another example would be something like getting the name (not the full path) of the parent directory:</p>

<pre><code>pax&gt; cd /home/pax/xyzzy/plugh
pax&gt; parent=$(basename $(dirname $PWD))
pax&gt; echo $parent
xyzzy
</code></pre>

<hr>

<p><sup>(a)</sup> Now that <em>specific</em> command may not actually work, I haven't tested the functionality. So, if you vote me down for it, you've lost sight of the intent :-) It's meant just as an illustration as to how you can nest, not as a bug-free production-ready snippet.</p>
"
"Delete all lines beginning with a # from a file","8206280","<bash><sed>","197","<p>This can be done with a <a href=""http://www.grymoire.com/Unix/Sed.html#uh-30"" rel=""noreferrer"">sed one-liner</a>:</p>

<pre><code>sed '/^#/d'
</code></pre>

<p>This says, ""find all lines that start with # and delete them, leaving everything else.""</p>
"
"Bash script processing limited number of commands in parallel","19543139","<linux><bash><shell>","197","<p>Use the <code>wait</code> built-in:</p>

<pre><code>process1 &amp;
process2 &amp;
process3 &amp;
process4 &amp;
wait
process5 &amp;
process6 &amp;
process7 &amp;
process8 &amp;
wait
</code></pre>

<p>For the above example, 4 processes <code>process1</code> ... <code>process4</code> would be started in the background, and the shell would wait until those are completed before starting the next set.</p>

<p>From the <a href=""http://www.gnu.org/software/bash/manual/bashref.html#Job-Control-Builtins"" rel=""noreferrer"">GNU manual</a>:</p>

<blockquote>
<pre><code>wait [jobspec or pid ...]
</code></pre>
  
  <p>Wait until the child process specified by each process ID pid or job specification jobspec exits and return the exit status of the last
  command waited for. If a job spec is given, all processes in the job
  are waited for. If no arguments are given, all currently active child
  processes are waited for, and the return status is zero. If neither
  jobspec nor pid specifies an active child process of the shell, the
  return status is 127.</p>
</blockquote>
"
"How do I edit $PATH (.bash_profile) on OSX?","30461201","<bash><macos><terminal><path><osx-yosemite>","196","<p>You have to open that file with a text editor and then save it.</p>

<pre><code>touch ~/.bash_profile; open ~/.bash_profile
</code></pre>

<p>It will open the file with TextEdit, paste your things and then save it. If you open it again you'll find your edits.</p>

<p>You can use other editors:</p>

<pre><code>nano ~/.bash_profile
mate ~/.bash_profile
vim ~/.bash_profile
</code></pre>

<p>But if you don't know how to use them, it's easier to use the <code>open</code> approach.</p>

<hr>

<p>Alternatively, you can rely on <code>pbpaste</code>. Copy</p>

<pre><code>export ANDROID_HOME=/&lt;installation location&gt;/android-sdk-macosx
export PATH=${PATH}:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools
</code></pre>

<p>in the system clipboard and then in a shell run</p>

<pre><code>pbpaste &gt; ~/.bash_profile
</code></pre>

<hr>

<p>Or alternatively you can also use <code>cat</code></p>

<pre><code>cat &gt; ~/.bash_profile
</code></pre>

<p>(now <code>cat</code> waits for input: paste the two export definitions and then hit ctrl-D).</p>
"
"How do I limit the number of results returned from grep?","5013151","<linux><bash><unix><sh>","195","<p>The <code>-m</code> option is probably what you're looking for:</p>

<pre><code>grep -m 10 PATTERN [FILE]
</code></pre>

<p>From <code>man grep</code>:</p>

<pre class=""lang-none prettyprint-override""><code>-m NUM, --max-count=NUM
        Stop reading a file after NUM matching lines.  If the  input  is
        standard  input  from a regular file, and NUM matching lines are
        output, grep ensures that the standard input  is  positioned  to
        just  after the last matching line before exiting, regardless of
        the presence of trailing context lines.  This enables a  calling
        process  to resume a search.
</code></pre>

<p>Note: grep stops reading the file once the specified number of matches have been found!</p>
"
"How to store standard error in a variable","962255","<bash><shell><redirect><variables><stderr>","194","<p>It would be neater to capture the error file thus:</p>

<pre><code>ERROR=$(&lt;/tmp/Error)
</code></pre>

<p>The shell recognizes this and doesn't have to run '<code>cat</code>' to get the data.</p>

<p>The bigger question is hard.  I don't think there's an easy way to do it.  You'd have to build the entire pipeline into the sub-shell, eventually sending its final standard output to a file, so that you can redirect the errors to standard output.</p>

<pre><code>ERROR=$( { ./useless.sh | sed s/Output/Useless/ &gt; outfile; } 2&gt;&amp;1 )
</code></pre>

<p>Note that the semi-colon is needed (in classic shells - Bourne, Korn - for sure; probably in Bash too).  The '<code>{}</code>' does I/O redirection over the enclosed commands.  As written, it would capture errors from <code>sed</code> too.</p>

<blockquote>
  <p><strong>WARNING:</strong> Formally untested code - use at own risk.</p>
</blockquote>
"
"Is there a bash command which counts files?","11307257","<bash>","194","<p>This simple one-liner should work in any shell, not just bash:</p>

<pre><code>ls -1q log* | wc -l
</code></pre>

<p>ls -1q will give you one line per file, even if they contain whitespace or special characters such as newlines.</p>

<p>The output is piped to wc -l, which counts the number of lines.</p>
"
"An ""and"" operator for an ""if"" statement in Bash","13408493","<bash><if-statement>","194","<p>What you have should work, unless <code>${STATUS}</code> is empty.  It would probably be better to do:</p>

<pre><code>if ! [ ""${STATUS}"" -eq 200 ] 2&gt; /dev/null &amp;&amp; [ ""${STRING}"" != ""${VALUE}"" ]; then
</code></pre>

<p>or</p>

<pre><code>if [ ""${STATUS}"" != 200 ] &amp;&amp; [ ""${STRING}"" != ""${VALUE}"" ]; then
</code></pre>

<p>It's hard to say, since you haven't shown us exactly what is going wrong with your script.</p>

<p>Personal opinion: never use <code>[[</code>.  It suppresses important error messages and is not portable to different shells.  </p>
"
"How to check if a process id (PID) exists","3043978","<bash><process><pid>","193","<p>To check for the existence of a process, use</p>

<pre><code>kill -0 $pid
</code></pre>

<p>But just as @unwind said, if you're going to kill it anyway, just</p>

<pre><code>kill $pid
</code></pre>

<p>or you will have a race condition.</p>

<p>If you want to ignore the text output of <code>kill</code> and do something based on the exit code, you can</p>

<pre><code>if ! kill $pid &gt; /dev/null 2&gt;&amp;1; then
    echo ""Could not send SIGTERM to process $pid"" &gt;&amp;2
fi
</code></pre>
"
"Laravel PHP Command Not Found","26376516","<php><bash><laravel>","193","<p>Ok, I did that and it works:</p>

<pre><code>nano ~/.bash_profile 
</code></pre>

<p>And paste</p>

<pre><code>export PATH=~/.composer/vendor/bin:$PATH
</code></pre>

<p>do <code>source ~/.bash_profile</code> and enjoy ;)</p>

<p><strong>Important</strong>: If you want to know the difference between <em>bash_profile</em> and <em>bashrc</em> please check this <a href=""http://www.joshstaiger.org/archives/2005/07/bash_profile_vs.html"" rel=""noreferrer"">link</a></p>

<p><strong>Note:</strong> For Ubuntu 16.04 running laravel 5.1, the path is: ~/.config/composer/vendor/bin</p>

<p><strong>On other platforms:</strong> To check where your Composer global directory is, run <code>composer global about</code>. Add <code>/vendor/bin</code> to the directory that gets listed after ""Changed current directory to ..."" to get the path you should add to your <code>PATH</code>.</p>
"
"Generating random number between 1 and 10 in Bash Shell Script","8988824","<bash>","193","<pre><code>$(( ( RANDOM % 10 )  + 1 ))
</code></pre>

<p><strong>EDIT.</strong> Changed brackets into parenthesis according to the comment.
<a href=""http://web.archive.org/web/20150206070451/http://islandlinux.org/howto/generate-random-numbers-bash-scripting"">http://web.archive.org/web/20150206070451/http://islandlinux.org/howto/generate-random-numbers-bash-scripting</a></p>
"
"How do I negate a test with regular expressions in a bash script?","4542732","<regex><bash><conditional><negate>","192","<p>You had it right, just put a space between the <code>!</code> and the <code>[[</code> like <code>if ! [[</code></p>
"
"Worth switching to zsh for casual use?","43321","<bash><shell><zsh>","192","<p>For casual use you are probably better off sticking with bash and just installing bash completion. </p>

<p>Installing it is pretty easy, grab the bash-completion-20060301.tar.gz from <a href=""http://www.caliban.org/bash/index.shtml#completion"" rel=""noreferrer"">http://www.caliban.org/bash/index.shtml#completion</a> and extract it with </p>

<pre><code>tar -xzvf bash-completion-20060301.tar.gz
</code></pre>

<p>then copy the bash_completion/bash_completion file to /etc with </p>

<pre><code>sudo cp bash_completion/bash_completion /etc
</code></pre>

<p>which will prompt you for your password. You probably will want to make a /etc/bash_completion.d directory for any additional completion scripts (for instance I have the git completion script in there).</p>

<p>Once this is done the last step is to make sure the .bash_profile file in your home directory has </p>

<pre><code>if [ -f /etc/bash_completion ]; then
     . /etc/bash_completion 
fi
</code></pre>

<p>in it to load the completion file when you login. </p>

<p>To test it just open a new terminal, and try completing on cvs and it should show you the cvs options in the list of completions.</p>
"
"Determine if a function exists in bash","85880","<bash><function><testing><scripting>","192","<p>I think you're looking for the 'type' command. It'll tell you whether something is a function, built-in function, external command, or just not defined. Example:</p>

<pre class=""lang-none prettyprint-override""><code>$ LC_ALL=C type foo
bash: type: foo: not found

$ LC_ALL=C type ls
ls is aliased to `ls --color=auto'

$ which type

$ LC_ALL=C type type
type is a shell builtin

$ LC_ALL=C type -t rvm
function

$ if [ -n ""$(LC_ALL=C type -t rvm)"" ] &amp;&amp; [ ""$(LC_ALL=C type -t rvm)"" = function ]; then echo rvm is a function; else echo rvm is NOT a function; fi
rvm is a function
</code></pre>
"
"Only get hash value using md5sum (without filename)","3679296","<bash><shell><md5sum>","192","<p>Well another way :)</p>

<pre><code>md5=`md5sum ${my_iso_file} | awk '{ print $1 }'`
</code></pre>
"
"bash HISTSIZE vs. HISTFILESIZE?","19454837","<bash><unix>","191","<h2>Short answer:</h2>

<p><code>HISTSIZE</code> is the number of lines or commands that are stored in memory in a history list while your bash session is ongoing.</p>

<p><code>HISTFILESIZE</code> is the number of lines or commands that (a) are allowed in the history file at startup time of a session, and (b) are stored in the history file at the end of your bash session for use in future sessions.</p>

<p>Notice the distinction between <code>file</code>: on disk - and <code>list</code>: in memory.</p>

<h2>Long answer:</h2>

<p>All the info above + some examples:</p>

<p><strong>Example 1</strong>:
<code>HISTFILESIZE=10</code> and <code>HISTSIZE=10</code></p>

<ol>
<li>You start your session. </li>
<li>Your HISTFILE (file that stores your bash command history), is truncated to contain HISTFILESIZE=10 lines.</li>
<li>You write 50 lines. </li>
<li>At the end of your 50 commands, only commands 41 to 50 are in your history list, whose size is determined by HISTSIZE=10.</li>
<li>You end your session. </li>
<li>Assuming <code>histappend</code> is not enabled, commands 41 to 50 are saved to your HISTFILE which now has the 10 commands it held at the beginning plus the 10 newly written commands.</li>
<li>Your HISTFILE is truncated to contain HISTFILESIZE=10 lines. </li>
<li>You now have 10 commands in your history - the last 10 that you just typed in the session you just finished.</li>
<li>When you start a new session, you start over at 1 with a HISTFILE of HISTFILESIZE=10.</li>
</ol>

<p><strong>Example 2</strong>:
<code>HISTFILESIZE=10</code> and <code>HISTSIZE=5</code></p>

<ol>
<li>You start your session. </li>
<li>Your HISTFILE (file that stores your bash command history), is truncated to contain at most HISTFILESIZE=10 lines.</li>
<li>You write 50 lines. </li>
<li>At the end of your 50 commands, only commands 46 to 50 are in your history list, whose size is determined by HISTSIZE=5.</li>
<li>You end your session. </li>
<li>Assuming <code>histappend</code> is not enabled, commands 46 to 50 are saved to your HISTFILE which now has the 10 commands it held at the beginning plus the 5 newly written commands. </li>
<li>Your HISTFILE is truncated to contain HISTFILESIZE=10 lines. </li>
<li>You now have 10 commands in your history - 5 from a previous session and the last 5 that you just typed in the session you just finished.</li>
<li>When you start a new session, you start over at 1 with a HISTFILE of HISTFILESIZE=10.</li>
</ol>

<p><strong>Example 3</strong>:
<code>HISTFILESIZE=5</code> and <code>HISTSIZE=10</code></p>

<ol>
<li>You start your session. </li>
<li>Your HISTFILE (file that stores your bash command history), is truncated to contain at most HISTFILESIZE=5 lines.</li>
<li>You write 50 lines. </li>
<li>At the end of your 50 commands, only commands 41 to 50 are in your history list, whose size is determined by HISTSIZE=10.</li>
<li>You end your session. </li>
<li>Assuming <code>histappend</code> is not enabled, commands 41 to 50 are saved to your HISTFILE which now has the 5 commands it held at the beginning plus the 10 newly written commands. </li>
<li>Your HISTFILE is truncated to contain HISTFILESIZE=5 lines. </li>
<li>You now have 5 commands in your history - the last 5 that you just typed in the session you just finished.</li>
<li>When you start a new session, you start over at step 1 with a HISTFILE of HISTFILESIZE=5.</li>
</ol>

<p>Info from <a href=""http://www.unix.com/unix-dummies-questions-answers/191301-histsize-histfilesize.html"" rel=""noreferrer"">elixir_sinari</a>:</p>

<blockquote>
  <p>The history ""file"" is not updated as you type the commands. The
  commands get stored in a ""list"" separately (accessed by the history
  command). The number of these stored commands is controlled by 
  HISTSIZE  value. When the shell (interactive) exits, the last 
  $HISTSIZE  lines are copied/appended to  $HISTFILE  from that ""list"".
  If  HISTFILESIZE  is set, then after this operation, it is ensured
  that only  $HISTFILESIZE  lines (latest) exist in  $HISTFILE . And
  when the shell starts, the ""list"" is initialized from  $HISTFILE  upto
  a maximum of  $HISTSIZE  commands.</p>
</blockquote>

<p>And from the <code>man bash</code> page:</p>

<blockquote>
  <p>The  value
         of  the  HISTSIZE  variable  is used as the number of commands to save in a history list.  The text of the last HISTSIZE commands
  (default 500) is saved.  (...)</p>
  
  <p>On  startup,  the  history  is initialized from the file named by the variable HISTFILE (default ~/.bash_history).  The file named by
  the value of HISTFILE is
         truncated, if necessary, to contain no more than the number of lines specified by the value of HISTFILESIZE.  (...)  When an interactive shell exits, the last $HISTSIZE lines
  are copied from  the  history
         list to $HISTFILE.  If the histappend shell option is enabled (see the description of shopt under SHELL BUILTIN COMMANDS below), the
  lines are appended to the
         history file, otherwise the history file is overwritten.  If HISTFILE is unset, or if the history file is unwritable, the history
  is not saved. (...)  After saving the history, the
  history file  is  truncated
         to contain no more than HISTFILESIZE lines.  If HISTFILESIZE is not set, no truncation is performed.</p>
</blockquote>
"
"How to run cron once, daily at 10pm","8938120","<bash><cron><system><scheduled-tasks>","190","<p>It's running every minute of the hour 22 I guess. Try the following to run it every first minute of the hour 22:</p>

<pre><code>0 22 * * * ....
</code></pre>
"
"How to determine if a process runs inside lxc/Docker?","20010199","<linux><bash><docker>","190","<p>The most reliable way is to check <code>/proc/1/cgroup</code>. It will tell you the control groups of the init process, and when you are <em>not</em> in a container, that will be <code>/</code> for all hierarchies. When you are <em>inside</em> a container, you will see the name of the anchor point. With LXC/Docker containers, it will be something like <code>/lxc/&lt;containerid&gt;</code> or <code>/docker/&lt;containerid&gt;</code> respectively.</p>
"
"Exclude .svn directories from grep","1491514","<linux><bash><svn><grep>","190","<p>If you have GNU Grep, it should work like this:</p>

<pre><code>grep --exclude-dir="".svn""
</code></pre>

<p>If happen to be on a Unix System without GNU Grep, try the following:</p>

<pre><code>grep -R ""whatever you like"" *|grep -v ""\.svn/*"" 
</code></pre>
"
"How to compare two strings in dot separated version format in Bash?","4023830","<linux><bash><versioning>","189","<p>Here is a pure Bash version that doesn't require any external utilities:</p>

<pre><code>#!/bin/bash
vercomp () {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i&lt;${#ver2[@]}; i++))
    do
        ver1[i]=0
    done
    for ((i=0; i&lt;${#ver1[@]}; i++))
    do
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} &gt; 10#${ver2[i]}))
        then
            return 1
        fi
        if ((10#${ver1[i]} &lt; 10#${ver2[i]}))
        then
            return 2
        fi
    done
    return 0
}

testvercomp () {
    vercomp $1 $2
    case $? in
        0) op='=';;
        1) op='&gt;';;
        2) op='&lt;';;
    esac
    if [[ $op != $3 ]]
    then
        echo ""FAIL: Expected '$3', Actual '$op', Arg1 '$1', Arg2 '$2'""
    else
        echo ""Pass: '$1 $op $2'""
    fi
}

# Run tests
# argument table format:
# testarg1   testarg2     expected_relationship
echo ""The following tests should pass""
while read -r test
do
    testvercomp $test
done &lt;&lt; EOF
1            1            =
2.1          2.2          &lt;
3.0.4.10     3.0.4.2      &gt;
4.08         4.08.01      &lt;
3.2.1.9.8144 3.2          &gt;
3.2          3.2.1.9.8144 &lt;
1.2          2.1          &lt;
2.1          1.2          &gt;
5.6.7        5.6.7        =
1.01.1       1.1.1        =
1.1.1        1.01.1       =
1            1.0          =
1.0          1            =
1.0.2.0      1.0.2        =
1..0         1.0          =
1.0          1..0         =
EOF

echo ""The following test should fail (test the tester)""
testvercomp 1 1 '&gt;'
</code></pre>

<p>Run the tests:</p>

<pre><code>$ . ./vercomp
The following tests should pass
Pass: '1 = 1'
Pass: '2.1 &lt; 2.2'
Pass: '3.0.4.10 &gt; 3.0.4.2'
Pass: '4.08 &lt; 4.08.01'
Pass: '3.2.1.9.8144 &gt; 3.2'
Pass: '3.2 &lt; 3.2.1.9.8144'
Pass: '1.2 &lt; 2.1'
Pass: '2.1 &gt; 1.2'
Pass: '5.6.7 = 5.6.7'
Pass: '1.01.1 = 1.1.1'
Pass: '1.1.1 = 1.01.1'
Pass: '1 = 1.0'
Pass: '1.0 = 1'
Pass: '1.0.2.0 = 1.0.2'
Pass: '1..0 = 1.0'
Pass: '1.0 = 1..0'
The following test should fail (test the tester)
FAIL: Expected '&gt;', Actual '=', Arg1 '1', Arg2 '1'
</code></pre>
"
"How to merge two files line by line in Bash","3806874","<bash><unix>","188","<p>You can use <a href=""http://ss64.com/bash/paste.html"" rel=""noreferrer""><code>paste</code></a>:</p>

<pre><code>paste file1.txt file2.txt &gt; fileresults.txt
</code></pre>
"
"How do I run multiple background commands in bash in a single line?","14612371","<linux><bash><shell>","188","<p>Exactly how do you want them to run? If you want them to be started in the background and run <em>sequentially</em>, you would do something like this:</p>

<pre><code>(sleep 2; sleep 3) &amp;
</code></pre>

<p>If, on the other hand, you would like them to run in <em>parallel</em> in the background, you can instead do this:</p>

<pre><code>sleep 2 &amp; sleep 3 &amp;
</code></pre>

<p>And the two techniques could be combined, such as:</p>

<pre><code>(sleep 2; echo first finished) &amp; (sleep 3; echo second finished) &amp;
</code></pre>

<p>Bash being bash, there's often a multitude of different techniques to accomplish the same task, although sometimes with subtle differences between them.</p>
"
"Negate if condition in bash script","26475358","<linux><bash><if-statement><negate>","187","<p>You can choose:</p>

<pre><code>if [[ $? -ne 0 ]]; then       # -ne: not equal

if ! [[ $? -eq 0 ]]; then     # -eq: equal

if [[ ! $? -eq 0 ]]; then
</code></pre>

<p><code>!</code> inverts the return of the following expression, respectively.</p>
"
"Passing a string with spaces as a function argument in bash","1983048","<bash><function>","186","<p>you should put quotes and also, your function declaration is wrong.</p>

<pre><code>myFunction()
{
    echo ""$1""
    echo ""$2""
    echo ""$3""
}
</code></pre>

<p>And like the others, it works for me as well. Tell us what version of shell you are using.</p>
"
"How to kill a child process after a given timeout in Bash?","5161193","<linux><bash><unix>","186","<p><em>(As seen in:
<a href=""http://mywiki.wooledge.org/BashFAQ/068"" rel=""noreferrer"">BASH FAQ entry #68: ""How do I run a command, and have it abort (timeout) after N seconds?""</a>)</em></p>

<p>If you don't mind downloading something, use <code>timeout</code> (<code>sudo apt-get install timeout</code>) and use it like: (most Systems have it already installed otherwise use <code>sudo apt-get install coreutils</code>)</p>

<pre><code>timeout 10 ping www.goooooogle.com
</code></pre>

<p>If you don't want to download something, do what timeout does internally:</p>

<pre><code>( cmdpid=$BASHPID; (sleep 10; kill $cmdpid) &amp; exec ping www.goooooogle.com )
</code></pre>

<p>In case that you want to do a timeout for longer bash code, use the second option as such:</p>

<pre><code>( cmdpid=$BASHPID; 
    (sleep 10; kill $cmdpid) \
   &amp; while ! ping -w 1 www.goooooogle.com 
     do 
         echo crap; 
     done )
</code></pre>
"
"Using curl POST with variables defined in bash script functions","17029902","<json><bash><curl><javascript-objects>","186","<p>You don't need to pass the quotes enclosing the custom headers to curl. Also, your variables in the middle of the <code>data</code> argument should be quoted.</p>

<p>First, write a function that generates the post data of your script. This saves you from all sort of headaches concerning shell quoting and makes it easier to read an maintain the script than feeding the post data on curl's invocation line as in your attempt:</p>

<pre><code>generate_post_data()
{
  cat &lt;&lt;EOF
{
  ""account"": {
    ""email"": ""$email"",
    ""screenName"": ""$screenName"",
    ""type"": ""$theType"",
    ""passwordSettings"": {
      ""password"": ""$password"",
      ""passwordConfirm"": ""$password""
    }
  },
  ""firstName"": ""$firstName"",
  ""lastName"": ""$lastName"",
  ""middleName"": ""$middleName"",
  ""locale"": ""$locale"",
  ""registrationSiteId"": ""$registrationSiteId"",
  ""receiveEmail"": ""$receiveEmail"",
  ""dateOfBirth"": ""$dob"",
  ""mobileNumber"": ""$mobileNumber"",
  ""gender"": ""$gender"",
  ""fuelActivationDate"": ""$fuelActivationDate"",
  ""postalCode"": ""$postalCode"",
  ""country"": ""$country"",
  ""city"": ""$city"",
  ""state"": ""$state"",
  ""bio"": ""$bio"",
  ""jpFirstNameKana"": ""$jpFirstNameKana"",
  ""jpLastNameKana"": ""$jpLastNameKana"",
  ""height"": ""$height"",
  ""weight"": ""$weight"",
  ""distanceUnit"": ""MILES"",
  ""weightUnit"": ""POUNDS"",
  ""heightUnit"": ""FT/INCHES""
}
EOF
}
</code></pre>

<p>It is then easy to use that function in the invocation of curl:</p>

<pre><code>curl -i \
-H ""Accept: application/json"" \
-H ""Content-Type:application/json"" \
-X POST --data ""$(generate_post_data)"" ""https://xxx:xxxxx@xxxx-www.xxxxx.com/xxxxx/xxxx/xxxx""
</code></pre>

<p>This said, here are a few clarifications about shell quoting rules:</p>

<p>The double quotes in the <code>-H</code> arguments (as in <code>-H ""foo bar""</code>) tell bash to keep what's inside as a single argument (even if it contains spaces).</p>

<p>The single quotes in the <code>--data</code> argument (as in <code>--data 'foo bar'</code>) do the same, except they pass all text verbatim (including double quote characters and the dollar sign).</p>

<p>To insert a variable in the middle of a single quoted text, you have to end the single quote, then concatenate with the double quoted variable, and re-open the single quote to continue the text: <code>'foo bar'""$variable""'more foo'</code>.</p>
"
"How do I disable Git Credential Manager for Windows?","37182847","<git><bash>","185","<p>OK, I discovered that you need to either <em>avoid</em> checking the ""Git Credential Manager"" checkbox during the Git for Windows installer, or (after installation) run the Bash shell as <em>Administrator</em> and use <code>git config --edit --system</code> to remove the <code>helper = manager</code> line so that it is no longer registered as a credential helper.</p>

<p>For bonus points, use <code>git config --edit --global</code> and insert:</p>

<pre><code>[core]
    askpass =
</code></pre>

<p>To disable the OpenSSH credentials popup too.</p>
"
"Getting an ""ambiguous redirect"" error","2462385","<bash>","185","<p>Bash can be pretty obtuse sometimes.</p>

<p>The following commands all return different error messages for basically the same error:</p>

<pre><code>$ echo hello &gt;
bash: syntax error near unexpected token `newline`

$ echo hello &gt; ${NONEXISTENT}
bash: ${NONEXISTENT}: ambiguous redirect

$ echo hello &gt; ""${NONEXISTENT}""
bash: : No such file or directory
</code></pre>

<p>Adding quotes around the variable seems to be a good way to deal with the ""ambiguous redirect"" message: You tend to get a better message when you've made a typing mistake -- and <strong>when the error is due to spaces in the filename, using quotes is the fix.</strong></p>
"
"How to append contents of multiple files into one file","18006581","<linux><bash><unix>","184","<p>You need the <code>cat</code> (short for concatenate) command, with shell redirection (<code>&gt;</code>) into your output file </p>

<pre><code>cat 1.txt 2.txt 3.txt &gt; 0.txt
</code></pre>
"
"Remove duplicate entries in a Bash script","9377040","<bash><shell>","184","<p>You can <code>sort</code> then <code>uniq</code>:</p>

<pre><code>$ sort -u input.txt
</code></pre>

<p>Or use <code>awk</code>:</p>

<pre><code>$ awk '!a[$0]++' input.txt
</code></pre>
"
"How do I delete/remove a shell function?","245406","<bash><shell><zsh>","184","<pre><code>unset -f z
</code></pre>

<p>Will unset the function named z.  A couple people have answered with:</p>

<pre><code>unset z
</code></pre>

<p>but if you have a function and a variable named z only the variable will be unset, not the function.</p>
"
"Calling shell functions with xargs","11003418","<bash><sh><xargs>","184","<p>Exporting the function should do it (untested):</p>

<pre><code>export -f echo_var
seq -f ""n%04g"" 1 100 | xargs -n 1 -P 10 -I {} bash -c 'echo_var ""$@""' _ {}
</code></pre>

<p>You can use the builtin <code>printf</code> instead of the external <code>seq</code>:</p>

<pre><code>printf ""n%04g\n"" {1..100} | xargs -n 1 -P 10 -I {} bash -c 'echo_var ""$@""' _ {}
</code></pre>

<p>Also, using <code>return 0</code> and <code>exit 0</code> like that masks any error value that might be produced by the command preceding it. Also, if there's no error, it's the default and thus somewhat redundant.</p>

<p>@phobic mentions that the Bash command <em><strong>could</strong></em> be simplified to</p>

<pre><code>bash -c 'echo_var ""{}""'
</code></pre>

<p>moving the <code>{}</code> directly inside it. <strong>But</strong> it's <strong>vulnerable to command injection</strong> as pointed out by @Sasha.</p>

<p>Here is an example why you <strong>should not use</strong> the embedded format:</p>

<pre><code>$ echo '$(date)' | xargs -I {} bash -c 'echo_var ""{}""'
Sun Aug 18 11:56:45 CDT 2019
</code></pre>

<p>Another example of <strong>why not</strong>:</p>

<pre><code>echo '\""; date\""' | xargs -I {} bash -c 'echo_var ""{}""'
</code></pre>

<p>This is what is output <strong>using the safe format</strong>:</p>

<pre><code>$ echo '$(date)' | xargs -I {} bash -c 'echo_var ""$@""' _ {}
$(date)
</code></pre>

<p>This is comparable to using <a href=""https://blog.codinghorror.com/give-me-parameterized-sql-or-give-me-death/"" rel=""noreferrer"">parameterized</a> SQL <a href=""https://en.wikipedia.org/wiki/Prepared_statement"" rel=""noreferrer"">queries</a> to avoid <a href=""https://rosettacode.org/wiki/Parametrized_SQL_statement"" rel=""noreferrer"">injection</a>.</p>

<p>I'm using <code>date</code> in a command substitution or in escaped quotes here instead of the <code>rm</code> command used in Sasha's comment since it's non-destructive.</p>
"
"How do I forward parameters to other command in bash script?","1537673","<bash><command-line>","183","<p>Use the <a href=""http://www.gnu.org/software/bash/manual/bashref.html#index-shift"" rel=""noreferrer""><code>shift</code></a> built-in command to ""eat"" the arguments. Then call the child process and pass it the <a href=""http://www.gnu.org/software/bash/manual/bashref.html#index-_0040"" rel=""noreferrer""><code>""$@""</code></a> argument to include all remaining arguments. Notice the quotes, they should be kept, since they cause the expansion of the argument list to be properly quoted.</p>
"
"Quick-and-dirty way to ensure only one instance of a shell script is running at a time","185451","<bash><shell><process><lockfile>","183","<p>Here's an implementation that uses a <em>lockfile</em> and echoes a PID into it. This serves as a protection if the process is killed before removing the <em>pidfile</em>:</p>

<pre><code>LOCKFILE=/tmp/lock.txt
if [ -e ${LOCKFILE} ] &amp;&amp; kill -0 `cat ${LOCKFILE}`; then
    echo ""already running""
    exit
fi

# make sure the lockfile is removed when we exit and then claim it
trap ""rm -f ${LOCKFILE}; exit"" INT TERM EXIT
echo $$ &gt; ${LOCKFILE}

# do stuff
sleep 1000

rm -f ${LOCKFILE}
</code></pre>

<p>The trick here is the <code>kill -0</code> which doesn't deliver any signal but just checks if a process with the given PID exists.  Also the call to <code>trap</code> will ensure that the <em>lockfile</em> is removed even when your process is killed (except <code>kill -9</code>).</p>
"
"Temporarily change current working directory in bash to run a command","10382141","<bash><shell><terminal><working-directory>","183","<p>You can run the <code>cd</code> and the executable in a subshell by enclosing the command line in a pair of parentheses:</p>

<pre><code>(cd SOME_PATH &amp;&amp; exec_some_command)
</code></pre>

<p>Demo:</p>

<pre><code>$ pwd
/home/abhijit
$ (cd /tmp &amp;&amp; pwd)  # directory changed in the subshell
/tmp 
$ pwd               # parent shell's pwd is still the same
/home/abhijit
</code></pre>
"
"How to make the hardware beep sound in Mac OS X 10.6","3127977","<bash><macos><applescript><beep>","183","<p>There is no ""hardware beep"" in macOS.</p>

<p>The functionality you're thinking of is an artifact of very old (pre-1990s) IBM PC-compatible hardware. Before most computers had sound cards, most machines had a small speaker or piezo buzzer connected to one of the channels of a timer chip. This could be used to generate simple tones or beeps. Even after many computers integrated sound cards, it remained common for quite some time for computers to route this output to a separate internal speaker. More recently, many computers, especially laptops, have integrated this functionality into the onboard sound card.</p>

<p>(If you're curious about the technical details of how the PC speaker interface worked, <a href=""https://courses.engr.illinois.edu/ece390/books/labmanual/io-devices-speaker.html"" rel=""noreferrer"">there are more details here</a>.)</p>

<p>This hardware has never existed in Apple computers. The only audio output available is through the sound card, and the only system beep in macOS is the user's alert sound.</p>
"
"How to loop over directories in Linux?","2107945","<linux><bash>","183","<pre><code>cd /tmp
find . -maxdepth 1 -mindepth 1 -type d -printf '%f\n'
</code></pre>

<p>A short explanation: </p>

<ul>
<li><p><code>find</code> finds files (quite obviously)</p></li>
<li><p><code>.</code> is the current directory, which after the <code>cd</code> is <code>/tmp</code> (IMHO this is more flexible than having <code>/tmp</code> directly in the <code>find</code> command. You have only one place, the <code>cd</code>, to change, if you want more actions to take place in this folder)</p></li>
<li><p><code>-maxdepth 1</code> and <code>-mindepth 1</code> make sure that <code>find</code> only looks in the current directory and doesn't include <code>.</code> itself in the result</p></li>
<li><p><code>-type d</code> looks only for directories</p></li>
<li><p><code>-printf '%f\n</code> prints only the found folder's name (plus a newline) for each hit.</p></li>
</ul>

<p>Et voilà!</p>
"
"Piping command output to tee but also save exit code of command","6871859","<bash><shell><pipe><sh><tee>","182","<p>Since you're running <code>bash</code>, you can use its <a href=""http://tldp.org/LDP/abs/html/internalvariables.html#PIPESTATUSREF"" rel=""noreferrer"">$PIPESTATUS</a> variable instead of <code>$?</code>:</p>

<pre><code>mvn clean install $@ | tee $logfile
echo ${PIPESTATUS[0]}
</code></pre>
"
"How to redirect stderr and stdout to different files in the same line in script?","7901517","<linux><bash>","182","<p>Just add them in one line <code>command 2&gt;&gt; error 1&gt;&gt; output</code></p>

<p>However, note that <code>&gt;&gt;</code> is for appending if the file already has data. Whereas, <code>&gt;</code> will overwrite any existing data in the file.</p>

<p>So, <code>command 2&gt; error 1&gt; output</code> if you do  not want to append.</p>

<p>Just for completion's sake, you can write <code>1&gt;</code> as just <code>&gt;</code> since the default file descriptor is the output. so <code>1&gt;</code> and <code>&gt;</code> is the same thing.</p>

<p>So, <code>command 2&gt; error 1&gt; output</code> becomes, <code>command 2&gt; error &gt; output</code></p>
"
"How can I match a string with a regex in Bash?","17420994","<regex><string><bash>","181","<p>To match regexes you need to use the <code>=~</code> operator.</p>

<p>Try this:</p>

<pre><code>[[ sed-4.2.2.tar.bz2 =~ tar.bz2$ ]] &amp;&amp; echo matched
</code></pre>

<p>Alternatively, you can use wildcards (instead of regexes) with the <code>==</code> operator:</p>

<pre><code>[[ sed-4.2.2.tar.bz2 == *tar.bz2 ]] &amp;&amp; echo matched
</code></pre>

<p>If portability is not a concern, I recommend using <code>[[</code> instead of <code>[</code> or <code>test</code> as it is safer and more powerful. See <a href=""http://mywiki.wooledge.org/BashFAQ/031"">What is the difference between test, [ and [[ ?</a> for details.</p>
"
"How to check the extension of a filename in a bash script?","407184","<bash><scripting><file>","181","<p>I think you want to say ""Are the last four characters of $file equal to <code>.txt</code>?""  If so, you can use the following:</p>

<pre><code>if [ ${file: -4} == "".txt"" ]
</code></pre>

<p>Note that the space between <code>file:</code> and <code>-4</code> is required, as the ':-' modifier means something different.</p>
"
"How to default to other directory instead of home directory","7017143","<bash><shell><git-bash>","180","<p>Just write that line to a file ""cd.sh"", then do this from your shell prompt:</p>

<pre><code>. ./cd.sh
</code></pre>

<p>Or you can create an alias or function in your <code>$HOME/.bashrc</code> file:</p>

<pre><code>foo() { cd /d/work_space_for_my_company/project/code_source ; }
</code></pre>

<p>If the directory name includes spaces or other shell metacharacters, you'll need quotation marks; it won't hurt to add them even if they're not necessary:</p>

<pre><code>foo() { cd ""/d/Work Space/project/code_source"" ; }
</code></pre>

<p>(Note that I've omitted the <code>../../..</code>; you don't need it.)</p>

<p>EDIT: If you add a line</p>

<pre><code>foo
</code></pre>

<p>to your <code>.bashrc</code> after the function definition, your shell will start in that directory. Or you can just use the <code>cd</code> command directly in your <code>.bashrc</code> if you aren't going to need to use the function later.</p>

<p>(The name <code>foo</code> is just an example; you should pick a more meaningful name.)</p>
"
"String comparison in bash. [[: not found","12230690","<bash><shell><ubuntu-11.04><string-comparison>","180","<p><code>[[</code> is a bash-builtin. Your <code>/bin/bash</code> doesn't seem to be an actual bash.</p>
<p><em>From a comment:</em></p>
<p>Add <code>#!/bin/bash</code> at the top of file</p>
"
"How to get the list of files in a directory in a shell script?","2437452","<bash><shell><directory-listing>","179","<pre><code>for entry in &quot;$search_dir&quot;/*
do
  echo &quot;$entry&quot;
done
</code></pre>
"
"Convert command line arguments into an array in Bash","12711786","<arrays><bash><shell>","179","<p>Actually your command line arguments are <em>practically</em> like an array already. At least, you can treat the <code>$@</code> variable much like an array. That said, you can convert it into an actual array like this:</p>

<pre><code>myArray=( ""$@"" )
</code></pre>

<p>If you just want to type some arguments and feed them into the <code>$@</code> value, use <code>set</code>:</p>

<pre><code>$ set -- apple banana ""kiwi fruit""
$ echo ""$#""
3
$ echo ""$@""
apple banana kiwi fruit
</code></pre>

<p>Understanding how to use the argument structure is particularly useful in POSIX sh, which has nothing else like an array.</p>
"
"How do you run a command for each line of a file?","13939038","<bash><loops><line>","179","<h1>Read a file line by line and execute commands: 4 answers</h1>

<p>This is because there is not only 1 answer...</p>

<ol>
<li><code>shell</code> command line expansion</li>
<li><code>xargs</code> dedicated tool</li>
<li><code>while read</code> with some remarks</li>
<li><code>while read -u</code> using dedicated <em><code>fd</code></em>, for <em>interactive</em> processing (sample)</li>
</ol>

<p>Regarding the OP request: <strong><em>running <code>chmod</code> on all targets listed in file</em></strong>, <code>xargs</code> is the indicated tool. But for some other applications, small amount of files, etc...</p>

<ol>
<li><h2>Read entire file as command line argument.</h2>

<p>If your file is not too big and all files are <em>well named</em> (without spaces or other special chars like quotes), you could use <em><code>shell</code> command line expansion</em>. Simply:</p>

<pre><code>chmod 755 $(&lt;file.txt)
</code></pre>

<p>For small amount of files (lines), this command is the lighter one.</p></li>
<li><h2><code>xargs</code> is the right tool</h2>

<p>For bigger amount of files, or almost <strong><em>any</em></strong> number of lines in your input file...</p>

<p>For many <em>binutils</em> tools, like <code>chown</code>, <code>chmod</code>, <code>rm</code>, <code>cp -t</code> ...</p>

<pre><code>xargs chmod 755 &lt;file.txt
</code></pre>

<p>If you have special chars and/or a lot of lines in <code>file.txt</code>.</p>

<pre><code>xargs -0 chmod 755 &lt; &lt;(tr \\n \\0 &lt;file.txt)
</code></pre>

<p>if your command need to be run exactly 1 time by entry:</p>

<pre><code>xargs -0 -n 1 chmod 755 &lt; &lt;(tr \\n \\0 &lt;file.txt)
</code></pre>

<p>This is not needed for this sample, as <code>chmod</code> accept multiple files as argument, but this match the title of question.</p>

<p>For some special case, you could even define location of file argument in commands generateds by <code>xargs</code>:</p>

<pre><code>xargs -0 -I '{}' -n 1 myWrapper -arg1 -file='{}' wrapCmd &lt; &lt;(tr \\n \\0 &lt;file.txt)
</code></pre>

<h3>Test with <code>seq 1 5</code> as input</h3>

<p>Try this:</p>

<pre><code>xargs -n 1 -I{} echo Blah {} blabla {}.. &lt; &lt;(seq 1 5)
Blah 1 blabla 1..
Blah 2 blabla 2..
Blah 3 blabla 3..
Blah 4 blabla 4..
Blah 5 blabla 5..
</code></pre>

<p>Where commande is done <strong>once per line</strong>.</p></li>
<li><h2><code>while read</code> and variants.</h2>

<p>As OP suggest <code>cat file.txt | while read in; do chmod 755 ""$in""; done</code> will work, but there is 2 issues:</p>

<ul>
<li><p><code>cat |</code> is an <em>useless fork</em>, and</p></li>
<li><p><code>| while ... ;done</code> will become a <em>subshell</em> where environment will disapear after <code>;done</code>.</p></li>
</ul>

<p>So this could be better written:</p>

<pre><code>while read in; do chmod 755 ""$in""; done &lt; file.txt
</code></pre>

<p>But,</p>

<ul>
<li><p>You may be warned about <code>$IFS</code> and <code>read</code> flags:</p>

<pre><code>help read
</code></pre>

<blockquote>
<pre><code>read: read [-r] ... [-d delim] ... [name ...]
    ...
    Reads a single line from the standard input... The line is split
    into fields as with word splitting, and the first word is assigned
    to the first NAME, the second word to the second NAME, and so on...
    Only the characters found in $IFS are recognized as word delimiters.
    ...
    Options:
      ...
      -d delim   continue until the first character of DELIM is read, 
                 rather than newline
      ...
      -r do not allow backslashes to escape any characters
    ...
    Exit Status:
    The return code is zero, unless end-of-file is encountered...
</code></pre>
</blockquote>

<p>In some case, you may need to use</p>

<pre><code>while IFS= read -r in;do chmod 755 ""$in"";done &lt;file.txt
</code></pre>

<p>For avoiding problems with stranges filenames. And maybe if you encouter problems with <em><code>UTF-8</code></em>:</p>

<pre><code>while LANG=C IFS= read -r in ; do chmod 755 ""$in"";done &lt;file.txt
</code></pre></li>
<li><p>While you use <code>STDIN</code> for reading <code>file.txt</code>, your script could not be <em>interactive</em> (you cannot use <code>STDIN</code> anymore).</p></li>
</ul></li>
<li><h2><code>while read -u</code>, using dedicated <em><code>fd</code></em>.</h2>

<p>Syntax: <code>while read ...;done &lt;file.txt</code> will redirect <em><code>STDIN</code></em> to <code>file.txt</code>. That mean, you won't be able to deal with process, until they finish.</p>

<p>If you plan to create <em>interactive</em> tool, you have to avoid use of <em><code>STDIN</code></em> and use some alternative <em>file descriptor</em>.</p>

<p>Constants <em>file descriptors</em> are: <code>0</code> for <em>STDIN</em>, <code>1</code> for <em>STDOUT</em> and <code>2</code> for <em>STDERR</em>. You could see them by:</p>

<pre><code>ls -l /dev/fd/
</code></pre>

<p>or</p>

<pre><code>ls -l /proc/self/fd/
</code></pre>

<p>From there, you have to choose unused number, between <code>0</code> and <code>63</code> (more, in fact, depending on <code>sysctl</code> superuser tool) as <em>file descriptor</em>:</p>

<p>For this demo, I will use <em>fd</em> <code>7</code>:</p>

<p><s></p>

<pre><code>exec 7&lt;file.txt      # Without spaces between `7` and `&lt;`!
ls -l /dev/fd/
</code></pre>

<p></s></p>

<p>Then you could use <code>read -u 7</code> this way:</p>

<pre><code>while read -u 7 filename;do
    ans=;while [ -z ""$ans"" ];do
        read -p ""Process file '$filename' (y/n)? "" -sn1 foo
        [ ""$foo"" ]&amp;&amp; [ -z ""${foo/[yn]}"" ]&amp;&amp; ans=$foo || echo '??'
    done
    if [ ""$ans"" = ""y"" ] ;then
        echo Yes
        echo ""Processing '$filename'.""
    else
        echo No
    fi
done 7&lt;file.txt
</code></pre>

<p><s></p>

<pre><code>done
</code></pre>

<p>To close <code>fd/7</code>:</p>

<pre><code>exec 7&lt;&amp;-            # This will close file descriptor 7.
ls -l /dev/fd/
</code></pre>

<p></s></p>

<p>Nota: I let <s>striked</s> version because this syntax could be usefull, when doing many I/O with parallels process:</p>

<pre><code>mkfifo sshfifo
exec 7&gt; &gt;(ssh -t user@host sh &gt;sshfifo)
exec 6&lt;sshfifo
</code></pre></li>
</ol>
"
"How to assign the output of a Bash command to a variable?","2314750","<bash><shell>","178","<p>Try:</p>

<pre><code>pwd=`pwd`
</code></pre>

<p>or</p>

<pre><code>pwd=$(pwd)
</code></pre>

<blockquote>
  <p>Notice no spaces after the equals sign.</p>
</blockquote>

<p>Also as Mr. Weiss points out; you don't assign to <code>$pwd</code>, you assign to <code>pwd</code>.</p>
"
"How to run the sftp command with a password from Bash script?","5386482","<bash><shell><unix><ssh><sftp>","178","<p>You have a few options other than using public key authentication:</p>
<ol>
<li>Use <a href=""http://www.cyberciti.biz/faq/ssh-passwordless-login-with-keychain-for-scripts/"" rel=""nofollow noreferrer"">keychain</a></li>
<li>Use <a href=""http://www.cyberciti.biz/faq/noninteractive-shell-script-ssh-password-provider/"" rel=""nofollow noreferrer"">sshpass</a> (less secured but probably that meets your requirement)</li>
<li>Use <a href=""https://linux.die.net/man/1/expect"" rel=""nofollow noreferrer"">expect</a> (least secured and more coding needed)</li>
</ol>
<p>If you decide to give sshpass a chance here is a working script snippet to do so:</p>
<pre><code>export SSHPASS=your-password-here
sshpass -e sftp -oBatchMode=no -b - sftp-user@remote-host &lt;&lt; !
   cd incoming
   put your-log-file.log
   bye
!
</code></pre>
"
"How to fix Terminal not loading ~/.bashrc on OS X Lion","7780030","<macos><bash><terminal><osx-lion>","178","<p>Terminal opens a login shell. This means, <code>~/.bash_profile</code> will get executed, <code>~/.bashrc</code> not.</p>

<p>The solution on most systems is to ""require"" the <code>~/.bashrc</code> in the <code>~/.bash_profile</code>: just put this snippet in your <code>~/.bash_profile</code>:</p>

<pre><code>[[ -s ~/.bashrc ]] &amp;&amp; source ~/.bashrc
</code></pre>
"
"How to use mod operator in bash?","5688576","<bash><modulo><arithmetic-expressions>","178","<p>Try the following:</p>

<pre><code> for i in {1..600}; do echo wget http://example.com/search/link$(($i % 5)); done
</code></pre>

<p>The <code>$((    ))</code> syntax does an <a href=""http://www.gnu.org/software/bash/manual/bashref.html#Arithmetic-Expansion"" rel=""noreferrer"">arithmetic evaluation</a> of the contents.</p>
"
"How to concatenate multiple lines of output to one line?","15580144","<linux><bash><unix><grep><tr>","177","<p>Use <code>tr '\n' ' '</code> to translate all newline characters to spaces:</p>

<pre><code>$ grep pattern file | tr '\n' ' '
</code></pre>

<p>Note: <code>grep</code> reads files, <code>cat</code> concatenates files. Don't <code>cat file | grep</code>!</p>

<p><strong>Edit:</strong></p>

<p><code>tr</code> can only handle single character translations. You could use <code>awk</code> to change the output record separator like:</p>

<pre><code>$ grep pattern file | awk '{print}' ORS='"" '
</code></pre>

<p>This would transform:</p>

<pre><code>one
two 
three
</code></pre>

<p>to:</p>

<pre><code>one"" two"" three"" 
</code></pre>
"
"How to get the part of a file after the first line that matches a regular expression?","7103531","<bash><shell><scripting><grep>","177","<p>The following will print the line matching <code>TERMINATE</code> till the end of the file:</p>

<pre><code>sed -n -e '/TERMINATE/,$p'
</code></pre>

<p><strong>Explained:</strong> <code>-n</code> disables default behavior of <code>sed</code> of printing each line after executing its script on it, <code>-e</code> indicated a script to <code>sed</code>, <code>/TERMINATE/,$</code> is an address (line) range selection meaning the first line matching the <code>TERMINATE</code> regular expression (like grep) to the end of the file (<code>$</code>), and <code>p</code> is the print command which prints the current line.</p>

<p>This will print from the line that follows the line matching <code>TERMINATE</code> till the end of the file:<br>
(from AFTER the matching line to EOF, NOT including the matching line)</p>

<pre><code>sed -e '1,/TERMINATE/d'
</code></pre>

<p><strong>Explained:</strong> <code>1,/TERMINATE/</code> is an address (line) range selection meaning the first line for the input to the 1st line matching the <code>TERMINATE</code> regular expression, and <code>d</code> is the delete command which delete the current line and skip to the next line.  As <code>sed</code> default behavior is to print the lines, it will print the lines after <code>TERMINATE</code>  to the end of input.</p>

<p><strong>Edit:</strong></p>

<p>If you want the lines before <code>TERMINATE</code>:</p>

<pre><code>sed -e '/TERMINATE/,$d'
</code></pre>

<p>And if you want both lines before and after <code>TERMINATE</code> in 2 different files in a single pass:</p>

<pre><code>sed -e '1,/TERMINATE/w before
/TERMINATE/,$w after' file
</code></pre>

<p>The before and after files will contain the line with terminate, so to process each you need to use:</p>

<pre><code>head -n -1 before
tail -n +2 after
</code></pre>

<p><strong>Edit2:</strong></p>

<p>IF you do not want to hard-code the filenames in the sed script, you can:</p>

<pre><code>before=before.txt
after=after.txt
sed -e ""1,/TERMINATE/w $before
/TERMINATE/,\$w $after"" file
</code></pre>

<p>But then you have to escape the <code>$</code> meaning the last line so the shell will not try to expand the <code>$w</code> variable (note that we now use double quotes around the script instead of single quotes).</p>

<p>I forgot to tell that the new line is important after the filenames in the script so that sed knows that the filenames end.</p>

<p><br>
<strong>Edit:</strong> 2016-0530</p>

<p>Sébastien Clément asked: ""How would you replace the hardcoded <code>TERMINATE</code> by a variable?""</p>

<p>You would make a variable for the matching text and then do it the same way as the previous example:  </p>

<pre><code>matchtext=TERMINATE
before=before.txt
after=after.txt
sed -e ""1,/$matchtext/w $before
/$matchtext/,\$w $after"" file
</code></pre>

<p>to use a variable for the matching text with the previous examples:</p>

<pre><code>## Print the line containing the matching text, till the end of the file:
## (from the matching line to EOF, including the matching line)
matchtext=TERMINATE
sed -n -e ""/$matchtext/,\$p""
</code></pre>



<pre><code>## Print from the line that follows the line containing the 
## matching text, till the end of the file:
## (from AFTER the matching line to EOF, NOT including the matching line)
matchtext=TERMINATE
sed -e ""1,/$matchtext/d""
</code></pre>



<pre><code>## Print all the lines before the line containing the matching text:
## (from line-1 to BEFORE the matching line, NOT including the matching line)
matchtext=TERMINATE
sed -e ""/$matchtext/,\$d""
</code></pre>

<p>The important points about replacing text with variables in these cases are:  </p>

<ol>
<li>Variables (<code>$variablename</code>) enclosed in <code>single quotes</code> [<code>'</code>] won't ""expand"" but variables inside <code>double quotes</code> [<code>""</code>] will. So, you have to change all the <code>single quotes</code> to <code>double quotes</code> if they contain text you want to replace with a variable.  </li>
<li>The <code>sed</code> ranges also contain a <code>$</code> and are immediately followed by a letter like: <code>$p</code>, <code>$d</code>, <code>$w</code>. They will also look like variables to be expanded, so you have to escape those <code>$</code> characters with a backslash [<code>\</code>] like: <code>\$p</code>, <code>\$d</code>, <code>\$w</code>.</li>
</ol>
"
"Assign output to variable in Bash","8737638","<bash><curl>","177","<p>In shell, you don't put a $ in front of a variable you're assigning.  You only use $IP when you're referring to the variable.</p>

<pre><code>#!/bin/bash

IP=$(curl automation.whatismyip.com/n09230945.asp)

echo ""$IP""

sed ""s/IP/$IP/"" nsupdate.txt | nsupdate
</code></pre>
"
"Dynamic variable names in Bash","16553089","<bash><variables><dynamic><syntax>","176","<p>Use an associative array, with command names as keys.</p>

<pre><code># Requires bash 4, though
declare -A magic_variable=()

function grep_search() {
    magic_variable[$1]=$( ls | tail -1 )
    echo ${magic_variable[$1]}
}
</code></pre>

<p>If you can't use associative arrays (e.g., you must support <code>bash</code> 3), you can use <code>declare</code> to create dynamic variable names:</p>

<pre><code>declare ""magic_variable_$1=$(ls | tail -1)""
</code></pre>

<p>and use indirect parameter expansion to access the value.</p>

<pre><code>var=""magic_variable_$1""
echo ""${!var}""
</code></pre>

<p>See BashFAQ: <a href=""http://mywiki.wooledge.org/BashFAQ/006#Indirection"" rel=""noreferrer"">Indirection - Evaluating indirect/reference variables</a>.</p>
"
"How to split one string into multiple variables in bash shell?","10520623","<bash><shell><variables>","175","<p><em>If</em> your solution doesn't have to be general, i.e. only needs to work for strings like your example, you could do:</p>

<pre><code>var1=$(echo $STR | cut -f1 -d-)
var2=$(echo $STR | cut -f2 -d-)
</code></pre>

<p>I chose <code>cut</code> here because you could simply extend the code for a few more variables...</p>
"
"Get the date (a day before current time) in Bash","1706882","<bash><unix><date><solaris>","175","<p>Sorry not mentioning I on Solaris system.
As such, the -date switch is not available on Solaris bash.</p>

<p>I find out I can get the previous date with little trick on timezone.</p>

<pre><code>DATE=`TZ=MYT+16 date +%Y-%m-%d_%r`
echo $DATE
</code></pre>
"
"eval command in Bash and its typical uses","11065077","<linux><bash><shell><scripting><eval>","175","<p><code>eval</code> takes a string as its argument, and evaluates it as if you'd typed that string on a command line. (If you pass several arguments, they are first joined with spaces between them.)</p>

<p><code>${$n}</code> is a syntax error in bash. Inside the braces, you can only have a variable name, with some possible prefix and suffixes, but you can't have arbitrary bash syntax and in particular you can't use variable expansion. There is a way of saying “the value of the variable whose name is in this variable”, though:</p>

<pre><code>echo ${!n}
one
</code></pre>

<p><code>$(…)</code> runs the command specified inside the parentheses in a subshell (i.e. in a separate process that inherits all settings such as variable values from the current shell), and gathers its output. So <code>echo $($n)</code> runs <code>$n</code> as a shell command, and displays its output. Since <code>$n</code> evaluates to <code>1</code>, <code>$($n)</code> attempts to run the command <code>1</code>, which does not exist.</p>

<p><code>eval echo \${$n}</code> runs the parameters passed to <code>eval</code>. After expansion, the parameters are <code>echo</code> and <code>${1}</code>. So <code>eval echo \${$n}</code> runs the command <code>echo ${1}</code>.</p>

<p>Note that most of the time, you must use double quotes around variable substitutions and command substitutions (i.e. anytime there's a <code>$</code>): <code>""$foo"", ""$(foo)""</code>. <strong>Always put double quotes around variable and command substitutions</strong>, unless you know you need to leave them off. Without the double quotes, the shell performs field splitting (i.e. it splits value of the variable or the output from the command into separate words) and then treats each word as a wildcard pattern. For example:</p>

<pre><code>$ ls
file1 file2 otherfile
$ set -- 'f* *'
$ echo ""$1""
f* *
$ echo $1
file1 file2 file1 file2 otherfile
$ n=1
$ eval echo \${$n}
file1 file2 file1 file2 otherfile
$eval echo \""\${$n}\""
f* *
$ echo ""${!n}""
f* *
</code></pre>

<p><code>eval</code> is not used very often. In some shells, the most common use is to obtain the value of a variable whose name is not known until runtime. In bash, this is not necessary thanks to the <code>${!VAR}</code> syntax. <code>eval</code> is still useful when you need to construct a longer command containing operators, reserved words, etc.</p>
"
"In bash, how does one clear the current input?","1056394","<bash><input>","174","<ol>
<li><p>Press <kbd>Ctrl</kbd>-<kbd>U</kbd> to delete everything before the cursor. The deleted command will be stored into a buffer. Press <kbd>Ctrl</kbd>-<kbd>Y</kbd> to paste the deleted command.</p>

<p>(Optional: Press <kbd>End</kbd> or <kbd>Ctrl</kbd>-<kbd>E</kbd> to jump to the end of the input first.)</p></li>
<li><p>Alternatively, press <kbd>Ctrl</kbd>-<kbd>C</kbd> to abort what you're typing.</p></li>
</ol>
"
"How to send email from Terminal?","8260858","<bash><email><terminal>","174","<p>Go into Terminal and type <code>man mail</code> for help.</p>
<p>You will need to set <code>SMTP</code> up:</p>
<p><a href=""http://hints.macworld.com/article.php?story=20081217161612647"" rel=""noreferrer"">http://hints.macworld.com/article.php?story=20081217161612647</a></p>
<p>See also:</p>
<p><a href=""http://www.mactricksandtips.com/2008/09/send-mail-over-your-network.html"" rel=""noreferrer"">http://www.mactricksandtips.com/2008/09/send-mail-over-your-network.html</a></p>
<p>Eg:</p>
<pre><code>mail -s &quot;hello&quot; &quot;example@example.com&quot; &lt;&lt;EOF
hello
world
EOF
</code></pre>
<p>This will send an email to <code>example@example.com</code> with the subject <code>hello</code> and the message</p>
<blockquote>
<p>Hello</p>
<p>World</p>
</blockquote>
"
"Get yesterday's date in bash on Linux, DST-safe","15374752","<linux><bash>","174","<p>I think this should work, irrespective of how often and when you run it ... </p>

<pre><code>date -d ""yesterday 13:00"" '+%Y-%m-%d'
</code></pre>
"
"Bash script plugin for Eclipse?","1356827","<eclipse><bash><ide>","174","<p><a href=""http://sourceforge.net/projects/shelled/"" rel=""noreferrer"">ShellEd</a> looks promising, does syntax highlighting, and has positive reviews, although I've not tried it myself. It was <a href=""https://bugzilla.redhat.com/show_bug.cgi?id=470792"" rel=""noreferrer"">approved</a> for distro inclusion by Redhat. There's a little more info on the <a href=""http://marketplace.eclipse.org/content/shelled"" rel=""noreferrer"">ShellEd plugin page</a> on the Eclipse site, and <a href=""http://sourceforge.net/apps/trac/shelled/wiki/Documentation/InstallGuide"" rel=""noreferrer"">installation instructions</a> on their wiki.</p>

<p>Note that if you're not running an up-to-date version of Eclipse (as of this writing, Juno) you'll need to use an older version, for instance 2.0.1 is compatible with Indigo.</p>
"
"How to retrieve absolute path given relative","4175264","<bash><shell><path><absolute>","174","<p>use:</p>
<pre><code>find &quot;$(pwd)&quot;/ -type f
</code></pre>
<p>to get all files or</p>
<pre><code>echo &quot;$(pwd)/$line&quot;
</code></pre>
<p>to display full path (if relative path matters to)</p>
"
"How to replace ${} placeholders in a text file?","415677","<bash><command-line><text-processing><templating>","173","<p><a href=""https://en.wikipedia.org/wiki/Sed"" rel=""noreferrer"">Sed</a>!</p>

<p>Given template.txt:</p>

<pre>
The number is ${i}
The word is ${word}
</pre>

<p>we just have to say:</p>

<pre><code>sed -e ""s/\${i}/1/"" -e ""s/\${word}/dog/"" template.txt
</code></pre>

<p>Thanks to Jonathan Leffler for the tip to pass multiple <code>-e</code> arguments to the same <code>sed</code> invocation.</p>
"
"Design patterns or best practices for shell scripts","78497","<design-patterns><bash><shell>","173","<p>I wrote quite complex shell scripts and my first suggestion is ""don't"". The reason is that is fairly easy to make a small mistake that hinders your script, or even make it dangerous.</p>

<p>That said, I don't have other resources to pass you but my personal experience. 
Here is what I normally do, which is overkill, but tends to be solid, although <em>very</em> verbose.</p>

<p><strong>Invocation</strong></p>

<p>make your script accept long and short options. be careful because there are two commands to parse options, getopt and getopts. Use getopt as you face less trouble.</p>

<pre><code>CommandLineOptions__config_file=""""
CommandLineOptions__debug_level=""""

getopt_results=`getopt -s bash -o c:d:: --long config_file:,debug_level:: -- ""$@""`

if test $? != 0
then
    echo ""unrecognized option""
    exit 1
fi

eval set -- ""$getopt_results""

while true
do
    case ""$1"" in
        --config_file)
            CommandLineOptions__config_file=""$2"";
            shift 2;
            ;;
        --debug_level)
            CommandLineOptions__debug_level=""$2"";
            shift 2;
            ;;
        --)
            shift
            break
            ;;
        *)
            echo ""$0: unparseable option $1""
            EXCEPTION=$Main__ParameterException
            EXCEPTION_MSG=""unparseable option $1""
            exit 1
            ;;
    esac
done

if test ""x$CommandLineOptions__config_file"" == ""x""
then
    echo ""$0: missing config_file parameter""
    EXCEPTION=$Main__ParameterException
    EXCEPTION_MSG=""missing config_file parameter""
    exit 1
fi
</code></pre>

<p>Another important point is that a program should always return zero if completes successfully, non-zero if something went wrong.</p>

<p><strong>Function calls</strong></p>

<p>You can call functions in bash, just remember to define them before the call. Functions are like scripts, they can only return numeric values. This means that you have to invent a different strategy to return string values. My strategy is to use a variable called RESULT to store the result, and returning 0 if the function completed cleanly. 
Also, you can raise exceptions if you are returning a value different from zero, and then set two ""exception variables"" (mine: EXCEPTION and EXCEPTION_MSG), the first containing the exception type and the second a human readable message.</p>

<p>When you call a function, the parameters of the function are assigned to the special vars $0, $1 etc. I suggest you to put them into more meaningful names. declare the variables inside the function as local:</p>

<pre><code>function foo {
   local bar=""$0""
}
</code></pre>

<p><strong>Error prone situations</strong></p>

<p>In bash, unless you declare otherwise, an unset variable is used as an empty string. This is very dangerous in case of typo, as the badly typed variable will not be reported, and it will be evaluated as empty. use</p>

<pre><code>set -o nounset
</code></pre>

<p>to prevent this to happen. Be careful though, because if you do this, the program will abort every time you evaluate an undefined variable. For this reason, the only way to check if a variable is not defined is the following:</p>

<pre><code>if test ""x${foo:-notset}"" == ""xnotset""
then
    echo ""foo not set""
fi
</code></pre>

<p>You can declare variables as readonly:</p>

<pre><code>readonly readonly_var=""foo""
</code></pre>

<p><strong>Modularization</strong></p>

<p>You can achieve ""python like"" modularization if you use the following code:</p>

<pre><code>set -o nounset
function getScriptAbsoluteDir {
    # @description used to get the script path
    # @param $1 the script $0 parameter
    local script_invoke_path=""$1""
    local cwd=`pwd`

    # absolute path ? if so, the first character is a /
    if test ""x${script_invoke_path:0:1}"" = 'x/'
    then
        RESULT=`dirname ""$script_invoke_path""`
    else
        RESULT=`dirname ""$cwd/$script_invoke_path""`
    fi
}

script_invoke_path=""$0""
script_name=`basename ""$0""`
getScriptAbsoluteDir ""$script_invoke_path""
script_absolute_dir=$RESULT

function import() { 
    # @description importer routine to get external functionality.
    # @description the first location searched is the script directory.
    # @description if not found, search the module in the paths contained in $SHELL_LIBRARY_PATH environment variable
    # @param $1 the .shinc file to import, without .shinc extension
    module=$1

    if test ""x$module"" == ""x""
    then
        echo ""$script_name : Unable to import unspecified module. Dying.""
        exit 1
    fi

    if test ""x${script_absolute_dir:-notset}"" == ""xnotset""
    then
        echo ""$script_name : Undefined script absolute dir. Did you remove getScriptAbsoluteDir? Dying.""
        exit 1
    fi

    if test ""x$script_absolute_dir"" == ""x""
    then
        echo ""$script_name : empty script path. Dying.""
        exit 1
    fi

    if test -e ""$script_absolute_dir/$module.shinc""
    then
        # import from script directory
        . ""$script_absolute_dir/$module.shinc""
    elif test ""x${SHELL_LIBRARY_PATH:-notset}"" != ""xnotset""
    then
        # import from the shell script library path
        # save the separator and use the ':' instead
        local saved_IFS=""$IFS""
        IFS=':'
        for path in $SHELL_LIBRARY_PATH
        do
            if test -e ""$path/$module.shinc""
            then
                . ""$path/$module.shinc""
                return
            fi
        done
        # restore the standard separator
        IFS=""$saved_IFS""
    fi
    echo ""$script_name : Unable to find module $module.""
    exit 1
} 
</code></pre>

<p>you can then import files with the extension .shinc with the following syntax</p>

<p>import ""AModule/ModuleFile""</p>

<p>Which will be searched in SHELL_LIBRARY_PATH. As you always import in the global namespace, remember to prefix all your functions and variables with a proper prefix, otherwise you risk name clashes. I use double underscore as the python dot.</p>

<p>Also, put this as first thing in your module</p>

<pre><code># avoid double inclusion
if test ""${BashInclude__imported+defined}"" == ""defined""
then
    return 0
fi
BashInclude__imported=1
</code></pre>

<p><strong>Object oriented programming</strong></p>

<p>In bash, you cannot do object oriented programming, unless you build a quite complex system of allocation of objects (I thought about that. it's feasible, but insane).
In practice, you can however do ""Singleton oriented programming"": you have one instance of each object, and only one.</p>

<p>What I do is: i define an object into a module (see the modularization entry). Then I define empty vars (analogous to member variables) an init function (constructor) and member functions, like in this example code</p>

<pre><code># avoid double inclusion
if test ""${Table__imported+defined}"" == ""defined""
then
    return 0
fi
Table__imported=1

readonly Table__NoException=""""
readonly Table__ParameterException=""Table__ParameterException""
readonly Table__MySqlException=""Table__MySqlException""
readonly Table__NotInitializedException=""Table__NotInitializedException""
readonly Table__AlreadyInitializedException=""Table__AlreadyInitializedException""

# an example for module enum constants, used in the mysql table, in this case
readonly Table__GENDER_MALE=""GENDER_MALE""
readonly Table__GENDER_FEMALE=""GENDER_FEMALE""

# private: prefixed with p_ (a bash variable cannot start with _)
p_Table__mysql_exec="""" # will contain the executed mysql command 

p_Table__initialized=0

function Table__init {
    # @description init the module with the database parameters
    # @param $1 the mysql config file
    # @exception Table__NoException, Table__ParameterException

    EXCEPTION=""""
    EXCEPTION_MSG=""""
    EXCEPTION_FUNC=""""
    RESULT=""""

    if test $p_Table__initialized -ne 0
    then
        EXCEPTION=$Table__AlreadyInitializedException   
        EXCEPTION_MSG=""module already initialized""
        EXCEPTION_FUNC=""$FUNCNAME""
        return 1
    fi


    local config_file=""$1""

      # yes, I am aware that I could put default parameters and other niceties, but I am lazy today
      if test ""x$config_file"" = ""x""; then
          EXCEPTION=$Table__ParameterException
          EXCEPTION_MSG=""missing parameter config file""
          EXCEPTION_FUNC=""$FUNCNAME""
          return 1
      fi


    p_Table__mysql_exec=""mysql --defaults-file=$config_file --silent --skip-column-names -e ""

    # mark the module as initialized
    p_Table__initialized=1

    EXCEPTION=$Table__NoException
    EXCEPTION_MSG=""""
    EXCEPTION_FUNC=""""
    return 0

}

function Table__getName() {
    # @description gets the name of the person 
    # @param $1 the row identifier
    # @result the name

    EXCEPTION=""""
    EXCEPTION_MSG=""""
    EXCEPTION_FUNC=""""
    RESULT=""""

    if test $p_Table__initialized -eq 0
    then
        EXCEPTION=$Table__NotInitializedException
        EXCEPTION_MSG=""module not initialized""
        EXCEPTION_FUNC=""$FUNCNAME""
        return 1
    fi

    id=$1

      if test ""x$id"" = ""x""; then
          EXCEPTION=$Table__ParameterException
          EXCEPTION_MSG=""missing parameter identifier""
          EXCEPTION_FUNC=""$FUNCNAME""
          return 1
      fi

    local name=`$p_Table__mysql_exec ""SELECT name FROM table WHERE id = '$id'""`
      if test $? != 0 ; then
        EXCEPTION=$Table__MySqlException
        EXCEPTION_MSG=""unable to perform select""
        EXCEPTION_FUNC=""$FUNCNAME""
        return 1
      fi

    RESULT=$name
    EXCEPTION=$Table__NoException
    EXCEPTION_MSG=""""
    EXCEPTION_FUNC=""""
    return 0
}
</code></pre>

<p><strong>Trapping and handling signals</strong></p>

<p>I found this useful to catch and handle exceptions.</p>

<pre><code>function Main__interruptHandler() {
    # @description signal handler for SIGINT
    echo ""SIGINT caught""
    exit
} 
function Main__terminationHandler() { 
    # @description signal handler for SIGTERM
    echo ""SIGTERM caught""
    exit
} 
function Main__exitHandler() { 
    # @description signal handler for end of the program (clean or unclean). 
    # probably redundant call, we already call the cleanup in main.
    exit
} 

trap Main__interruptHandler INT
trap Main__terminationHandler TERM
trap Main__exitHandler EXIT

function Main__main() {
    # body
}

# catch signals and exit
trap exit INT TERM EXIT

Main__main ""$@""
</code></pre>

<p><strong>Hints and tips</strong></p>

<p>If something does not work for some reason, try to reorder the code. Order is important and not always intuitive.</p>

<p>do not even consider working with tcsh. it does not support functions, and it's horrible in general. </p>

<p>Hope it helps, although please note. If you have to use the kind of things I wrote here, it means that your problem is too complex to be solved with shell. use another language. I had to use it due to human factors and legacy.</p>
"
"Difference between single and double square brackets in Bash","13542832","<bash><if-statement>","172","<p>Single <code>[]</code> are posix shell compliant condition tests.</p>

<p>Double <code>[[]]</code> are an extension to the standard <code>[]</code> and are supported by bash and other shells (e.g. zsh, ksh). They support extra operations (as well as the standard posix operations). For example: <code>||</code> instead of <code>-o</code> and regex matching with <code>=~</code>. A fuller list of differences can be found in the <a href=""http://www.gnu.org/software/bash/manual/bashref.html#Conditional-Constructs"" rel=""noreferrer"">bash manual section on conditional constructs</a>.</p>

<p>Use <code>[]</code> whenever you want your script to be portable across shells. Use <code>[[]]</code> if you want conditional expressions not supported by <code>[]</code> and don't need to be portable.</p>
"
"RVM is not a function, selecting rubies with 'rvm use ...' will not work","23963018","<ruby><bash><rvm>","172","<p>Your console is not running as a login shell and hence have no access to rvm function. If you are running Ubuntu, you can:</p>

<ol>
<li>Open console</li>
<li>Select Edit -> Profile Preferences</li>
<li>Select tab: Title and Command</li>
<li>Check box 'Run command as a login shell'</li>
<li>Restart terminal</li>
</ol>
"
"How to make a programme continue to run after log out from ssh?","954302","<linux><bash><ssh>","172","<p>Assuming that you have a program running in the foreground, <strong>press ctrl-Z</strong>, then:</p>

<pre><code>[1]+  Stopped                 myprogram
$ disown -h %1
$ bg 1
[1]+ myprogram &amp;
$ logout
</code></pre>

<p>If there is only one job, then you don't need to specify the job number. Just use <code>disown -h</code> and <code>bg</code>.</p>

<h2>Explanation of the above steps:</h2>

<p>You press ctrl-Z. The system suspends the running program, displays a job number and a ""Stopped"" message and returns you to a bash prompt. </p>

<p>You type the <code>disown -h %1</code> command (here, I've used a <code>1</code>, but you'd use the job number that was displayed in the <code>Stopped</code> message) which marks the job so it ignores the <code>SIGHUP</code> signal (it will not be stopped by logging out). </p>

<p>Next, type the <code>bg</code> command using the same job number; this resumes the running of the program in the background and a message is displayed confirming that. </p>

<p>You can now log out and it will continue running..</p>
"
"How do I make this file.sh executable via double click?","8409946","<bash><macos><terminal><executable>","172","<p>By default, <code>*.sh</code> files are opened in a text editor (Xcode or TextEdit). To create a shell script that will execute in Terminal when you open it, name it with the “command” extension, e.g., <code>file.command</code>. By default, these are sent to Terminal, which will execute the file as a shell script.</p>

<p>You will also need to ensure the file is executable, e.g.:</p>

<pre><code>chmod +x file.command
</code></pre>

<p>Without this, Terminal will refuse to execute it.</p>

<p>Note that the script does not have to begin with a <code>#!</code> prefix in this specific scenario, because Terminal specifically arranges to execute it with your default shell. (Of course, you can add a <code>#!</code> line if you want to customize which shell is used or if you want to ensure that you can execute it from the command line while using a different shell.)</p>

<p>Also note that Terminal executes the shell script without changing the working directory. You’ll need to begin your script with a <code>cd</code> command if you actually need it to run with a particular working directory.</p>
"
"How to loop through a directory recursively to delete files with certain extensions","4638874","<bash>","171","<p><code>find</code> is just made for that.</p>

<pre><code>find /tmp -name '*.pdf' -or -name '*.doc' | xargs rm
</code></pre>
"
"uppercase first character in a variable with bash","12487424","<bash>","171","<pre><code>foo=""$(tr '[:lower:]' '[:upper:]' &lt;&lt;&lt; ${foo:0:1})${foo:1}""
</code></pre>
"
"How to determine function name from inside a function","1835943","<bash><function>","171","<p>You can use <code>${FUNCNAME[0]}</code> in <code>bash</code> to get the function name.</p>
"
"Viewing full output of PS command","2159860","<linux><bash><shell><process>","171","<p>It is likely that you're using a pager such as <a href=""http://www.greenwoodsoftware.com/less/"" rel=""noreferrer""><code>less</code></a> or <a href=""https://www.jedsoft.org/most/"" rel=""noreferrer""><code>most</code></a> since the output of <code>ps aux</code> is longer than a screenful. If so, the following options will cause (or force) long lines to wrap instead of being truncated.</p>

<pre><code>ps aux | less -+S

ps aux | most -w
</code></pre>

<p>If you use either of the following commands, lines won't be wrapped but you can use your arrow keys or other movement keys to scroll left and right.</p>

<pre><code>ps aux | less -S    # use arrow keys, or Esc-( and Esc-), or Alt-( and Alt-) 

ps aux | most       # use arrow keys, or &lt; and &gt; (Tab can also be used to scroll right)
</code></pre>

<p>Lines are always wrapped for <code>more</code> and <code>pg</code>.</p>

<p>When <code>ps aux</code> is used in a pipe, the <code>w</code> option is unnecessary since <code>ps</code> only uses screen width when output is to the terminal.</p>
"
"Bash if statement with multiple conditions throws an error","16203088","<bash><if-statement><flags>","171","<p>Use <code>-a</code> (for and) and <code>-o</code> (for or) operations.</p>

<p><a href=""http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html"">tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html</a></p>

<p>Update</p>

<p>Actually you could still use <code>&amp;&amp;</code> and <code>||</code> with the <code>-eq</code> operation. So your script would be like this:</p>

<pre><code>my_error_flag=1
my_error_flag_o=1
if [ $my_error_flag -eq 1 ] ||  [ $my_error_flag_o -eq 2 ] || ([ $my_error_flag -eq 1 ] &amp;&amp; [ $my_error_flag_o -eq 2 ]); then
      echo ""$my_error_flag""
else
    echo ""no flag""
fi
</code></pre>

<p>Although in your case you can discard the last two expressions and just stick with one or operation like this:</p>

<pre><code>my_error_flag=1
my_error_flag_o=1
if [ $my_error_flag -eq 1 ] ||  [ $my_error_flag_o -eq 2 ]; then
      echo ""$my_error_flag""
else
    echo ""no flag""
fi
</code></pre>
"
"Commenting in a Bash script inside a multiline command","1455988","<bash><syntax><comments>","171","<p>This will have some overhead, but technically it does answer your question:</p>

<pre><code>echo abc `#Put your comment here` \
     def `#Another chance for a comment` \
     xyz, etc.
</code></pre>

<p>And for pipelines specifically, there is a clean solution with no overhead:</p>

<pre><code>echo abc |        # Normal comment OK here
     tr a-z A-Z | # Another normal comment OK here
     sort |       # The pipelines are automatically continued
     uniq         # Final comment
</code></pre>

<p>See Stack Overflow question <em><a href=""https://stackoverflow.com/q/9522631/#12797512"">How to Put Line Comment for a Multi-line Command</a></em>.</p>
"
"source command not found in sh shell","13702425","<bash><shell><sh>","171","<p><code>/bin/sh</code> is usually some other shell trying to mimic The Shell. Many distributions use <code>/bin/bash</code> for <code>sh</code>, it supports <code>source</code>. On Ubuntu, though, <code>/bin/dash</code> is used which does not support <code>source</code>. Most shells use <code>.</code> instead of <code>source</code>. If you cannot edit the script, try to change the shell which runs it.</p>
"
"Delete terminal history in Linux","6709349","<linux><bash><terminal>","171","<p>You can clear your bash history like this:</p>

<p><code>history -cw</code></p>
"
"Search and replace in bash using regular expressions","13043344","<regex><bash>","170","<p>Use <a href=""http://www.gnu.org/software/sed/manual/"" rel=""noreferrer"">sed</a>:</p>

<pre><code>MYVAR=ho02123ware38384you443d34o3434ingtod38384day
echo ""$MYVAR"" | sed -e 's/[a-zA-Z]/X/g' -e 's/[0-9]/N/g'
# prints XXNNNNNXXXXNNNNNXXXNNNXNNXNNNNXXXXXXNNNNNXXX
</code></pre>

<p>Note that the subsequent <code>-e</code>'s are processed in order.  Also, the <code>g</code> flag for the expression will match all occurrences in the input.</p>

<p>You can also pick your favorite tool using this method, i.e. perl, awk, e.g.:</p>

<pre><code>echo ""$MYVAR"" | perl -pe 's/[a-zA-Z]/X/g and s/[0-9]/N/g'
</code></pre>

<p>This may allow you to do more creative matches...  For example, in the snip above, the numeric replacement would not be used unless there was a match on the first expression (due to lazy <code>and</code> evaluation).  And of course, you have the full language support of Perl to do your bidding...</p>
"
"Intersection of two lists in Bash","2696055","<bash>","170","<pre><code>comm -12  &lt;(ls 1) &lt;(ls 2)
</code></pre>
"
"Shell script to delete directories older than n days","13868821","<bash><shell>","170","<p>This will do it recursively for you:</p>

<pre><code>find /path/to/base/dir/* -type d -ctime +10 -exec rm -rf {} \;
</code></pre>

<p><strong>Explanation:</strong></p>

<ul>
<li><code>find</code>: the unix command for finding files / directories / links etc.</li>
<li><code>/path/to/base/dir</code>: the directory to start your search in.</li>
<li><code>-type d</code>: only find directories</li>
<li><code>-ctime +10</code>: only consider the ones with modification time older than 10 days</li>
<li><code>-exec ... \;</code>: for each such result found, do the following command in <code>...</code></li>
<li><code>rm -rf {}</code>: recursively force remove the directory; the <code>{}</code> part is where the find result gets substituted into from the previous part.</li>
</ul>

<hr>

<p><strong>Alternatively, use:</strong></p>

<pre><code>find /path/to/base/dir/* -type d -ctime +10 | xargs rm -rf
</code></pre>

<p>Which is a bit more efficient, because it amounts to:</p>

<pre><code>rm -rf dir1 dir2 dir3 ...
</code></pre>

<p>as opposed to:</p>

<pre><code>rm -rf dir1; rm -rf dir2; rm -rf dir3; ...
</code></pre>

<p>as in the <code>-exec</code> method.</p>

<hr>

<p>With modern versions of <code>find</code>, you can replace the <code>;</code> with <code>+</code> and it will do the equivalent of the <code>xargs</code> call for you, passing as many files as will fit on each exec system call:</p>

<pre><code>find . -type d -ctime +10 -exec rm -rf {} +
</code></pre>
"
"Run ssh and immediately execute command","18522647","<bash><unix><ssh>","169","<pre><code>ssh -t 'command; bash -l'
</code></pre>

<p>will execute the command and then start up a login shell when it completes. For example:</p>

<pre><code>ssh -t user@domain.com 'cd /some/path; bash -l'
</code></pre>
"
"Piping both stdout and stderr in bash?","16497317","<bash><stdout><stderr><piping>","168","<p>(Note that <code>&amp;&gt;&gt;file</code> <em>appends</em> to a file while <code>&amp;&gt;</code> would redirect and <em>overwrite</em> a previously existing file.)</p>

<p>To combine <code>stdout</code> and <code>stderr</code> you would redirect the latter to the former using <code>2&gt;&amp;1</code>. This redirects stderr (file descriptor 2) to stdout (file descriptor 1), e.g.:</p>

<pre><code>$ { echo ""stdout""; echo ""stderr"" 1&gt;&amp;2; } | grep -v std
stderr
$
</code></pre>

<p><code>stdout</code> goes to stdout, <code>stderr</code> goes to stderr. <code>grep</code> only sees <code>stdout</code>, hence <code>stderr</code> prints to the terminal.</p>

<p>On the other hand:</p>

<pre><code>$ { echo ""stdout""; echo ""stderr"" 1&gt;&amp;2; } 2&gt;&amp;1 | grep -v std
$
</code></pre>

<p>After writing to both stdout and stderr, <code>2&gt;&amp;1</code> redirects stderr back to stdout and <code>grep</code> sees both strings on stdin, thus filters out both.</p>

<p>You can read more about redirection <a href=""http://www.gnu.org/software/bash/manual/bashref.html#Redirections"">here</a>.</p>

<p>Regarding your example (POSIX):</p>

<pre><code>cmd-doesnt-respect-difference-between-stdout-and-stderr 2&gt;&amp;1 | grep -i SomeError
</code></pre>

<p>or, using <code>&gt;=bash-4</code>:</p>

<pre><code>cmd-doesnt-respect-difference-between-stdout-and-stderr |&amp; grep -i SomeError
</code></pre>
"
"Bash: infinite sleep (infinite blocking)","2935183","<linux><bash><sleep><infinite>","168","<p><code>sleep infinity</code> does exactly what it suggests and works without cat abuse.</p>
"
"bash ""if [ false ];"" returns true instead of false -- why?","19670061","<bash><boolean><conditional-operator>","168","<p>You are running the <code>[</code> (aka <code>test</code>) command with the argument ""false"", not running the command <code>false</code>. Since ""false"" is a non-empty string, the <code>test</code> command always succeeds. To actually run the command, drop the <code>[</code> command.</p>

<pre><code>if false; then
   echo ""True""
else
   echo ""False""
fi
</code></pre>
"
"Command substitution: backticks or dollar sign / paren enclosed?","9405478","<bash><shell><command><substitution>","168","<p>There are several questions/issues here, so I'll repeat each section of the poster's text, block-quoted, and followed by my response.</p>

<blockquote>
  <p>What's the preferred syntax, and why? Or are they pretty much interchangeable?</p>
</blockquote>

<p>I would say that the <code>$(some_command)</code> form is preferred over the <code>`some_command`</code> form. The second form, using a pair of backquotes (the ""`"" character, also called a backtick and a grave accent), is the historical way of doing it. The first form, using dollar sign and parentheses, is a newer POSIX form, which means it's probably a more standard way of doing it. In turn, I'd think that that means it's more likely to work correctly with different shells and with different *nix implementations.</p>

<p>Another reason given for preferring the first (POSIX) form is that it's easier to read, especially when command substitutions are nested. Plus, with the backtick form, the backtick characters have to be backslash-escaped in the nested (inner) command substitutions.</p>

<p>With the POSIX form, you don't need to do that.</p>

<p>As far as whether they're interchangeable, well, I'd say that, in general, they are interchangeable, apart from the exceptions you mentioned for escaped characters. However, I don't know and cannot say whether all modern shells and all modern *nixes support both forms. I doubt that they do, especially older shells/older *nixes. If I were you, I wouldn't depend on interchangeability without first running a couple of quick, simple tests of each form on any shell/*nix implementations that you plan to run your finished scripts on.</p>

<blockquote>
  <p>I tend to favor the first, simply because my text editor seems to know what it is, and does syntax highlighting appropriately.</p>
</blockquote>

<p>It's unfortunate that your editor doesn't seem to support the POSIX form; maybe you should check to see if there's an update to your editor that supports the POSIX way of doing it. Long shot maybe, but who knows? Or, maybe you should even consider trying a different editor.</p>

<p>GGG, what text editor are you using???</p>

<blockquote>
  <p>I read here that escaped characters act a bit differently in each case, but it's not clear to me which behavior is preferable, or if it just depends on the situation.</p>
</blockquote>

<p>I'd say that it depends on what you're trying to accomplish; in other words, whether you're using escaped characters along with command substitution or not.</p>

<blockquote>
  <p>Side question: Is it bad practice to use both forms in one script, for example when nesting command substitutions?</p>
</blockquote>

<p>Well, it might make the script slightly easier to READ (typographically speaking), but harder to UNDERSTAND! Someone reading your script (or YOU, reading it six months later!) would likely wonder why you didn't just stick to one form or the other--unless you put some sort of note about why you did this in the comments. Plus, mixing both forms in one script would make that script less likely to be portable: In order for the script to work properly, the shell that's executing it has to support BOTH forms, not just one form or the other.</p>

<p>For making a shell script understandable, I'd personally prefer sticking to one form or the other throughout any one script, unless there's a good technical reason to do otherwise. Moreover, I'd prefer the POSIX form over the older form; again, unless there's a good technical reason to do otherwise.</p>

<p>For more on the topic of command substitution, and the two different forms for doing it, I suggest you refer to the section on command substitution in the O'Reilly book ""Classic Shell Scripting,"" second edition, by Robbins and Beebe. In that section, the authors state that the POSIX form for command substitution ""is recommended for all new development."" I have no financial interest in this book; it's just one I have (and love) on shell scripting, though it's more for intermediate or advanced shell scripting, and not really for beginning shell scripting.</p>

<p>-B.</p>
"
"How can I remove the extension of a filename in a shell script?","12152626","<bash><shell><sh><cut><gnu-coreutils>","167","<p>You should be using the <a href=""https://www.gnu.org/software/bash/manual/bashref.html#Command-Substitution"" rel=""noreferrer"">command substitution</a> syntax <code>$(command)</code> when you want to execute a command in script/command.</p>

<p>So your line would be </p>

<pre><code>name=$(echo ""$filename"" | cut -f 1 -d '.')
</code></pre>

<p>Code explanation:</p>

<ol>
<li><code>echo</code> get the value of the variable <code>$filename</code> and send it to standard output</li>
<li>We then grab the output and pipe it to the <code>cut</code> command</li>
<li>The <code>cut</code> will use the . as delimiter (also known as separator) for cutting the string into segments and by <code>-f</code> we select which segment we want to have in output</li>
<li>Then the <code>$()</code> command substitution will get the output and return its value</li>
<li>The returned value will be assigned to the variable named <code>name</code></li>
</ol>

<p>Note that this gives the portion of the variable up to the first period <code>.</code>:</p>

<pre><code>$ filename=hello.world
$ echo ""$filename"" | cut -f 1 -d '.'
hello
$ filename=hello.hello.hello
$ echo ""$filename"" | cut -f 1 -d '.'
hello
$ filename=hello
$ echo ""$filename"" | cut -f 1 -d '.'
hello
</code></pre>
"
"Check if passed argument is file or directory in Bash","4665051","<bash><shell>","167","<p>That should work. I am not sure why it's failing. You're quoting your variables properly. What happens if you use this script with double <code>[[</code> <code>]]</code>?</p>

<pre><code>if [[ -d $PASSED ]]; then
    echo ""$PASSED is a directory""
elif [[ -f $PASSED ]]; then
    echo ""$PASSED is a file""
else
    echo ""$PASSED is not valid""
    exit 1
fi
</code></pre>

<p>Double square brackets is a bash extension to <code>[ ]</code>. It doesn't require variables to be quoted, not even if they contain spaces.</p>

<p>Also worth trying: <code>-e</code> to test if a path exists without testing what type of file it is.</p>
"
"bash: Bad Substitution","20615217","<string><bash><ubuntu><substitution>","167","<p>The default shell (<code>/bin/sh</code>) under Ubuntu points to <code>dash</code>, not <code>bash</code>.</p>

<pre><code>me@pc:~$ readlink -f $(which sh)
/bin/dash
</code></pre>

<p>So if you <code>chmod +x your_script_file.sh</code> and then run it with <code>./your_script_file.sh</code>, or if you run it with <code>bash your_script_file.sh</code>, it should work fine.</p>

<p>Running it with <code>sh your_script_file.sh</code> will not work because the hashbang line will be ignored and the script will be interpreted by <code>dash</code>, which does not support that string substitution syntax.</p>
"
"Send string to stdin","6541109","<bash><redirect><stdin><io-redirection>","166","<p>You can use one-line <code>heredoc</code></p>

<pre><code>cat &lt;&lt;&lt; ""This is coming from the stdin""
</code></pre>

<p>the above is the same as</p>

<pre><code>cat &lt;&lt;EOF
This is coming from the stdin
EOF
</code></pre>

<p>or you can redirect output from a command, like</p>

<pre><code>diff &lt;(ls /bin) &lt;(ls /usr/bin)
</code></pre>

<p>or you can read as</p>

<pre><code>while read line
do
   echo =$line=
done &lt; some_file
</code></pre>

<p>or simply</p>

<pre><code>echo something | read param
</code></pre>
"
"Why is $$ returning the same id as the parent process?","21063765","<bash><shell><pid><subshell>","166","<p><code>$$</code> is defined to return the process ID of the parent in a subshell; from the man page under ""Special Parameters"":</p>

<blockquote>
  <p>$      Expands to the process ID of the shell.  In a () subshell, it expands to the process ID of the current shell, not the subshell. </p>
</blockquote>

<p>In <code>bash</code> 4, you can get the process ID of the child with <code>BASHPID</code>.</p>

<pre><code>~ $ echo $$
17601
~ $ ( echo $$; echo $BASHPID )
17601
17634
</code></pre>
"
"How to prevent rm from reporting that a file was not found?","10247472","<bash><rm>","166","<p>The main use of <code>-f</code> is to force the removal of files that would
not be removed using <code>rm</code> by itself (as a special case, it ""removes""
non-existent files, thus suppressing the error message).</p>

<p>You can also just redirect the error message using</p>

<pre><code>$ rm file.txt 2&gt; /dev/null
</code></pre>

<p>(or your operating system's equivalent). You can check the value of <code>$?</code>
immediately after calling <code>rm</code> to see if a file was actually removed or not.</p>
"
"How does a Linux/Unix Bash script know its own PID?","2493642","<bash><scripting><pid>","166","<p>The variable '$$' contains the PID.</p>
"
"Bash script - variable content as a command to run","5998066","<bash>","166","<p>You just need to do:</p>

<pre><code>#!/bin/bash
count=$(cat last_queries.txt | wc -l)
$(perl test.pl test2 $count)
</code></pre>

<p>However, if you want to call your Perl command later, and that's why you want to assign it to a variable, then:</p>

<pre><code>#!/bin/bash
count=$(cat last_queries.txt | wc -l)
var=""perl test.pl test2 $count"" # You need double quotes to get your $count value substituted.

...stuff...

eval $var
</code></pre>

<p>As per Bash's help:</p>

<pre class=""lang-none prettyprint-override""><code>~$ help eval
eval: eval [arg ...]
    Execute arguments as a shell command.

    Combine ARGs into a single string, use the result as input to the shell,
    and execute the resulting commands.

    Exit Status:
    Returns exit status of command or success if command is null.
</code></pre>
"
"Getting a 'source: not found' error when using source in a bash script","670191","<bash><virtualenv>","165","<p>If you're writing a bash script, call it by name:</p>

<pre><code>#!/bin/bash
</code></pre>

<p>/bin/sh is not guaranteed to be bash. This caused a ton of broken scripts in Ubuntu some years ago (IIRC).</p>

<p>The source builtin works just fine in bash; but you might as well just use dot like Norman suggested.</p>
"
"Adding git branch on the Bash command prompt","15883416","<git><bash><ubuntu>","165","<h2>git 1.9.3 or later: use <code>__git_ps1</code></h2>

<p>Git provides a shell script called <a href=""https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh"" rel=""noreferrer""><code>git-prompt.sh</code></a>, which includes a function <code>__git_ps1</code> that</p>

<blockquote>
  <p>prints text to add to bash PS1 prompt (includes branch name)</p>
</blockquote>

<p>Its most basic usage is:</p>

<pre><code>$ __git_ps1
(master)
</code></pre>

<p>It also takes an optional format string:</p>

<pre><code>$ __git_ps1 'git:[%s]'
git:[master]
</code></pre>

<h3>How to Get It</h3>

<p>First, copy the file to somewhere (e.g. <code>~/.git-prompt.sh</code>).</p>

<p>Option 1: use an existing copy on your filesystem.  Example (Mac OS X 10.15):</p>

<pre><code>$ find / -name 'git-prompt.sh' -type f -print -quit 2&gt;/dev/null
/Library/Developer/CommandLineTools/usr/share/git-core/git-prompt.sh
</code></pre>

<p>Option 2: Pull the script <a href=""https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh"" rel=""noreferrer"">from GitHub</a>.</p>

<p>Next, add the following line to your <code>.bashrc/.zshrc</code>:</p>

<pre><code>source ~/.git-prompt.sh
</code></pre>

<p>Finally, change your <code>PS1</code> to call <code>__git_ps1</code> as command-substitution:</p>

<p>Bash: </p>

<pre><code>PS1='[\u@\h \W$(__git_ps1 "" (%s)"")]\$ '
</code></pre>

<p>Zsh:</p>

<pre><code>setopt PROMPT_SUBST ; PS1='[%n@%m %c$(__git_ps1 "" (%s)"")]\$ '
</code></pre>

<h3>git &lt; 1.9.3</h3>

<p>But note that only git 1.9.3 (May 2014) <a href=""https://unix.stackexchange.com/questions/33617/how-can-i-update-to-a-newer-version-of-git-using-apt-get/170831#170831"">or later</a> allows you to <em>safely</em> display that branch name(!)</p>

<p>See <a href=""https://github.com/git/git/commit/8976500cbbb13270398d3b3e07a17b8cc7bff43f"" rel=""noreferrer"">commit 8976500</a> by <a href=""https://github.com/richardhansen"" rel=""noreferrer"">Richard Hansen (<code>richardhansen</code>)</a>:</p>

<blockquote>
  <p>Both bash and zsh subject the value of PS1 to <strong>parameter expansion</strong>, <strong>command substitution</strong>, and arithmetic expansion.  </p>
  
  <p>Rather than include the raw, unescaped branch name in <code>PS1</code> when running in two- or
  three-argument mode, construct <code>PS1</code> to reference a variable that holds the branch name.  </p>
  
  <p>Because the shells do not recursively expand, this avoids arbitrary code execution by specially-crafted branch names such as </p>
</blockquote>

<pre><code>'$(IFS=_;cmd=sudo_rm_-rf_/;$cmd)'.
</code></pre>

<p>What devious mind would name a branch like that? ;) (<a href=""http://xkcd.com/327/"" rel=""noreferrer"">Beside a Mom as in xkcd</a>)</p>

<h3>More Examples</h3>

<p><a href=""https://stackoverflow.com/users/172274/still-dreaming-1"">still_dreaming_1</a> reports <a href=""https://stackoverflow.com/questions/15883416/adding-git-branch-on-the-bash-command-prompt/24716445?noredirect=1#comment54332815_24716445"">in the comments</a>:</p>

<blockquote>
  <p>This seems to work great if you want a color prompt with <code>xterm</code> (in my <code>.bashrc</code>): </p>
</blockquote>

<pre><code>PS1='\[\e]0;\u@\h: \w\a\]\n${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\03‌​3[01;34m\]\w\[\033[00m\]$(__git_ps1)\$ ' 
</code></pre>

<blockquote>
  <p>Everything is a different color, including the branch.</p>
</blockquote>

<p>In  in Linux Mint 17.3 Cinnamon 64-bit: </p>

<pre><code>PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[01;34m\] \w\[\033[00m\]$(__git_ps1) \$ ' 
</code></pre>
"
"How to add leading zeros for for-loop in shell?","18460123","<bash><for-loop>","164","<p>Use the following syntax:</p>
<pre><code>$ for i in {01..05}; do echo &quot;$i&quot;; done
01
02
03
04
05
</code></pre>
<p>Disclaimer: Leading zeros only work in <code>&gt;=bash-4</code>.</p>
<p>If you want to use <code>printf</code>, nothing prevents you from putting its result in a variable for further use:</p>
<pre><code>$ foo=$(printf &quot;%02d&quot; 5)
$ echo &quot;${foo}&quot;
05
</code></pre>
"
"How to replace an entire line in a text file by line number","11145270","<bash><text><replace><sed>","164","<p>Not the greatest, but this should work:</p>

<pre><code>sed -i 'Ns/.*/replacement-line/' file.txt
</code></pre>

<p>where <code>N</code> should be replaced by your target line number. This replaces the line in the original file. To save the changed text in a different file, drop the <code>-i</code> option:</p>

<pre><code>sed 'Ns/.*/replacement-line/' file.txt &gt; new_file.txt
</code></pre>
"
"How do I fetch lines before/after the grep result in bash?","12444808","<bash><shell><ubuntu>","164","<p>You can use the <code>-B</code> and <code>-A</code> to print lines before and after the match.</p>

<pre><code>grep -i -B 10 'error' data
</code></pre>

<p>Will print the 10 lines before the match, including the matching line itself.</p>
"
"How to display a specific user's commits in svn log?","4499910","<svn><bash><version-control>","163","<p>You could use this:</p>

<pre><code>svn log | sed -n '/USERNAME/,/-----$/ p' 
</code></pre>

<p>It will show you every commit made by the specified user (USERNAME).</p>

<p><strong>UPDATE</strong></p>

<p>As suggested by @bahrep, <a href=""http://svnbook.red-bean.com/en/1.8/svn.ref.svn.html#svn.ref.svn.sw.search"" rel=""noreferrer"">subversion 1.8</a> comes with a <code>--search</code> option.</p>
"
"Bash foreach loop","4162821","<bash><foreach>","163","<p>Something like this would do:</p>

<pre><code>xargs cat &lt;filenames.txt
</code></pre>

<p>The <code>xargs</code> program reads its standard input, and for each line of input runs the <code>cat</code> program with the input lines as argument(s).</p>

<p>If you really want to do this in a loop, you can:</p>

<pre><code>for fn in `cat filenames.txt`; do
    echo ""the next file is $fn""
    cat $fn
done
</code></pre>
"
"How to use > in an xargs command?","845863","<bash><redirect><xargs>","163","<p>Do not make the mistake of doing this:</p>

<pre><code>sh -c ""grep ABC {} &gt; {}.out""
</code></pre>

<p>This will break under a lot of conditions, including funky filenames and is impossible to quote right. Your <code>{}</code> must always be a single completely separate argument to the command to avoid code injection bugs.  What you need to do, is this:</p>

<pre><code>xargs -I{} sh -c 'grep ABC ""$1"" &gt; ""$1.out""' -- {}
</code></pre>

<p>Applies to <code>xargs</code> as well as <code>find</code>.</p>

<p>By the way, never use xargs without the <code>-0</code> option (unless for very rare and controlled one-time interactive use where you aren't worried about destroying your data).</p>

<p>Also don't parse <code>ls</code>.  Ever.  Use globbing or <code>find</code> instead: <a href=""http://mywiki.wooledge.org/ParsingLs"" rel=""noreferrer""><a href=""http://mywiki.wooledge.org/ParsingLs"" rel=""noreferrer"">http://mywiki.wooledge.org/ParsingLs</a></a></p>

<p>Use <code>find</code> for everything that needs recursion and a simple loop with a glob for everything else:</p>

<pre><code>find /foo -exec sh -c 'grep ""$1"" &gt; ""$1.out""' -- {} \;
</code></pre>

<p>or non-recursive:</p>

<pre><code>for file in *; do grep ""$file"" &gt; ""$file.out""; done
</code></pre>

<p>Notice the proper use of quotes.</p>
"
"Move all files except one","670460","<linux><bash><glob>","163","<p>Put the following to your .bashrc </p>

<pre><code>shopt -s extglob
</code></pre>

<p>It extends regexes.
You can then move all files except one by</p>

<pre><code>mv !(fileOne) ~/path/newFolder
</code></pre>

<h2>Exceptions in relation to other commands</h2>

<p>Note that, in copying directories, the forward-flash cannot be used in the name as noticed in the thread <a href=""https://stackoverflow.com/a/31597198/54964"">Why extglob except breaking except condition?</a>:</p>

<pre><code>cp -r !(Backups.backupdb) /home/masi/Documents/
</code></pre>

<p>so <code>Backups.backupdb/</code> is wrong here before the negation and I would not use it neither in moving directories because of the risk of using wrongly then globs with other commands and possible other exceptions.</p>
"
"Delete all but the most recent X files in bash","25785","<bash><unix><scripting>","162","<p>The problems with the existing answers:</p>
<ul>
<li>inability to handle filenames with embedded spaces or newlines.
<ul>
<li>in the case of solutions that invoke <code>rm</code> directly on an unquoted command substitution (<code>rm `...`</code>), there's an added risk of unintended globbing.</li>
</ul>
</li>
<li>inability to distinguish between files and directories (i.e., if <em>directories</em> happened to be among the 5 most recently modified filesystem items, you'd effectively retain <em>fewer</em> than 5 files, and applying <code>rm</code> to directories will fail).</li>
</ul>
<p><a href=""https://stackoverflow.com/a/299911/45375"">wnoise's answer</a> addresses these issues, but the solution is <em>GNU</em>-specific (and quite complex).</p>
<p>Here's a pragmatic, <strong>POSIX-compliant solution</strong> that comes with only <strong>one caveat</strong>: it cannot handle filenames with embedded <em>newlines</em> - but I don't consider that a real-world concern for most people.</p>
<p><sup>For the record, here's the explanation for why it's generally not a good idea to parse <code>ls</code> output: <a href=""http://mywiki.wooledge.org/ParsingLs"" rel=""nofollow noreferrer"">http://mywiki.wooledge.org/ParsingLs</a></sup></p>
<pre><code>ls -tp | grep -v '/$' | tail -n +6 | xargs -I {} rm -- {}
</code></pre>
<p><sup>Note: This command operates in the <strong><em>current</em> directory</strong>; to <strong>target a directory explicitly</strong>, use a subshell (<code>(...)</code>):<br />
<code>(cd /path/to &amp;&amp; ls -tp | grep -v '/$' | tail -n +6 | xargs -I {} rm -- {})</code><br />
The same applies analogously to the commands below.</sup></p>
<p>The above is <strong>inefficient</strong>, because <code>xargs</code> has to invoke <code>rm</code> once for <em>each</em> filename.<br />
Your platform's <code>xargs</code> may allow you to solve this problem:</p>
<p>If you have <strong><em>GNU</em> <code>xargs</code></strong>, use <code>-d '\n'</code>, which makes <code>xargs</code> consider each input line a separate argument, yet passes as many arguments as will fit on a command line <em>at once</em>:</p>
<pre><code>ls -tp | grep -v '/$' | tail -n +6 | xargs -d '\n' -r rm --
</code></pre>
<p><sup><code>-r</code> (<code>--no-run-if-empty</code>) ensures that <code>rm</code> is not invoked if there's no input.</sup></p>
<p>If you have <strong><em>BSD</em> <code>xargs</code></strong> (including on <strong>macOS</strong>), you can use <code>-0</code> to handle <code>NUL</code>-separated input, after first translating newlines to <code>NUL</code> (<code>0x0</code>) chars., which also passes (typically) all filenames <em>at once</em> (will also work with GNU <code>xargs</code>):</p>
<pre><code>ls -tp | grep -v '/$' | tail -n +6 | tr '\n' '\0' | xargs -0 rm --
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><p><code>ls -tp</code> prints the names of filesystem items sorted by how recently they were modified , in descending order (most recently modified items first) (<code>-t</code>), with directories printed with a trailing <code>/</code> to mark them as such (<code>-p</code>).</p>
<ul>
<li>Note: It is the fact that <code>ls -tp</code> always outputs file / directory <em>names</em> only, not full paths, that necessitates the subshell approach mentioned above for targeting a directory other than the current one (<code>(cd /path/to &amp;&amp; ls -tp ...)</code>).</li>
</ul>
</li>
<li><p><code>grep -v '/$'</code> then weeds out directories from the resulting listing, by omitting (<code>-v</code>) lines that have a trailing <code>/</code> (<code>/$</code>).</p>
<ul>
<li><em>Caveat</em>: Since a <em>symlink that points to a directory</em> is technically not itself a directory, such symlinks will <em>not</em> be excluded.</li>
</ul>
</li>
<li><p><code>tail -n +6</code> skips the first <em>5</em> entries in the listing, in effect returning all <em>but</em> the 5 most recently modified files, if any.<br />
Note that in order to exclude <code>N</code> files, <code>N+1</code> must be passed to <code>tail -n +</code>.</p>
</li>
<li><p><code>xargs -I {} rm -- {}</code> (and its variations) then invokes on <code>rm</code> on all these files; if there are no matches at all, <code>xargs</code> won't do anything.</p>
<ul>
<li><code>xargs -I {} rm -- {}</code> defines placeholder <code>{}</code> that represents each input line <em>as a whole</em>, so <code>rm</code> is then invoked once for each input line, but with filenames with embedded spaces handled correctly.</li>
<li><code>--</code> in all cases ensures that any filenames that happen to start with <code>-</code> aren't mistaken for <em>options</em> by <code>rm</code>.</li>
</ul>
</li>
</ul>
<hr />
<p>A <strong>variation</strong> on the original problem, <strong>in case the matching files need to be processed <em>individually</em> or <em>collected in a shell array</em></strong>:</p>
<pre><code># One by one, in a shell loop (POSIX-compliant):
ls -tp | grep -v '/$' | tail -n +6 | while IFS= read -r f; do echo &quot;$f&quot;; done

# One by one, but using a Bash process substitution (&lt;(...), 
# so that the variables inside the `while` loop remain in scope:
while IFS= read -r f; do echo &quot;$f&quot;; done &lt; &lt;(ls -tp | grep -v '/$' | tail -n +6)

# Collecting the matches in a Bash *array*:
IFS=$'\n' read -d '' -ra files  &lt; &lt;(ls -tp | grep -v '/$' | tail -n +6)
printf '%s\n' &quot;${files[@]}&quot; # print array elements
</code></pre>
"
"Fastest way(s) to move the cursor on a terminal command line?","657130","<bash><terminal><window>","162","<p>Since this hasn't been closed yet, here are a few more options.</p>

<ul>
<li>Use <kbd>Ctrl</kbd>+<kbd>x</kbd> followed by <kbd>Ctrl</kbd>+<kbd>e</kbd> to open the current line in the editor specified by <code>$FCEDIT</code> or <code>$EDITOR</code> or <code>emacs</code> (tried in that order).</li>
<li>If you ran the command earlier, hit <kbd>Ctrl</kbd>+<kbd>r</kbd> for a reverse history search and type <code>option25</code> (in this case). The line will be displayed. Hit <kbd>Tab</kbd> to start editing at this point.</li>
<li>Use history expansion with the <code>s///</code> modifier. E.g. <code>!-2:s/--option25/--newoption/</code> would rerun the second-to-last command, but replace option25. To modify the last <code>./cmd</code> command, use the <code>!string</code> syntax: <code>!./cmd:s/--option25/--newoption/</code><br>
Any delimiter may be used in place of / in the substitution.</li>
<li>If editing the previous line, you can use quick substitution: <code>^--option25^--newoption</code></li>
<li>Character search. This was mentioned by Pax, and can be done in regular emacs-mode with <kbd>Ctrl</kbd>+<kbd>]</kbd> for forward search, and <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>]</kbd> for backward search.</li>
</ul>

<p>I recommend the second option. <kbd>Ctrl</kbd>+<kbd>r</kbd> is really handy and fast, no mucking about with editors, and you see the results before the command is run (unlike the history expansions).</p>
"
"How to use sed to remove the last n lines of a file","13380607","<linux><bash><shell><sed>","162","<p>I don't know about <code>sed</code>, but it can be done with <code>head</code>:</p>

<pre><code>head -n -2 myfile.txt
</code></pre>
"
"Find files containing a given text","6153152","<bash><find>","162","<pre><code>egrep -ir --include=*.{php,html,js} ""(document.cookie|setcookie)"" .
</code></pre>

<p>The <code>r</code> flag means to search recursively (search subdirectories). The <code>i</code> flag means case insensitive.</p>

<p>If you just want file names add the <code>l</code> (lowercase <code>L</code>) flag:</p>

<pre><code>egrep -lir --include=*.{php,html,js} ""(document.cookie|setcookie)"" .
</code></pre>
"
"Root user/sudo equivalent in Cygwin?","4090301","<bash><cygwin><root><sudo>","161","<p>I answered this question on <a href=""https://superuser.com/a/699281/93684"">SuperUser</a> but only after the OP disregarded the unhelpful answer that was at the time the only answer to the question.</p>

<p><strong>Here is the proper way to elevate permissions in Cygwin, copied from my own answer on SuperUser:</strong></p>

<p>I found the answer on <a href=""http://cygwin.com/ml/cygwin/2010-04/msg00651.html"" rel=""noreferrer"">the Cygwin mailing list</a>. To run <code>command</code> with elevated privileges in Cygwin, precede the command with <code>cygstart --action=runas</code> like this:</p>

<pre><code>$ cygstart --action=runas command
</code></pre>

<p><strong>This will open a Windows dialogue box asking for the Admin password and run the command if the proper password is entered.</strong></p>

<p>This is easily scripted, so long as <code>~/bin</code> is in your path. Create a file <code>~/bin/sudo</code> with the following content:</p>

<pre><code>#!/usr/bin/bash
cygstart --action=runas ""$@""
</code></pre>

<p>Now make the file executable:</p>

<pre><code>$ chmod +x ~/bin/sudo
</code></pre>

<p>Now you can run commands with <strong>real elevated privileges</strong>:</p>

<pre><code>$ sudo elevatedCommand
</code></pre>

<p>You may need to add <code>~/bin</code> to your path. You can run the following command on the Cygwin CLI, or add it to <code>~/.bashrc</code>:</p>

<pre><code>$ PATH=$HOME/bin:$PATH
</code></pre>

<p>Tested on 64-bit Windows 8.</p>

<p>You could also instead of above steps add an alias for this command to <code>~/.bashrc</code>:</p>

<pre><code># alias to simulate sudo
alias sudo='cygstart --action=runas'
</code></pre>
"
"How to merge every two lines into one from the command line?","9605232","<bash><awk><sed><grep>","161","<p>awk:</p>

<pre><code>awk 'NR%2{printf ""%s "",$0;next;}1' yourFile
</code></pre>

<p>note, there is an empty line at the end of output.</p>

<p>sed:</p>

<pre><code>sed 'N;s/\n/ /' yourFile
</code></pre>
"
"How can I select random files from a directory in bash?","414164","<bash><random>","160","<p>Here's a script that uses GNU sort's random option:</p>

<pre><code>ls |sort -R |tail -$N |while read file; do
    # Something involving $file, or you can leave
    # off the while to just get the filenames
done
</code></pre>
"
"How to debug a bash script?","951336","<bash><shell>","160","<pre><code>sh -x script [arg1 ...]
bash -x script [arg1 ...]
</code></pre>

<p>These give you a trace of what is being executed.  (See also 'Clarification' near the bottom of the answer.)</p>

<p>Sometimes, you need to control the debugging within the script.  In that case, as <a href=""https://stackoverflow.com/users/110662/cheeto"">Cheeto</a> <a href=""https://stackoverflow.com/a/951371/15168"">reminded</a> me, you can use:</p>

<pre><code>set -x
</code></pre>

<p>This turns debugging on.  You can then turn it off again with:</p>

<pre><code>set +x
</code></pre>

<p>(You can find out the current tracing state by analyzing <code>$-</code>, the current flags, for <code>x</code>.)</p>

<p>Also, shells generally provide options '<code>-n</code>' for 'no execution' and '<code>-v</code>' for 'verbose' mode; you can use these in combination to see whether the shell thinks it could execute your script — occasionally useful if you have an unbalanced quote somewhere.</p>

<hr>

<p>There is contention that the '<code>-x</code>' option in Bash is different from other shells (see the comments).  The <a href=""http://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin"" rel=""noreferrer"">Bash Manual</a> says:</p>

<ul>
<li><p>-x</p>

<p>Print a trace of simple commands, <code>for</code> commands, <code>case</code> commands, <code>select</code> commands, and arithmetic <code>for</code> commands and their arguments or associated word lists after they are expanded and before they are executed. The value of the <code>PS4</code> variable is expanded and the resultant value is printed before the command and its expanded arguments. </p></li>
</ul>

<p>That much does not seem to indicate different behaviour at all.  I don't see any other relevant references to '<code>-x</code>' in the manual.  It does not describe differences in the startup sequence.</p>

<p><em>Clarification</em>: On systems such as a typical Linux box, where '<code>/bin/sh</code>' is a symlink to '<code>/bin/bash</code>' (or wherever the Bash executable is found), the two command lines achieve the equivalent effect of running the script with execution trace on.  On other systems (for example, Solaris, and some more modern variants of Linux), <code>/bin/sh</code> is not Bash, and the two command lines would give (slightly) different results.  Most notably, '<code>/bin/sh</code>' would be confused by constructs in Bash that it does not recognize at all.  (On Solaris, <code>/bin/sh</code> is a Bourne shell; on modern Linux, it is sometimes Dash — a smaller, more strictly POSIX-only shell.)  When invoked by name like this, the 'shebang' line ('<code>#!/bin/bash</code>' vs <code>'#!/bin/sh</code>') at the start of the file has no effect on how the contents are interpreted.</p>

<p>The Bash manual has a section on <a href=""http://www.gnu.org/software/bash/manual/bash.html#Bash-POSIX-Mode"" rel=""noreferrer"">Bash POSIX mode</a> which, contrary to a long-standing but erroneous version of this answer (see also the comments below), does describe in extensive detail the difference between 'Bash invoked as <code>sh</code>' and 'Bash invoked as <code>bash</code>'.</p>

<p>When debugging a (Bash) shell script, it will be sensible and sane — necessary even — to use the shell named in the shebang line with the <code>-x</code> option.  Otherwise, you may (will?) get different behaviour when debugging from when running the script.</p>
"
"List files with certain extensions with ls and grep","1447625","<bash><shell><macos><grep>","160","<p>Why not:</p>

<pre><code>ls *.{mp3,exe,mp4}
</code></pre>

<p>I'm not sure where I learned it - but I've been using this.</p>
"
"UNIX export command","7328223","<bash><shell><unix>","159","<p>When you execute a program the child program inherits its environment variables from the parent. For instance if <code>$HOME</code> is set to <code>/root</code> in the parent then the child's <code>$HOME</code> variable is also set to <code>/root</code>.</p>

<p>This only applies to environment variable that are marked for export. If you set a variable at the command-line like</p>

<pre><code>$ FOO=""bar""
</code></pre>

<p>That variable will not be visible in child processes. Not unless you export it:</p>

<pre><code>$ export FOO
</code></pre>

<p>You can combine these two statements into a single one in bash (but not in old-school sh):</p>

<pre><code>$ export FOO=""bar""
</code></pre>

<p>Here's a quick example showing the difference between exported and non-exported variables. To understand what's happening know that <code>sh -c</code> creates a child shell process which inherits the parent shell's environment.</p>

<pre><code>$ FOO=bar
$ sh -c 'echo $FOO'

$ export FOO
$ sh -c 'echo $FOO'
bar
</code></pre>

<p><strong>Note:</strong> To get help on shell built-in commands use <code>help export</code>. Shell built-ins are commands that are part of your shell rather than independent executables like <code>/bin/ls</code>.</p>
"
"Run a string as a command within a Bash script","2355148","<bash><shell><command-line-arguments>","159","<p>You can use <code>eval</code> to execute a string:</p>

<pre><code>eval $illcommando
</code></pre>
"
"How can I remove all text after a character in bash?","4168371","<bash>","159","<p>An example might have been useful, but if I understood you correctly, this would work:</p>
<pre><code>echo &quot;Hello: world&quot; | cut -f1 -d&quot;:&quot;
</code></pre>
<p>This will convert <code>Hello: world</code> into <code>Hello</code>.</p>
"
"count (non-blank) lines-of-code in bash","114814","<bash><unix><count><lines><nonblank>","158","<pre><code>cat foo.c | sed '/^\s*$/d' | wc -l
</code></pre>

<p>And if you consider comments blank lines:</p>

<pre><code>cat foo.pl | sed '/^\s*#/d;/^\s*$/d' | wc -l
</code></pre>

<p>Although, that's language dependent. </p>
"
"How to go to each directory and execute a command?","7470165","<bash><shell><unix><find>","158","<p>You can do the following, when your current directory is <code>parent_directory</code>:</p>

<pre><code>for d in [0-9][0-9][0-9]
do
    ( cd ""$d"" &amp;&amp; your-command-here )
done
</code></pre>

<p>The <code>(</code> and <code>)</code> create a subshell, so the current directory isn't changed in the main script.</p>
"
"Use of an exclamation mark in a Git commit message via the command line","5131948","<git><bash>","158","<p>Use single quotes instead of double quotes</p>

<pre><code>git commit -am 'Nailed it!'
</code></pre>

<p>Alternatively, if you need to use double quotes for whatever reason but still want a literal <code>!</code> then turn off history expansion at the top of your script via <code>set +H</code></p>
"
"Find all files with a filename beginning with a specified string?","4034896","<bash><find>","158","<p>Use <code>find</code> with a wildcard:</p>
<pre class=""lang-sh prettyprint-override""><code>find . -name 'mystring*'
</code></pre>
"